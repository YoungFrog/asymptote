/*****
 * runtime.in
 * Tom Prince 2005/4/15
 *
 * Generate the runtime functions used by the vm::stack machine.
 *
 *****/

/* Autogenerated routines are specified like this (separated by a formfeed):
type asyname:cname(cparams)
{
  C code
}
*/


void     => primVoid()
int      => primInt()
bool     => primBoolean()
double   => primReal()
string*  => primString()
string   => primString() 
pen      => primPen()
pair     => primPair()
triple   => primTriple()
path     => primPath()
guide*   => primGuide()
file*    => primFile()
picture* => primPicture()
transform => primTransform()
callable* => voidFunction()
runnable* => primCode()
array* => primArray()  
boolarray* => boolArray()
intarray*  => intArray()
realarray* => realArray()
realarray2* => realArray2()
pairarray* => pairArray()
triplearray* => tripleArray()
patharray* => pathArray()  
guidearray* => guideArray()  
transformarray* => transformArray()
penarray* => penArray()  
penarray2* => penArray2()  
stringarray* => stringArray()
stringarray2* => stringArray2()

#include <cfloat>
#include "angle.h"
#include "pair.h"
#include "triple.h"
#include "transform.h"
#include "path.h"
#include "pen.h"
#include "guide.h"
#include "picture.h"
#include "drawpath.h"
#include "drawfill.h"
#include "drawclipbegin.h"
#include "drawclipend.h"
#include "drawlabel.h"
#include "drawverbatim.h"
#include "drawgsave.h"
#include "drawgrestore.h"
#include "drawlayer.h"
#include "drawimage.h"
#include "drawgroup.h"
#include "fileio.h"
#include "genv.h"
#include "builtin.h"
#include "texfile.h"
#include "pipestream.h"
#include "parser.h"
#include "stack.h"
#include "util.h"
#include "mathop.h"
#include "callable.h"
#include "stm.h"
  
#ifdef HAVE_LIBFFTW3
#include "fftw++.h"
#endif
  
#if defined(HAVE_LIBREADLINE) && defined(HAVE_LIBCURSES)
#include <readline/readline.h>
#include <readline/history.h>
#endif

using namespace vm;
using namespace camp;
using namespace settings;

namespace run {
using camp::pair;
using mem::string;
using vm::array;
using vm::frame;
using vm::stack;
using camp::transform;
using absyntax::runnable;

callable *atExitFunction=NULL;
callable *atDrawFunction=NULL;
  
typedef array boolarray;
typedef array intarray;
typedef array realarray;
typedef array realarray2;
typedef array pairarray;
typedef array triplearray;
typedef array patharray;
typedef array guidearray;
typedef array transformarray;
typedef array penarray;
typedef array penarray2;
typedef array stringarray;
typedef array stringarray2;
}

using vm::array;
using types::function;
using types::primVoid;
using types::primBoolean;
using types::primInt;
using types::primReal;
using types::primPair;
using types::primTriple;
using types::primPen;
using types::primPath;
using types::primGuide;
using types::primPicture;
using types::primString;
using types::primCode;
using types::primArray;
using types::primFile;
using types::primTransform;
using types::boolArray;
using types::intArray;
using types::realArray;
using types::realArray2;
using types::pairArray;
using types::tripleArray;
using types::pathArray;
using types::guideArray;
using types::transformArray;
using types::penArray;
using types::penArray2;
using types::stringArray;
using types::stringArray2;
using types::formal;

namespace loop {
  void doIRunnable(absyntax::runnable *r, bool embedded=false);
  void doITree(absyntax::block *tree, bool embedded=false);
}
  
function *voidFunction()
{
  return new function(primVoid());
}

const int camp::ColorComponents[]={0,0,1,3,4,0};

namespace vm {
const char *arraymismatch="operation attempted on arrays of different lengths";
}

namespace run {
  
const char *arraymin="cannot take min of empty array";
const char *arraymax="cannot take max of empty array";

static inline int Round(double x) 
{
  return int(x+((x >= 0) ? 0.5 : -0.5));
}

inline int sgn(double x) 
{
  return (x > 0.0 ? 1 : (x < 0.0 ? -1 : 0));
}

inline void CheckReallocate(double *& A, size_t n, size_t& old)
{
  if(n > old) {delete A; A=new double[n]; old=n;}
}

inline void CheckReallocate(double *& A, double *& B, size_t n, size_t& old)
{
  if(n > old) {delete A; A=new double[n]; delete B; B=new double[n]; old=n;}
}

void outOfBounds(const char *op, size_t len, int n)
{
  ostringstream buf;
  buf << op << " array of length " << len << " with out-of-bounds index "
      << n;
  error(buf.str().c_str());
}

item& arrayRead(array *a, int n)  
{
  size_t len=checkArray(a);
  bool cyclic=a->cyclic();
  if(cyclic && len > 0) n=imod(n,len);
  else if(n < 0 || n >= (int) len) outOfBounds("reading",len,n);
  return (*a)[(unsigned) n];
}

// Helper function to create deep arrays.
static array* deepArray(int depth, int *dims)
{
  assert(depth > 0);
  
  if (depth == 1) {
    return new array(dims[0]);
  } else {
    int length = dims[0];
    depth--; dims++;

    array *a = new array(length);

    for (int index = 0; index < length; index++) {
      (*a)[index] = deepArray(depth, dims);
    }
    return a;
  }
}
  
array *copyArray(array *a)
{
  size_t size=checkArray(a);
  array *c=new array(size);
  for(size_t i=0; i < size; i++) 
    (*c)[i]=(*a)[i];
  return c;
}

array *copyArray2(array *a)
{
  size_t size=checkArray(a);
  array *c=new array(size);
  for(size_t i=0; i < size; i++) {
    array *ai=read<array*>(a,i);
    size_t aisize=checkArray(ai);
    array *ci=new array(aisize);
    (*c)[i]=ci;
    for(size_t j=0; j < aisize; j++) 
      (*ci)[j]=(*ai)[j];
  }
  return c;
}

void writestring(stack *s)
{
  callable *suffix=pop<callable *>(s,NULL);
  string S=pop<string>(s);
  vm::item it=pop(s);
  bool defaultfile=isdefault(it);
  camp::file *f=defaultfile ? &camp::Stdout : vm::get<camp::file*>(it);
  if(!f->isOpen()) return;
  if(S != "") f->write(S);
  if(f->text()) {
    if(suffix) {
      s->push(f);
      suffix->call(s);
    } else if(defaultfile) f->writeline();
  }
}

void dividebyzero(size_t i)
{
  std::ostringstream buf;
  if(i > 0) buf << "array element " << i << ": ";
  buf << "Divide by zero";
  error(buf.str().c_str());
}
  
void integeroverflow(size_t i)
{
  std::ostringstream buf;
  if(i > 0) buf << "array element " << i << ": ";
  buf << "Integer overflow";
  error(buf.str().c_str());
}
  
#if defined(HAVE_LIBREADLINE) && defined(HAVE_LIBCURSES)
typedef mem::map<CONST string, HISTORY_STATE> historyMap_t;
historyMap_t historyMap;
static HISTORY_STATE history_save;

// Store a deep copy of the current readline history in dest.
void store_history(HISTORY_STATE *dest)
{
  HISTORY_STATE *src=history_get_history_state();
  *dest=*src;
  for(int i=0; i < src->length; ++i)
    dest->entries[i]=src->entries[i];
}

const char nosave='\n';

string historyfilename(const string &name) 
{
  return historyname+"_"+name;
}

int readline_startup_hook()
{
#ifdef __CYGWIN__
  rl_set_key("\\M-[3~",rl_delete,rl_get_keymap());
  rl_set_key("\\M-[2~",rl_overwrite_mode,rl_get_keymap());
#endif    
  return 0;
}

void init_readline(bool tabcompletion=true) 
{
  static bool first=true;
  if(first) {
    first=false;
#ifdef __CYGWIN__
    rl_startup_hook=readline_startup_hook;
#endif    
  }
  rl_bind_key('\t',tabcompletion ? rl_complete : rl_insert);
}
 
#endif

void cleanup()
{
  defaultpen=camp::pen::startupdefaultpen();
  if(!interact::interactive) settings::scrollLines=0;
  
  if(TeXinitialized) {
    camp::TeXpipepreamble.clear();
    camp::TeXpreamble.clear();
    camp::tex.pipeclose();
    TeXinitialized=false;
  }

#if defined(HAVE_LIBREADLINE) && defined(HAVE_LIBCURSES)
  store_history(&history_save);
  int nlines=getSetting<int>("historylines");
  for(historyMap_t::iterator h=historyMap.begin(); h != historyMap.end(); 
      ++h) {
    history_set_history_state(&h->second);
    stifle_history(nlines);
    if(h->first[0] != nosave) write_history(historyfilename(h->first).c_str());
  }
  history_set_history_state(&history_save);
#endif
}

void exitFunction(stack *Stack)
{
  if(atExitFunction && !nullfunc::instance()->compare(atExitFunction)) {
    atExitFunction->call(Stack);
    atExitFunction=NULL;
  }
  cleanup();
}

void updateFunction(stack *Stack)
{
  if(atExitFunction && !nullfunc::instance()->compare(atExitFunction))
    atExitFunction->call(Stack);
}

default_t def;
string emptystring;
string commentchar="#";

}

namespace types {
extern const char *names[];
}

void checkformat(const char *ptr, bool intformat) 
{
  while(*ptr != '\0') {
    if(*ptr != '%') /* While we have regular characters, print them.  */
      ptr++;
    else { /* We've got a format specifier. */
      ptr++;
      
      while(strchr ("-+ #0", *ptr)) /* Move past flags.  */
	*ptr++;

      if(*ptr == '*')
	ptr++;
      else while(isdigit(*ptr)) /* Handle explicit numeric value.  */
	ptr++;
	  
      if(*ptr == '.') {
	*ptr++; /* Go past the period.  */
	if(*ptr == '*') {
	  ptr++;
	} else
	  while(isdigit(*ptr)) /* Handle explicit numeric value.  */
	    *ptr++;
      }
      while(strchr ("hlL", *ptr))
	*ptr++;
	  
      if(*ptr == '%') ++ptr;
      else if(intformat) {
	switch(*ptr) {
	case 'd':
	case 'i':
	case 'o':
	case 'u':
	case 'x':
	case 'X':
	case 'c':
	  break;
	default:
	  ostringstream buf;
	  buf << "Invalid format for type " << types::names[types::ty_int];
	  error(buf.str().c_str());
	  break;
	}
      } else {
	  switch(*ptr) {
	    case 'f':
	    case 'e':
	    case 'E':
	    case 'g':
	    case 'G':
	    break;
	  default:
	    ostringstream buf;
	    buf << "Invalid format for type " << types::names[types::ty_real];
	    error(buf.str().c_str());
	    break;
	  }
      }
    } /* End of else statement */
  }
}
  
// Auto-generated routines:



// Initializers

int :intZero()
{
  return 0;
}

double :realZero()
{
  return 0.0;
}

bool :boolFalse()
{
  return false;
}

array* :pushNullArray()
{
  return 0;
}

frame* :pushNullRecord()
{
  return 0;
}

item :pushNullFunction()
{
  return nullfunc::instance();
}


// Default operations

// Put the default value token on the stack (in place of an argument when
// making a function call).
item :pushDefault()
{
  return def;
}


// Test if the value on the stack is the default value token.
bool :isDefault(item i)
{
  return isdefault(i);
}


// Logical operations

bool !(bool b)
{
  return !b;
}

bool :boolMemEq(frame *a, frame *b)
{
  return a == b;
}

bool :boolMemNeq(frame *a, frame *b)
{
  return a != b;
}

bool :boolFuncEq(callable *a, callable *b)
{
  return a->compare(b);
}

bool :boolFuncNeq(callable *a, callable *b)
{
  return !(a->compare(b));
}


// Casts

guide* :pairToGuide(pair z) 
{
  return new pairguide(z);
}


guide* :pathToGuide(path p) 
{
  return new pathguide(p);
}


path :guideToPath(guide *g) 
{
  return g->solve();
}


// Picture operations

picture* :newPicture()
{
  return new picture();
}

bool empty(picture *f)
{
  return f->null();
}

pair max(picture *f)
{
  return f->bounds().Max();
}

pair min(picture *f)
{
  return f->bounds().Min();
}

void label(picture *f, string *s, string *size, double angle, pair position,
	   pair align, pair scale, pen p)
{
  f->append(new drawLabel(*s,*size,angle,position,align,scale,p));
}

bool labels(picture *f)
{
  return f->havelabels();
}

void fill(picture *f, patharray *g, pen p)
{
  f->append(new drawFill(copyArray(g),p));
}

void latticeshade(picture *f, patharray *g, pen fillrule, penarray2 *p)
{
  f->append(new drawLatticeShade(copyArray(g),fillrule,copyArray(p)));
}

void axialshade(picture *f, patharray *g, pen pena, pair a, pen penb, pair b)
{
  f->append(new drawAxialShade(copyArray(g),pena,a,penb,b));
}

void radialshade(picture *f, patharray *g, pen pena, pair a, double ra,
		 pen penb, pair b, double rb)
{
  f->append(new drawRadialShade(copyArray(g),pena,a,ra,penb,b,rb));
}

void gouraudshade(picture *f, patharray *g, pen fillrule, penarray *p,
		  pairarray *z, intarray *edges)
{
  checkArrays(p,z);
  checkArrays(z,edges);
  f->append(new drawGouraudShade(copyArray(g),fillrule,copyArray(p),
				 copyArray(z),copyArray(edges)));
}

// Clip a picture to a superpath using the given fill rule.
// Subsequent additions to the picture will not be affected by the clipping.
void clip(picture *f, patharray *g, pen p)
{
  f->enclose(new drawClipBegin(copyArray(g),p),new drawClipEnd());
}

void beginclip(picture *f, patharray *g, pen p)
{
  f->append(new drawClipBegin(copyArray(g),p,false));
}

void postscript(picture *f, string s)
{
  f->append(new drawVerbatim(PostScript,s));
}

void tex(picture *f, string s)
{
  f->append(new drawVerbatim(TeX,s));
}

void texpreamble(string s)
{
  string t=s+"\n";
  camp::TeXpipepreamble.push_back(t);
  camp::TeXpreamble.push_back(t);
}

void layer(picture *f)
{
  f->append(new drawLayer());
}

void image(picture *f, realarray2 *data, penarray *palette, 
	   pair initial, pair final)
{
  f->append(new drawImage(copyArray2(data),copyArray(palette),
			  matrix(initial,final)));
}

void shipout(string prefix=emptystring, picture *f, picture *preamble=NULL,
	     string format=emptystring, bool wait=0, bool quiet=0,
	     transformarray *GUItransform, boolarray *GUIdelete)
{
  if(prefix.empty()) prefix=getSetting<string>("outname");
  
  size_t size=GUItransform && GUIdelete ?
    checkArrays(GUItransform,GUIdelete) : 0;
 
  if(getSetting<double>("deconstruct") || size) {
    picture *result=new picture;
    unsigned level=0;
    unsigned i=0;
    nodelist::iterator p;
    for(p = f->nodes.begin(); p != f->nodes.end(); ++p) {
      bool Delete;
      transform t;
      if(i < size) {
	t=*(read<transform*>(GUItransform,i));
	Delete=read<bool>(GUIdelete,i);
      } else {
	t=identity();
	Delete=false;
      }
      picture *group=new picture;
// Ignore unclosed begingroups but not spurious endgroups.
      const char *nobegin="endgroup without matching begingroup";
      assert(*p);
      if((*p)->endgroup()) error(nobegin);
      if((*p)->begingroup()) {
	++level;
	while(p != f->nodes.end() && level) {
	  drawElement *e=t.isIdentity() ? *p : (*p)->transformed(t);
	  group->append(e);
	  ++p;
	  if(p == f->nodes.end()) break;
	  assert(*p);
	  if((*p)->begingroup()) ++level;
	  if((*p)->endgroup()) if(level) --level;
	  else error(nobegin);
	}
      }
      if(p == f->nodes.end()) break;
      assert(*p);
      drawElement *e=t.isIdentity() ? *p : (*p)->transformed(t);
      group->append(e);
      if(!group->empty()) {
	if(getSetting<double>("deconstruct")) {
	  ostringstream buf;
	  buf << prefix << "_" << i;
	  group->shipout(preamble,buf.str(),"tgif",false,true,Delete);
	}
	++i;
      }
      if(size && !Delete) result->add(*group);
    }
    if(size) f=result;
  }

  f->shipout(preamble,prefix,format,wait,quiet);
}


// Pen operations

pen :newPen()
{
  return pen();
}

bool ==(pen a, pen b)
{
  return a == b;
}

bool !=(pen a, pen b)
{
  return a != b;
}

pen +(pen a, pen b)
{
  return a+b;
}

pen Operator *(double a, pen b)
{
  return a*b;
}

pen Operator *(pen a, double b)
{
  return b*a;
}

pair max(pen p)
{
  return p.bounds().Max();
}

pair min(pen p)
{
  return p.bounds().Min();
}

// Reset the meaning of pen default attributes.
void resetdefaultpen()
{
  defaultpen=camp::pen::startupdefaultpen();
}

void defaultpen(pen p)
{
  defaultpen=pen(resolvepen,p);
}

pen defaultpen()
{
  return defaultpen;
}

pen invisible()
{
  return pen(invisiblepen);
}

pen gray(pen p)
{
  if(p.rgb()) p.rgbtogrey();
  else if (p.cmyk()) p.cmyktogrey();
  return p;
}

pen rgb(pen p)
{
  if(p.grayscale()) p.greytorgb();
  else if (p.cmyk()) p.cmyktorgb();
  return p;
}

pen rgb(double r, double g, double b)
{
  return pen(r,g,b);
}

pen cmyk(double c, double m, double y, double k)
{
  return pen(c,m,y,k);  
}

pen gray(double gray)
{
  return pen(gray);
}

realarray *colors(pen p)
{  
  int n=ColorComponents[p.colorspace()];
  array *a=new array(n);
  
  switch(n) {
  case 0:
    break;
  case 1: 
    (*a)[0]=p.gray(); 
    break;
  case 3:
    (*a)[0]=p.red(); 
    (*a)[1]=p.green(); 
    (*a)[2]=p.blue(); 
    break;
  case 4:
    (*a)[0]=p.cyan();
    (*a)[1]=p.magenta(); 
    (*a)[2]=p.yellow(); 
    (*a)[3]=p.black();
    break;
  default:
    break;
  }
  return a;
}

pen pattern(string *s)
{
  return pen(setpattern,*s);
}

string pattern(pen p)
{
  return p.fillpattern();  
}

pen fillrule(int n)
{
  return pen(n >= 0 && n < nFill ? (FillRule) n : DEFFILL);
}

int fillrule(pen p)
{
  return p.Fillrule();  
}

pen linetype(string *s, bool scale)
{
  return pen(LineType(*s,scale)); 
}

string linetype(pen p)
{
  return p.stroke();  
}

pen linecap(int n)
{
  return pen(setlinecap,n >= 0 && n < nCap ? n : DEFCAP);
}

int linecap(pen p)
{
  return p.cap();  
}

pen linejoin(int n)
{
  return pen(setlinejoin,n >= 0 && n < nJoin ? n : DEFJOIN);
}

int linejoin(pen p)
{
  return p.join();  
}

pen linewidth(double x)
{
  return pen(setlinewidth,x >= 0.0 ? x : DEFWIDTH);
}

double linewidth(pen p)
{
  return p.width();  
}

pen fontcommand(string *s)
{
  return pen(setfont,*s);
}

string font(pen p)
{
  return p.Font();
}

pen fontsize(double size, double skip)
{
  return pen(setfontsize,size > 0.0 ? size : 0.0,
	     skip > 0.0 ? skip : 0.0);
}

double fontsize(pen p)
{
  return p.size();
}

double lineskip(pen p)
{
  return p.Lineskip();  
}

pen overwrite(int n)
{
  return pen(setoverwrite,n >= 0 && n < nOverwrite ? (overwrite_t) n :
	     DEFWRITE);
}

int overwrite(pen p)
{
  return p.Overwrite();  
}

pen basealign(int n)
{
  return pen(n >= 0 && n < nBaseLine ? (BaseLine) n : DEFBASE);
}

int basealign(pen p)
{
  return p.Baseline();
}

path nib(pen p)
{
  static path nullpath;
  path *g=p.Path();
  return g ? *g : nullpath;
}

pen makepen(path p)
{
  return p.size() == 0 ? pen() : pen(new path(p));
}

void _draw(picture *f, path g, pen p)
{
  f->append(new drawPath(g,p));
}

void endclip(picture *f)
{
  f->append(new drawClipEnd(false));
}

void gsave(picture *f)
{
  f->append(new drawGsave());
}

void grestore(picture *f)
{
  f->append(new drawGrestore());
}

void begingroup(picture *f)
{
  f->append(new drawBegin());
}

void endgroup(picture *f)
{
  f->append(new drawEnd());
}

void add(picture *dest, picture *src)
{
  dest->add(*src);
}

void prepend(picture *dest, picture *src)
{
  dest->prepend(*src);
}

string fileprefix()
{
  return getSetting<string>("outname");
}


// Interactive mode

bool interact()
{
  return interact::interactive;
}

void uptodate(bool b)
{
  interact::uptodate=b;
}

bool uptodate()
{
  return interact::uptodate;
}


// System commands

int system(string *str)
{
  if(safe) error("system() call disabled; override with option -unsafe");
  else return System(str->c_str());
}

void abort(string *msg)
{
  error(msg->c_str());
}

void _eval(string *s, bool embedded)
{
  loop::doITree(parser::parseString(*s),embedded);
}

void _eval(runnable *s, bool embedded)
{
  loop::doIRunnable(s,embedded);
}

void gui(double x=1)
{ 
  Setting("deconstruct")=(x > 0.0 ? x : 0.0);
}

bool deconstruct()
{ 
  return getSetting<double>("deconstruct");
}

void readGUI()
{
  static bool first=true;
  string name=buildname(getSetting<string>("outname"),"gui");
  std::ifstream exists(name.c_str());
  if(exists) {
    if((getSetting<bool>("clearGUI") && !interact::interactive) ||
       (first && interact::interactive)) unlink(name.c_str());
    else {
      if (!getSetting<bool>("ignoreGUI")) {
	string cmd=string("include \"")+name+string("\";");
	absyntax::block *ast = parser::parseString(cmd);
	loop::doITree(ast,true);
      }
    }
  }
  first=false;
}

// Wrapper for the stack::load() method.
void :loadModule(string *index)
{
  Stack->load(*index);
}

string cd(string *d)
{
  int rc=setPath(d->c_str());
  if(rc != 0) {
    ostringstream buf;
    buf << "Cannot change to directory '" << *d << "'";
    error(buf.str().c_str());
  }
  char *p=getPath();
  if(p && interact::interactive) 
    cout << p << endl;
  return p;
}

void scroll(int n)
{
  settings::scrollLines=n;
}


// Path operations

path :nullPath()
{
  static path nullpath;
  return nullpath;
}

pair point(path p, int n)
{
  return p.point(n);
}

pair point(path p, double t)
{
  return p.point(t);
}

pair precontrol(path p, int n)
{
  return p.precontrol(n);
}

pair precontrol(path p, double t)
{
  return p.precontrol(t);
}

pair postcontrol(path p, int n)
{
  return p.postcontrol(n);
}

pair postcontrol(path p, double t)
{
  return p.postcontrol(t);
}

pair dir(path p, int n)
{
  return unit(p.direction(n));
}

pair dir(path p, double t)
{
  return unit(p.direction(t));
}

path reverse(path p)
{
  return p.reverse();
}

path subpath(path p, int b, int e)
{
  return p.subpath(b,e);
}

path subpath(path p, double b, double e)
{
  return p.subpath(b,e);
}

int length(path p)
{
  return p.length();
}

bool cyclic(path p)
{
  return p.cyclic();
}

bool straight(path p, int i)
{
  return p.straight(i);
}

double arclength(path p)
{
  return p.arclength();
}

double arctime(path p, double dval)
{
  return p.arctime(dval);
}

double dirtime(path p, pair z)
{
  return p.directiontime(z);
}

pair intersect(path x, path y, double fuzz=0)
{
  return intersectiontime(x,y,fuzz);
}

int size(path p)
{
  return p.size();
}

path &(path p, path q)
{
  return camp::concat(p,q);
}

pair min(path p)
{
  return p.bounds().Min();
}

pair max(path p)
{
  return p.bounds().Max();
}

double relativedistance(double theta, double phi, double t, bool atleast)
{
  return camp::velocity(theta,phi,tension(t,atleast));
}

bool inside(patharray *g, pair z, pen p)
{
  array *G=copyArray(g);
  size_t size=G->size();
  int count=0;
  for(size_t i=0; i < size; i++) 
    count += read<path *>(G,i)->inside(z);
  return p.inside(count);
}


// Guide operations

guide* :nullGuide()
{
  return new pathguide(path());
}

guide* :dotsGuide(guidearray *a)
{
  guidevector v;
  size_t size=checkArray(a);
  for (size_t i=0; i < size; ++i)
    v.push_back(a->read<guide*>(i));

  return new multiguide(v);
}

guide* :dashesGuide(guidearray *a)
{
  static camp::curlSpec curly;
  static specguide curlout(&curly, camp::OUT);
  static specguide curlin(&curly, camp::IN);

  size_t n=checkArray(a);

  // a--b is equivalent to a{curl 1}..{curl 1}b
  guidevector v;
  if (n > 0)
    v.push_back(a->read<guide*>(0));

  if (n==1) {
    v.push_back(&curlout);
    v.push_back(&curlin);
  }
  else
    for (size_t i=1; i<n; ++i) {
      v.push_back(&curlout);
      v.push_back(&curlin);
      v.push_back(a->read<guide*>(i));
    }

  return new multiguide(v);
}

guide* operator cycle()
{
  return new cycletokguide();
}

guide* operator spec(pair z, int p)
{
  camp::side d=(camp::side) p;
  camp::dirSpec *sp=new camp::dirSpec(angle(z));

  return new specguide(sp,d);
}

guide* operator curl(double gamma, int p)
{
  camp::side d=(camp::side) p;
  camp::curlSpec *sp=new camp::curlSpec(gamma);

  return new specguide(sp,d);
}

guide* operator tension(double tout, double tin, bool atleast)
{
  tension Tin(tin, atleast),
         Tout(tout, atleast);

  return new tensionguide(tout, tin);
}

guide* operator controls(pair zout, pair zin)
{
  return new controlguide(zout, zin);
}


// String operations

string :emptyString()
{
  return emptystring;
}

int length(string *s)
{
  return (int) s->length();
}

int find(string *s, string t, int pos=0)
{
  return (int) s->find(t,pos);
}

int rfind(string *s, string t, int pos=-1)
{
  return (int) s->rfind(t,pos);
}

string reverse(string s)
{
  reverse(s.begin(),s.end());
  return s;
}

string insert(string s, int pos, string t)
{
  if ((size_t)pos < s.length())
    return s.insert(pos,t);
  return s;
}

string substr(string* s, int pos, int n=-1)
{
  if ((size_t)pos < s->length())
    return s->substr(pos,n);
  return emptystring;
}

string erase(string s, int pos, int n)
{
  if ((size_t)pos < s.length())
    return s.erase(pos,n);
  return s; 
}

// returns a string constructed by translating all occurrences of the string
// from in an array of string pairs {from,to} to the string to in string s.
string replace(string *S, stringarray2 *translate)
{
  size_t size=checkArray(translate);
  for(size_t i=0; i < size; i++) {
    array *a=read<array*>(translate,i);
    checkArray(a);
  }
  const char *p=S->c_str();
  ostringstream buf;
  while(*p) {
    for(size_t i=0; i < size;) {
      array *a=read<array*>(translate,i);
      string* from=read<string*>(a,0);
      size_t len=from->length();
      if(strncmp(p,from->c_str(),len) != 0) {i++; continue;}
      buf << read<string>(a,1);
      p += len;
      if(*p == 0) return buf.str();
      i=0;
    }
    buf << *(p++);
  }
  return buf.str();
}

string format(string *format, int x)
{
  const char *f=format->c_str();
  
  checkformat(f,true);
  
  int size=snprintf(NULL,0,f,x)+1;
  if(size < 1) size=255; // Workaround for non-C99 compliant systems.
  char *buf=new char[size];
  snprintf(buf,size,f,x);
  string s=string(buf);
  delete [] buf;
  return s;
}

string format(string *format, double x) 
{
  ostringstream out;
  
  checkformat(format->c_str(),false);
  
  const char *phantom="\\phantom{+}";
  const char *p0=format->c_str();
  
  const char *p=p0;
  const char *start=NULL;
  while (*p != 0) {
    if(*p == '%') {
      p++;
      if(*p != '%') {start=p-1; break;}
    }
    out << *(p++);
  }
  
  if(!start) return out.str();
  
  // Allow at most 1 argument  
  while (*p != 0) {
    if(*p == '*' || *p == '$') return out.str();
    if(isupper(*p) || islower(*p)) {p++; break;}
    p++;
  }
  
  const char *tail=p;
  string f=format->substr(start-p0,tail-start);
  int size=snprintf(NULL,0,f.c_str(),x)+1;
  if(size < 1) size=255; // Workaround for non-C99 compliant systems.
  char *buf=new char[size];
  snprintf(buf,size,f.c_str(),x);

  bool trailingzero=f.find("#") < string::npos;
  bool plus=f.find("+") < string::npos;
  bool space=f.find(" ") < string::npos;
  
  char *q=buf; // beginning of formatted number

  if(*q == ' ') {
    out << phantom;
    q++;
  }
  
  // Remove any spurious sign
  if(*q == '-' || *q == '+') {
    p=q+1;
    bool zero=true;
    while(*p != 0) {
      if(!isdigit(*p) && *p != '.') break;
      if(isdigit(*p) && *p != '0') {zero=false; break;}
      p++;
    }
    if(zero) {
      q++;
      if(plus || space) out << phantom;
    }
  }
  
  const char *r=p=q;
  bool dp=false;
  while(*r != 0 && (isdigit(*r) || *r == '.' || *r == '+' || *r == '-')) {
    if(*r == '.') dp=true;
    r++;
  }
  if(dp) { // Remove trailing zeros and/or decimal point
    r--;
    unsigned int n=0;
    while(r > q && *r == '0') {r--; n++;}
    if(*r == '.') {r--; n++;}
    while(q <= r) out << *(q++);
    if(!trailingzero) q += n;
  }
  
  bool zero=(r == p && *r == '0') && !trailingzero;
  
  // Translate "E+/E-/e+/e-" exponential notation to TeX
  while(*q != 0) {
    if((*q == 'E' || *q == 'e') && (*(q+1) == '+' || *(q+1) == '-')) {
      if(!zero) out << "\\!\\times\\!10^{";
      bool plus=(*(q+1) == '+');
      q++;
      if(plus) q++;
      if(*q == '-') out << *(q++);
      while(*q == '0' && (zero || isdigit(*(q+1)))) q++;
      while(isdigit(*q)) out << *(q++);
      if(!zero) {
	if(plus) out << phantom;
	out << "}";
      }
      break;
    }
    out << *(q++);
  }
  
  while(*tail != 0) 
    out << *(tail++);
  
  delete [] buf;
  return out.str();
}

string time(string *format)
{
#ifdef HAVE_STRFTIME
  static const size_t n=256;
  static char Time[n];
  const time_t bintime=time(NULL);
  strftime(Time,n,format->c_str(),localtime(&bintime));
  return Time;
#else  
  return *format;
#endif  
}


// Math

double ^(double x, int y)
{
  return pow(x,y);
}

int quotient(int x, int y)
{ 
  if (y == 0) dividebyzero();
// Implementation-independent definition of integer division: round down
  return (x-portableMod(x,y))/y;
}  

int abs(int x)
{ 
  return abs(x);
}  

int sgn(double x)
{ 
  return sgn(x);
}  

int rand()
{ 
  return rand();
}  

void srand(int seed)
{ 
  srand(seed);
}  

int ceil(double x)
{ 
  double y=ceil(x);
  checkint(y,0);
  return (int) y;
}

int floor(double x)
{ 
  double y=floor(x);
  checkint(y,0);
  return (int) y;
}

int round(double x)
{ 
  if(fabs(x) >= INT_MAX+0.5) integeroverflow(0);
  return Round(x);
}

int Ceil(double x)
{ 
  return Ceil(x);
}

int Floor(double x)
{ 
  return Floor(x);
}

int Round(double x)
{ 
  return Round(intcap(x));
}

double fmod(double x, double y)
{
  if (y == 0.0) dividebyzero();
  return fmod(x,y);
}

double atan2(double y, double x)
{ 
  return atan2(y,x);
}  

double hypot(double x, double y)
{ 
  return hypot(x,y);
}  

double remainder(double x, double y)
{ 
  return remainder(x,y);
}  

double J(int n, double x)
{
  return jn(n,x);
}

double Y(int n, double x)
{
  return yn(n,x);
}

double erf(double x)
{
  return erf(x);
}

double erfc(double x)
{
  return erfc(x);
}

double gamma(double x)
{
#ifdef HAVE_TGAMMA
  return tgamma(x);
#else
 double lg = lgamma(x);
 return signgam*exp(lg);
#endif
}

realarray *quadraticroots(double a, double b, double c)
{
  quadraticroots q(a,b,c);
  array *roots=new array(q.roots);
  if(q.roots >= 1) (*roots)[0]=q.t1;
  if(q.roots == 2) (*roots)[1]=q.t2;
  return roots;
}

realarray *cubicroots(double a, double b, double c, double d)
{
  cubicroots q(a,b,c,d);
  array *roots=new array(q.roots);
  if(q.roots >= 1) (*roots)[0]=q.t1;
  if(q.roots >= 2) (*roots)[1]=q.t2;
  if(q.roots == 3) (*roots)[2]=q.t3;
  return roots;
}

  
// Transforms

bool ==(transform a, transform b)
{
  return a == b;
}

bool !=(transform a, transform b)
{
  return a != b;
}

transform Operator *(transform a, transform b)
{
  return a*b;
}

pair Operator *(transform t, pair z)
{
  return t*z;
}

path Operator *(transform t, path g)
{
  return transformed(t,g);
}

pen Operator *(transform t, pen p)
{
  return transformed(t,p);
}

picture * Operator *(transform t, picture *f)
{
  return transformed(t,f);
}

transform ^(transform t, int n)
{
  transform T;
  if(n < 0) {
    n=-n;
    t=inverse(t);
  }
  for(int i=0; i < n; i++) T=T*t;
  return T;
}

double :transformXPart(transform t)
{
  return t.getx();
}

double :transformYPart(transform t)
{
  return t.gety();
}

double :transformXXPart(transform t)
{
  return t.getxx();
}

double :transformXYPart(transform t)
{
  return t.getxy();
}

double :transformYXPart(transform t)
{
  return t.getyx();
}

double :transformYYPart(transform t)
{
  return t.getyy();
}

transform :real6ToTransform(double x, double y, double xx, double xy,
			    double yx, double yy)
{
  return transform(x,y,xx,xy,yx,yy);
}

transform identity:transformIdentity()
{
  return identity();
}

transform inverse(transform t)
{
  return inverse(t);
}

transform shift(pair z)
{
  return shift(z);
}

transform xscale(double x)
{
  return xscale(x);
}

transform yscale(double y)
{
  return yscale(y);
}

transform scale(double x)
{
  return scale(x);
}

transform slant(double s)
{
  return slant(s);
}

transform rotate(double angle, pair z=0)
{
  return rotatearound(z,radians(angle));
}

transform reflect(pair a, pair b)
{
  return reflectabout(a,b);
}


// Pair operations

pair :pairZero()
{
  static pair zero;
  return zero;
}

pair :realRealToPair(double x, double y)
{
  return pair(x,y);
}

pair :pairNegate(pair z)
{
  return -z;
}

double :pairXPart(pair z)
{
  return z.getx();
}

double :pairYPart(pair z)
{
  return z.gety();
}

double length(pair z)
{
  return z.length();
}

double abs(pair z)
{
  return z.length();
}

double angle(pair z)
{
  return z.angle();
}

// Return the angle of z in degrees in the interval [0,360).
double degrees(pair z)
{
  double deg=degrees(z.angle());
  if(deg < 0) deg += 360; 
  return deg;
}

pair unit(pair z)
{
  return unit(z);
}

pair dir(double theta)
{
  return expi(radians(theta));
}

pair expi(double theta)
{
  return expi(theta);
}

pair conj(pair z)
{
  return conj(z);
}

// To avoid confusion, a dot product requires explicit pair arguments.
double dot(explicit pair u, explicit pair v) 
{
  return u.getx()*v.getx()+u.gety()*v.gety();
}


// Triple operations

triple :tripleZero()
{
  static triple zero;
  return zero;
}

triple :realRealRealToTriple(double x, double y, double z)
{
  return triple(x,y,z);
}

double :tripleXPart(triple v)
{
  return v.getx();
}

double :tripleYPart(triple v)
{
  return v.gety();
}

double :tripleZPart(triple v)
{
  return v.getz();
}

triple Operator *(double x, triple v)
{
  return x*v;
}

triple Operator *(triple v, double x)
{
  return x*v;
}

triple /(triple v, double x)
{
  return v/x;
}

double length(triple v)
{
  return v.length();
}

double abs(triple v)
{
  return v.length();
}

double polar(triple v) 
{
  return v.polar();
}

double azimuth(triple v) 
{
  return v.azimuth();
}

double colatitude(triple v) 
{
  return degrees(v.polar());
}

double latitude(triple v) 
{
  return 90.0-degrees(v.polar());
}

double longitude(triple v) 
{
  double deg=degrees(v.azimuth());
  if(deg < 0) deg += 360; 
  return deg;
}

triple unit(triple v) 
{
  return unit(v);
}

double dot(triple u, triple v) 
{
  return u.getx()*v.getx()+u.gety()*v.gety()+u.getz()*v.getz();
}

triple cross(triple u, triple v) 
{
  return triple(u.gety()*v.getz()-u.getz()*v.gety(),
		u.getz()*v.getx()-u.getx()*v.getz(),
		u.getx()*v.gety()-v.getx()*u.gety());
}

triple expi(double theta, double phi)
{
  return expi(theta,phi);
  double sintheta=sin(theta);
  return triple(sintheta*cos(phi),sintheta*sin(phi),cos(theta));
}

triple dir(double theta, double phi)
{
  return expi(radians(theta),radians(phi));
}

double cubiclength(triple z0, triple z0p, triple z1m, triple z1, double goal)
{
  return cubiclength(z0,z0p,z1m,z1,goal);
}

pair intersect(triplearray* pre1, triplearray* point1, triplearray* post1,
               triplearray* pre2, triplearray* point2, triplearray* post2,
	       double fuzz)
{
  size_t size1=checkArrays(pre1,point1);
  size_t size2=checkArrays(pre2,point2);
      
  if(checkArray(post1) != size1 || checkArray(post2) != size2)
    vm::error(arraymismatch);
  
  int single1=(size1 == 1);
  int single2=(size2 == 1);
  
  size_t Size1=size1+single1;
  size_t Size2=size2+single2;
  
  node *n1=new node[Size1];
  node *n2=new node[Size2];
      
  for(size_t i=0; i < size1; ++i)
    n1[i]=node(read<triple>(pre1,i),read<triple>(point1,i),
	       read<triple>(post1,i));

  for(size_t i=0; i < size2; ++i)
    n2[i]=node(read<triple>(pre2,i),read<triple>(point2,i),
	       read<triple>(post2,i));

  if(single1) n1[1]=n1[0];
  if(single2) n2[1]=n2[0];
  
  return intersect((int) Size1-1,(int) Size2-1,n1,n2,fuzz);
}


// System routines

string VERSION()
{
  return VERSION;
}

void quiet(bool v)
{
  Setting("interactiveView")=
    Setting("batchView")=
    Setting("oneFileView")=!v;
}

void atexit(callable *f)
{
  atExitFunction=f;
}

callable *atexit()
{
  return atExitFunction;
}


// Merge output files  
int merge(stringarray *files, string *args, string *format, bool keep)
{
  int ret;
  
  size_t size=checkArray(files);
  
  if(!checkFormatString(*format)) return;
  
  ostringstream cmd,remove;
  cmd << getSetting<string>("convert") << " "+*args;
  
  for(size_t i=0; i < size; i++) 
    cmd << " " << read<string>(files,i);
  
  string name=buildname(getSetting<string>("outname"),format->c_str());
  cmd << " " << name;
  ret=System(cmd,false,true,"convert");
  
  if(ret == 0)
    if(verbose > 0) cout << "Wrote " << name << endl;
  
  if(!keep && !getSetting<bool>("keep"))
    for(size_t i=0; i < size; i++) 
      unlink(read<string>(files,i).c_str());
    
  if(ret == 0 && settings::view()) {
    ostringstream cmd;
    cmd << getSetting<string>("animate") << " " << name;
    System(cmd,false,false,"animate","your animated GIF viewer");
  }
  
  return ret;
}


// Array operations

// Create an empty array.
array* :emptyArray()
{
  return new array(0);
}

// Create a new array (technically a vector).
// This array will be multidimensional.  First the number of dimensions
// is popped off the stack, followed by each dimension in reverse order.
// The array itself is technically a one dimensional array of one
// dimension arrays and so on.
array* :newDeepArray(int depth)
{
  assert(depth > 0);

  int *dims = new int[depth];

  for (int index = depth-1; index >= 0; index--)
    dims[index] = pop<int>(Stack);

  array *a=deepArray(depth, dims);
  delete [] dims;
  return a;
}

// Creates an array with elements already specified.  First, the number
// of elements is popped off the stack, followed by each element in
// reverse order.
array* :newInitializedArray(int n)
{
  assert(n >= 0);

  array *a = new array(n);

  for (int index = n-1; index >= 0; index--)
    (*a)[index] = pop(Stack);

  return a;
}

// Similar to newInitializedArray, but after the n elements, append another
// array to it.
array* :newAppendedArray(array* tail, int n)
{
  assert(n >= 0);

  array *a = new array(n);

  for (int index = n-1; index >= 0; index--)
    (*a)[index] = pop(Stack);
  
  copy(tail->begin(), tail->end(), back_inserter(*a));

  return a;
}

// Read an element from an array. Checks for initialization & bounds.
item :arrayRead(array *a, int n)
{
  item& i=arrayRead(a,n);
  if (i.empty()) {
    ostringstream buf;
    buf << "read uninitialized value from array at index " << n;
    error(buf.str().c_str());
  }
  return i;
}

// Read an element from an array of arrays. Check bounds and initialize
// as necessary.
item :arrayArrayRead(array *a, int n)
{
  item& i=arrayRead(a,n);
  if (i.empty()) i=new array(0);
  return i;
}

// Write an element to an array.  Increase size if necessary.
item :arrayWrite(item value, array *a, int n)
{
  size_t len=checkArray(a);
  bool cyclic=a->cyclic();
  if(cyclic && len > 0) n=imod(n,len);
  else {
    if(cyclic) outOfBounds("writing cyclic",len,n);
    if(n < 0) outOfBounds("writing",len,n);
    if(len <= (size_t) n)
      a->resize(n+1);
  }
  (*a)[n] = value;
  return value;
}

// Returns the length of an array.
int :arrayLength(array *a)
{
  return (int) checkArray(a);
}

// Return the cyclic flag for an array.
bool :arrayCyclicFlag(array *a)
{
  checkArray(a);
  return a->cyclic();
}

// The helper function for the cyclic method that sets the cyclic flag.
void :arrayCyclicHelper(bool b, array *a)
{
  checkArray(a);
  a->cyclic(b);
}

// Set the cyclic flag for an array.
callable* :arrayCyclic(array *a)
{
  checkArray(a);
  return new thunk(new bfunc(arrayCyclicHelper),a);
}

// The helper function for the push method that does the actual operation.
item :arrayPushHelper(item i, array *a)
{
  checkArray(a);
  a->push(i);
  return i;
}

// Returns the push method for an array.
callable* :arrayPush(array *a)
{
  checkArray(a);
  return new thunk(new bfunc(arrayPushHelper),a);
}

// The helper function for the append method that appends b to a.
void :arrayAppendHelper(array *b, array *a)
{
  checkArray(a);
  size_t size=checkArray(b);
  for(size_t i=0; i < size; i++)
    a->push((*b)[i]);
}

// Returns the append method for an array.
callable* :arrayAppend(array *a)
{
  checkArray(a);
  return new thunk(new bfunc(arrayAppendHelper),a);
}

// The helper function for the pop method.
item :arrayPopHelper(array *a)
{
  size_t asize=checkArray(a);
  if(asize == 0) 
    error("cannot pop element from empty array");
  return a->pop();
}

// Returns the pop method for an array.
callable* :arrayPop(array *a)
{
  checkArray(a);
  return new thunk(new bfunc(arrayPopHelper),a);
}

bool :arrayAlias(array *a, array *b)
{
  return a==b;
}

// Return array formed by indexing array a with elements of integer array b
array* :arrayIntArray(array *a, array *b)
{
  size_t asize=checkArray(a);
  size_t bsize=checkArray(b);
  array *r=new array(bsize);
  bool cyclic=a->cyclic();
  for(size_t i=0; i < bsize; i++) {
    int index=read<int>(b,i);
    if(cyclic && asize > 0) index=imod(index,asize);
    else
      if(index < 0 || index >= (int) asize)
	outOfBounds("reading",asize,index);
    (*r)[i]=(*a)[index];
  }
  return r;
}

// returns the complement of the integer array a in {1,2,...,n},
// so that b[complement(a,b.length)] yields the complement of b[a].
intarray* complement(intarray *a, int n)
{
  size_t asize=checkArray(a);
  array *r=new array(0);
  bool *keep=new bool(n);
  for(int i=0; i < n; ++i) keep[i]=true;
  for(size_t i=0; i < asize; ++i) {
    int j=read<int>(a,i);
    if(j >= 0 && j < n) keep[j]=false;
  }
  for(int i=0; i < n; i++)
    if(keep[i]) r->push(i);
  
  delete[] keep;
  return r;
}

// Generate the sequence {f_i : i=0,1,...n-1} given a function f and integer n
intarray* :arraySequence(callable *f, int n)
{
  if(n < 0) n=0;
  array *a=new array(n);
  for(int i=0; i < n; ++i) {
    Stack->push(i);
    f->call(Stack);
    (*a)[i]=pop(Stack);
  }
  return a;
}

// Return the array {0,1,...n-1}
intarray *sequence(int n)
{
  if(n < 0) n=0;
  array *a=new array(n);
  for(int i=0; i < n; ++i) {
    (*a)[i]=i;
  }
  return a;
}

// Apply a function to each element of an array
array* :arrayFunction(callable *f, array *a)
{
  size_t size=checkArray(a);
  array *b=new array(size);
  for(size_t i=0; i < size; ++i) {
    Stack->push((*a)[i]);
    f->call(Stack);
    (*b)[i]=pop(Stack);
  }
  return b;
}

bool all(boolarray *a)
{
  size_t size=checkArray(a);
  bool c=true;
  for(size_t i=0; i < size; i++)
    if(!get<bool>((*a)[i])) {c=false; break;}
  return c;
}

boolarray* !(boolarray* a)
{
  size_t size=checkArray(a);
  array *c=new array(size);
  for(size_t i=0; i < size; i++)
    (*c)[i]=!read<bool>(a,i);
  return c;
}

int sum(boolarray *a)
{
  size_t size=checkArray(a);
  int sum=0;
  for(size_t i=0; i < size; i++)
    sum += read<bool>(a,i) ? 1 : 0;
  return sum;
}

array* :arrayCopy(array *a)
{
  return copyArray(a);
}

array* :arrayConcat(array *a, array *b)
{
  size_t asize=checkArray(a);
  size_t bsize=checkArray(b);
  array *c=new array(asize+bsize);
  for(size_t i=0; i < asize; i++) 
    (*c)[i]=(*a)[i];
  for(size_t i=0; i < bsize; i++, asize++) 
    (*c)[asize]=(*b)[i];
  return c;
}

array* :array2Copy(array *a)
{
  return copyArray2(a);
}

array* :array2Transpose(array *a)
{
  size_t asize=checkArray(a);
  array *c=new array(0);
  for(size_t i=0; i < asize; i++) {
    size_t ip=i+1;
    array *ai=read<array*>(a,i);
    size_t aisize=checkArray(ai);
    size_t csize=c->size();
    if(csize < aisize) {
      c->resize(aisize);
      for(size_t j=csize; j < aisize; j++) {
	(*c)[j]=new array(ip);
      }
    }
    for(size_t j=0; j < aisize; j++) {
    array *cj=read<array*>(c,j);
    if(cj->size() < ip) cj->resize(ip);
    (*cj)[i]=(*ai)[j];
    }
  }
  return c;
}

// In a boolean array, find the index of the nth true value or -1 if not found
// If n is negative, search backwards.
int find(boolarray *a, int n=1)
{
  
  size_t size=checkArray(a);
  int j=-1;
  if(n > 0)
    for(size_t i=0; i < size; i++)
      if(read<bool>(a,i)) {
	n--; if(n == 0) {j=(int) i; break;}
      }
  if(n < 0)
    for(size_t i=size; i > 0;)
      if(read<bool>(a,--i)) {
	n++; if(n == 0) {j=(int) i; break;}
      }
  return j;
}

// construct vector obtained by replacing those elements of b for which the
// corresponding elements of a are false by the corresponding element of c.
array* :arrayConditional(array *a, array *b, array *c)
{
  size_t size=checkArray(a);
  array *r=new array(size);
  if(b && c) {
    checkArrays(a,b);
    checkArrays(b,c);
    for(size_t i=0; i < size; i++)
      (*r)[i]=read<bool>(a,i) ? (*b)[i] : (*c)[i];
  } else {
    r->clear();
    if(b) {
      checkArrays(a,b);
      for(size_t i=0; i < size; i++)
        if(read<bool>(a,i)) r->push((*b)[i]);
    } else if(c) {
      checkArrays(a,c);
      for(size_t i=0; i < size; i++)
        if(!read<bool>(a,i)) r->push((*c)[i]);
    }
  }
  return r;
}

// Solve the problem L\inv f, where f is an n vector and L is the n x n matrix
//
// [ b[0] c[0]           a[0]   ]
// [ a[1] b[1] c[1]             ]
// [      a[2] b[2] c[2]        ]
// [                ...         ]
// [       c[n-1] a[n-1] b[n-1] ]
realarray *tridiagonal(realarray *a, realarray *b, realarray *c, realarray *f)
{
  size_t n=checkArrays(a,b);
  if(n != checkArray(c) || n != checkArray(f))
    vm::error(arraymismatch);
  
  array *up=new array(n);
  array& u=*up;

  if(n == 0) return up;
  
  // Special case: Zero Dirichlet boundary conditions
  if(read<double>(a,0) == 0.0 && read<double>(c,n-1) == 0.0) {
    static double *work;
    static size_t size=0;
  
    CheckReallocate(work,n,size);
    
    double temp=1.0/read<double>(b,0);
    u[0]=read<double>(f,0)*temp;
    work[0]=-read<double>(c,0)*temp;
	
    for(size_t i=1; i < n; i++) {
      double temp=1.0/(read<double>(b,i)+read<double>(a,i)*work[i-1]);
      u[i]=(read<double>(f,i)-read<double>(a,i)*read<double>(u,i-1))*temp;
      work[i]=-read<double>(c,i)*temp;
    }

    for(size_t i=n-1; i >= 1; i--)
      u[i-1]=read<double>(u,i-1)+work[i-1]*read<double>(u,i);
    return up;
  }
  
  double binv=read<double>(b,0);
  if(binv == 0.0) dividebyzero();
  binv=1.0/binv;
  
  if(n == 1) {u[0]=read<double>(f,0)*binv; return up;}
  if(n == 2) {
    double factor=(read<double>(b,0)*read<double>(b,1)-
		   read<double>(a,0)*read<double>(c,1));
    if(factor== 0.0) dividebyzero();
    factor=1.0/factor;
    double temp=(read<double>(b,0)*read<double>(f,1)-
	  read<double>(c,1)*read<double>(f,0))*factor;
    u[0]=(read<double>(b,1)*read<double>(f,0)-
	  read<double>(a,0)*read<double>(f,1))*factor;
    u[1]=temp;
    return up;
  }
	
  static double *gamma,*delta;
  static size_t size=0;
  CheckReallocate(gamma,delta,n-2,size);
  
  gamma[0]=read<double>(c,0)*binv;
  delta[0]=read<double>(a,0)*binv;
  u[0]=read<double>(f,0)*binv;
  double beta=read<double>(c,n-1);
  double fn=read<double>(f,n-1)-beta*read<double>(u,0);
  double alpha=read<double>(b,n-1)-beta*delta[0];

  for(size_t i=1; i <= n-3; i++) {
    double alphainv=read<double>(b,i)-read<double>(a,i)*gamma[i-1];
    if(alphainv == 0.0) dividebyzero();
    alphainv=1.0/alphainv;
    beta *= -gamma[i-1];
    gamma[i]=read<double>(c,i)*alphainv;
    u[i]=(read<double>(f,i)-read<double>(a,i)*read<double>(u,i-1))*alphainv;
    fn -= beta*read<double>(u,i);
    delta[i]=-read<double>(a,i)*delta[i-1]*alphainv;
    alpha -= beta*delta[i];
  }
	
  double alphainv=read<double>(b,n-2)-read<double>(a,n-2)*gamma[n-3];
  if(alphainv == 0.0) dividebyzero();
  alphainv=1.0/alphainv;
  u[n-2]=(read<double>(f,n-2)-read<double>(a,n-2)*read<double>(u,n-3))
    *alphainv;
  beta=read<double>(a,n-1)-beta*gamma[n-3];
  double dnm1=(read<double>(c,n-2)-read<double>(a,n-2)*delta[n-3])*alphainv;
  double temp=alpha-beta*dnm1;
  if(temp == 0.0) dividebyzero();
  u[n-1]=temp=(fn-beta*read<double>(u,n-2))/temp;
  u[n-2]=read<double>(u,n-2)-dnm1*temp;
	
  for(size_t i=n-2; i >= 1; i--)
    u[i-1]=read<double>(u,i-1)-gamma[i-1]*read<double>(u,i)-delta[i-1]*temp;
  
  return up;
}

// Compute the fast Fourier transform of a pair array
pairarray* :pairArrayFFT(pairarray *a, int sign=1)
{
  unsigned n=(unsigned) checkArray(a);
  array *c=new array(n);
#ifdef HAVE_LIBFFTW3
  Complex *f=FFTWComplex(n);
  fft1d Forward(n,sign,f);
  
  for(size_t i=0; i < n; i++) {
    pair z=read<pair>(a,i);
    f[i]=Complex(z.getx(),z.gety());
  }
  Forward.fft(f);
  
  for(size_t i=0; i < n; i++) {
    Complex z=f[i];
    (*c)[i]=pair(z.real(),z.imag());
  }
  FFTWdelete(f);
#else
  assert(sign); // Avoid unused variable warning message
#endif //  HAVE_LIBFFTW3
  return c;
}


// File operations

bool ==(file *a, file *b)
{
  return a == b;
}

bool !=(file *a, file *b)
{
  return a != b;
}

file* :standardOut()
{
  return &camp::Stdout;
}

file* :nullFile()
{
  return &camp::nullfile;
}

file* input(string name, bool check=true, string comment=commentchar)
{
  char c=comment == "" ? (char) 0 : comment[0];
  file *f=new ifile(name,check,c);
  f->open();
  return f;
}

file* output(string name, bool append=false)
{
  file *f=new ofile(name,append);
  f->open();
  return f;
}

file* xinput(string name, bool check=true)
{
#ifdef HAVE_RPC_RPC_H
  file *f=new ixfile(name,check);
  return f;
#else  
  error("XDR support not enabled");
#endif
}

file* xoutput(string name, bool append=false)
{
#ifdef HAVE_RPC_RPC_H
  file *f=new oxfile(name,append);
  return f;
#else  
  error("XDR support not enabled");
#endif
}

bool eof(file *File)
{
  return File->eof();
}

bool eol(file *File)
{
  return File->eol();
}

bool error(file *File)
{
  return File->error();
}

void clear(file *File)
{
  File->clear();
}

void close(file *File)
{
  File->close();
}

void precision(file *File, int digits) 
{
  File->precision(digits);
}

void flush(file *File) 
{
   File->flush();
}

string getc(file *File)
{
  char c;
  if(File->isOpen()) File->read(c);
  static char str[1];
  str[0]=c;
  return string(str);
}

// Set file dimensions
file* dimension(file *File, int nx) 
{
  File->dimension(nx);
  return File;
}

file* dimension(file *File, int nx, int ny) 
{
  File->dimension(nx,ny);
  return File;
}

file* dimension(file *File, int nx, int ny, int nz)
{
  File->dimension(nx,ny,nz);
  return File;
}

// Set file to read comma-separated values
file* csv(file *File, bool b=true) 
{
  File->CSVMode(b);
  return File;
}

// Set file to read arrays in line-at-a-time mode
file* line(file *File, bool b=true) 
{
  File->LineMode(b);
  return File;
}

// Set file to read/write single-precision XDR values.
file* single(file *File, bool b=true) 
{
  File->SingleMode(b);
  return File;
}

// Set file to read an array1 (1 int size followed by a 1d array)
file* read1(file *File) 
{
  File->dimension(-2);
  return File;
}

// Set file to read an array2 (2 int sizes followed by a 2d array)
file* read2(file *File) 
{
  File->dimension(-2,-2);
  return File;
}

// Set file to read an array3 (3 int sizes followed by a 3d array)
file* read3(file *File) 
{
  File->dimension(-2,-2,-2);
  return File;
}

// Prompt for a string using the GNU readline library and a local history.
// On exit, save this local history under the name historyfilename(history),
// unless history begins with an underscore character.
string readline(string prompt=emptystring, string history=emptystring,
		string initial=emptystring, bool tabcompletion=false)
{
#if defined(HAVE_LIBREADLINE) && defined(HAVE_LIBCURSES)
  init_readline(tabcompletion);
  
  store_history(&history_save);
  bool newhistory=historyMap.find(history) == historyMap.end();
  HISTORY_STATE& History=historyMap[history];
  history_set_history_state(&History);
  if(history[0] != nosave && newhistory)
    read_history(historyfilename(history).c_str());
  
  static char *line_read=NULL;
  /* Return the memory to the free pool
     if the buffer has already been allocated. */
  if(line_read) {
    free(line_read);
    line_read=NULL;
  }
     
  HIST_ENTRY *last=history_get(history_length);
  const char *Default=last ? last->line : initial.c_str();
  int size=snprintf(NULL,0,prompt.c_str(),Default)+1;
  if(size < 1) size=255; // Workaround for non-C99 compliant systems.
  char *buf=new char[size];
  snprintf(buf,size,prompt.c_str(),Default);
  
  /* Get a line from the user. */
  line_read=readline(buf);
  delete [] buf;
     
  if(line_read) {
  /* If the line has any text in it, save it on the history. */
    if(*line_read) add_history(line_read);
  } else cout << endl;
  
  store_history(&History);
  history_set_history_state(&history_save);
  
  return line_read ? string(*line_read ? line_read : Default) : emptystring;
#else
  Stdout.write(prompt);
  static ifile Stdin("");
  string s;
  Stdin.read(s);
  return s;
#endif
}
