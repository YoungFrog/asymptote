/*****
 * runtime.in
 * Tom Prince 2005/4/15
 *
 * Generate runtime functions.
 *
 *****/

void     => primVoid()
int      => primInt()
bool     => primBoolean()
double   => primReal()
string*  => primString()
string   => primString() 
pen      => primPen()
pair     => primPair()
triple   => primTriple()
path     => primPath()
picture* => primPicture()
transform => primTransform()
callable* => voidFunction()
runnable* => primCode()
realarray* => realArray()
stringarray* => stringArray()

#include <cfloat>
#include "angle.h"
#include "pair.h"
#include "triple.h"
#include "transform.h"
#include "path.h"
#include "pen.h"
#include "guide.h"
#include "picture.h"
#include "drawpath.h"
#include "drawfill.h"
#include "drawclipbegin.h"
#include "drawclipend.h"
#include "drawlabel.h"
#include "drawverbatim.h"
#include "drawgsave.h"
#include "drawgrestore.h"
#include "drawlayer.h"
#include "drawimage.h"
#include "drawgroup.h"
#include "fileio.h"
#include "genv.h"
#include "builtin.h"
#include "texfile.h"
#include "pipestream.h"
#include "parser.h"
#include "stack.h"
#include "util.h"
#include "mathop.h"
#include "callable.h"
#include "stm.h"
  
using namespace vm;
using namespace camp;
using namespace settings;
namespace run {
using camp::pair;
using mem::string;
using vm::array;
using absyntax::runnable;

callable *atExitFunction=NULL;
callable *atDrawFunction=NULL;
}

using namespace types;

typedef vm::array stringarray;
typedef vm::array realarray;

static inline int Round(double x) 
{
  return int(x+((x >= 0) ? 0.5 : -0.5));
}

function *voidFunction()
{
  function *ft = new function(primVoid());
  return ft;
}

namespace loop {
  void doIRunnable(absyntax::runnable *r, bool embedded=false);
  void doITree(absyntax::block *tree, bool embedded=false);
}
  

void _label(picture *pic, string *s, string *size, double r, pair z, pair a,
     	    pair scale, pen p)
{
  pic->append(new drawLabel(*s,*size,r,z,a,scale,p));
}

bool labels(picture *pic)
{
  return pic->havelabels();
}

// Pen operations
// Reset the meaning of pen default attributes.
void resetdefaultpen()
{
  defaultpen=camp::pen::startupdefaultpen();
}

void defaultpen(pen p)
{
  defaultpen=pen(resolvepen,p);
}

pen defaultpen()
{
  return defaultpen;
}

pen invisible()
{
  return pen(invisiblepen);
}

pen gray(pen p)
{
  if(p.rgb()) p.rgbtogrey();
  else if (p.cmyk()) p.cmyktogrey();
  return p;
}

pen rgb(pen p)
{
  if(p.grayscale()) p.greytorgb();
  else if (p.cmyk()) p.cmyktorgb();
  return p;
}

pen rgb(double r, double g, double b)
{
  return pen(r,g,b);
}

pen cmyk(double c, double m, double y, double k)
{
  return pen(c,m,y,k);  
}

pen gray(double gray)
{
  return pen(gray);
}

realarray *colors(pen p)
{  
  int n=ColorComponents[p.colorspace()];
  array *a=new array(n);
  
  switch(n) {
  case 0:
    break;
  case 1: 
    (*a)[0]=p.gray(); 
    break;
  case 3:
    (*a)[0]=p.red(); 
    (*a)[1]=p.green(); 
    (*a)[2]=p.blue(); 
    break;
  case 4:
    (*a)[0]=p.cyan();
    (*a)[1]=p.magenta(); 
    (*a)[2]=p.yellow(); 
    (*a)[3]=p.black();
    break;
  default:
    break;
  }
  return a;
}

pen pattern(string *s)
{
  return pen(setpattern,*s);
}

string pattern(pen p)
{
  return p.fillpattern();  
}

pen fillrule(int n)
{
  return pen(n >= 0 && n < nFill ? (FillRule) n : DEFFILL);
}

int fillrule(pen p)
{
  return p.Fillrule();  
}

pen linetype(string *s, bool scale)
{
  return pen(LineType(*s,scale)); 
}

string linetype(pen p)
{
  return p.stroke();  
}

pen linecap(int n)
{
  return pen(setlinecap,n >= 0 && n < nCap ? n : DEFCAP);
}

int linecap(pen p)
{
  return p.cap();  
}

pen linejoin(int n)
{
  return pen(setlinejoin,n >= 0 && n < nJoin ? n : DEFJOIN);
}

int linejoin(pen p)
{
  return p.join();  
}

pen linewidth(double x)
{
  return pen(setlinewidth,x >= 0.0 ? x : DEFWIDTH);
}

double linewidth(pen p)
{
  return p.width();  
}

pen fontcommand(string *s)
{
  return pen(setfont,*s);
}

string font(pen p)
{
  return p.Font();
}

pen fontsize(double size, double skip)
{
  return pen(setfontsize,size > 0.0 ? size : 0.0,
	     skip > 0.0 ? skip : 0.0);
}

double fontsize(pen p)
{
  return p.size();
}

double lineskip(pen p)
{
  return p.Lineskip();  
}

pen overwrite(int n)
{
  return pen(setoverwrite,n >= 0 && n < nOverwrite ? (overwrite_t) n :
	     DEFWRITE);
}

int overwrite(pen p)
{
  return p.Overwrite();  
}

pen basealign(int n)
{
  return pen(n >= 0 && n < nBaseLine ? (BaseLine) n : DEFBASE);
}

int basealign(pen p)
{
  return p.Baseline();
}

path nib(pen p)
{
  static path nullpath;
  path *g=p.Path();
  return g ? *g : nullpath;
}

pen makepen(path p)
{
  return p.size() == 0 ? pen() : pen(new path(p));
}

void _draw(picture *pic, path p, pen n)
{
  pic->append(new drawPath(p,n));
}

void endclip(picture *pic)
{
  pic->append(new drawClipEnd(false));
}

void gsave(picture *pic)
{
  pic->append(new drawGsave());
}

void grestore(picture *pic)
{
  pic->append(new drawGrestore());
}

void begingroup(picture *pic)
{
  pic->append(new drawBegin());
}

void endgroup(picture *pic)
{
  pic->append(new drawEnd());
}

void add(picture *to, picture *from)
{
  to->add(*from);
}

void prepend(picture *to, picture *from)
{
  to->prepend(*from);
}

string fileprefix()
{
  return outname;
}

// Interactive mode
bool interact()
{
  return interact::interactive;
}

void uptodate(bool b)
{
  interact::uptodate=b;
}

bool uptodate()
{
  return interact::uptodate;
}

// System commands
int system(string *str)
{
  if(safe) error("system() call disabled; override with option -unsafe");
  else return System(str->c_str());
}

void abort(string *msg)
{
  error(msg->c_str());
}

void _eval(string *s, bool embedded=false)
{
  loop::doITree(parser::parseString(*s),embedded);
}

void _eval(runnable *s, bool embedded=false)
{
  loop::doIRunnable(s,embedded);
}

void readGUI()
{
  static bool first=true;
  string name=buildname(outname,"gui");
  std::ifstream exists(name.c_str());
  if(exists) {
    if((settings::clearGUI && !interact::interactive) ||
       (first && interact::interactive)) unlink(name.c_str());
    else {
      if (!settings::ignoreGUI) {
	string cmd=string("include \"")+name+string("\";");
	absyntax::block *ast = parser::parseString(cmd);
	loop::doITree(ast,true);
      }
    }
  }
  first=false;
}

// Path operations
pair point(path p, int n)
{
  return p.point(n);
}

pair point(path p, double t)
{
  return p.point(t);
}

pair precontrol(path p, int n)
{
  return p.precontrol(n);
}

pair precontrol(path p, double t)
{
  return p.precontrol(t);
}

pair postcontrol(path p, int n)
{
  return p.postcontrol(n);
}

pair postcontrol(path p, double t)
{
  return p.postcontrol(t);
}

pair dir(path p, int n)
{
  return unit(p.direction(n));
}

pair dir(path p, double t)
{
  return unit(p.direction(t));
}

path reverse(path p)
{
  return p.reverse();
}

path subpath(path p, int b, int e)
{
  return p.subpath(b,e);
}

path subpath(path p, double b, double e)
{
  return p.subpath(b,e);
}

int length(path p)
{
  return p.length();
}

bool cyclic(path p)
{
  return p.cyclic();
}

bool straight(path p, int i)
{
  return p.straight(i);
}

double arclength(path p)
{
  return p.arclength();
}

double arctime(path p, double dval)
{
  return p.arctime(dval);
}

double dirtime(path p, pair z)
{
  return p.directiontime(z);
}

pair intersect(path x, path y, double fuzz)
{
  return intersectiontime(x,y,fuzz);
}

double relativedistance(double theta, double phi, double t, bool atleast)
{
  return camp::velocity(theta,phi,tension(t,atleast));
}

// Triple operations
double cubiclength(triple z0, triple z0p, triple z1m, triple z1, double goal)
{
  return cubiclength(z0,z0p,z1m,z1,goal);
}

triple expi(double theta, double phi)
{
  return expi(theta,phi);
  double sintheta=sin(theta);
  return triple(sintheta*cos(phi),sintheta*sin(phi),cos(theta));
}

triple dir(double theta, double phi)
{
  return expi(radians(theta),radians(phi));
}

// String operations
int length(string *s)
{
  return (int) s->length();
}

int find(string *s, string *sub, int pos)
{
  return (int) s->find(*sub,pos);
}

int rfind(string *s, string *sub, int pos)
{
  return (int) s->rfind(*sub,pos);
}

string reverse(string s)
{
  reverse(s.begin(),s.end());
  return s;
}

string insert(string s, int pos, string *sub)
{
  if ((size_t)pos < s.length())
    return s.insert(pos,*sub);
  return s;
}

string substr(string* s, int pos, int n)
{
  if ((size_t)pos < s->length())
    return s->substr(pos,n);
  return ""; // TODO: Make this shared again.
}

string erase(string s, int pos, int n)
{
  if ((size_t)pos < s.length())
    return s.erase(pos,n);
  return s; 
}

void gui(double x)
{ 
  settings::deconstruct=(x > 0 ? x : 0);
}

// Math
int ceil(double x)
{ 
  double y=ceil(x);
  checkint(y,0);
  return (int) y;
}

int floor(double x)
{ 
  double y=floor(x);
  checkint(y,0);
  return (int) y;
}

int round(double x)
{ 
  if(fabs(x) >= INT_MAX+0.5) integeroverflow(0);
  return Round(x);
}

int Ceil(double x)
{ 
  return Ceil(x);
}

int Floor(double x)
{ 
  return Floor(x);
}

int Round(double x)
{ 
  return Round(intcap(x));
}

double erf(double x)
{
  return erf(x);
}

double erfc(double x)
{
  return erfc(x);
}

double gamma(double x)
{
#ifdef HAVE_TGAMMA
  return tgamma(x);
#else
 double lg = lgamma(x);
 return signgam*exp(lg);
#endif
}

string VERSION()
{
  return VERSION;
}

void quiet(bool v)
{
  settings::view=!v;
}

void atexit(callable *f)
{
  atExitFunction=f;
}

callable *atexit()
{
  return atExitFunction;
}

// Transforms
transform identity()
{
  return identity();
}

transform inverse(transform t)
{
  return inverse(t);
}

transform shift(pair z)
{
  return shift(z);
}

transform xscale(double x)
{
  return xscale(x);
}

transform yscale(double y)
{
  return yscale(y);
}

transform scale(double x)
{
  return scale(x);
}

transform slant(double s)
{
  return slant(s);
}

transform rotate(double angle, pair z=0)
{
  return rotatearound(z,radians(angle));
}

transform reflect(pair a, pair b)
{
  return reflectabout(a,b);
}

// Pair operations
double length(pair z)
{
  return z.length();
}

double abs(pair z)
{
  return z.length();
}

double angle(pair z)
{
  return z.angle();
}

// Return the angle of z in degrees in the interval [0,360).
double degrees(pair z)
{
  double deg=degrees(z.angle());
  if(deg < 0) deg += 360; 
  return deg;
}

pair unit(pair z)
{
  return unit(z);
}

pair dir(double theta)
{
  return expi(radians(theta));
}

pair expi(double theta)
{
  return expi(theta);
}

pair conj(pair z)
{
  return conj(z);
}

double _dot(pair u, pair v) 
{
  return u.getx()*v.getx()+u.gety()*v.gety();
}

// Triple operations
double length(triple v)
{
  return v.length();
}

double abs(triple v)
{
  return v.length();
}

double polar(triple v) 
{
  return v.polar();
}

double azimuth(triple v) 
{
  return v.azimuth();
}

double colatitude(triple v) 
{
  return degrees(v.polar());
}

double latitude(triple v) 
{
  return 90.0-degrees(v.polar());
}

double longitude(triple v) 
{
  double deg=degrees(v.azimuth());
  if(deg < 0) deg += 360; 
  return deg;
}

triple unit(triple v) 
{
  return unit(v);
}

double dot(triple u, triple v) 
{
  return u.getx()*v.getx()+u.gety()*v.gety()+u.getz()*v.getz();
}

triple cross(triple u, triple v) 
{
  return triple(u.gety()*v.getz()-u.getz()*v.gety(),
		u.getz()*v.getx()-u.getx()*v.getz(),
		u.getx()*v.gety()-v.getx()*u.gety());
}
// Constants

double pi()
{ 
  return PI;
}

int intMax()
{ 
  return INT_MAX;
}

double infinity()
{ 
  return HUGE_VAL;
}  

double realMax()
{ 
  return DBL_MAX;
}

double realMin()
{ 
  return DBL_MIN;
}  

double realEpsilon()
{ 
  return DBL_EPSILON;
}  

double randMax()
{ 
  return RAND_MAX;
}

// Merge output files  
int merge(stringarray *files, string *args, string *format, bool keep)
{
  int ret;
  
  checkArray(files);
  size_t size=files->size();
  
  if(!checkFormatString(*format)) return;
  
  ostringstream cmd,remove;
  cmd << Convert << " "+*args;
  
  for(size_t i=0; i < size; i++) 
    cmd << " " << read<string>(files,i);
  
  string name=buildname(outname,format->c_str());
  cmd << " " << name;
  ret=System(cmd,false,true,"ASYMPTOTE_CONVERT","convert");
  
  if(ret == 0)
    if(settings::verbose > 0) cout << "Wrote " << name << endl;
  
  if(!keep && !settings::keep)
    for(size_t i=0; i < size; i++) 
      unlink(read<string>(files,i).c_str());
    
  if(ret == 0 && settings::view) {
    ostringstream cmd;
    cmd << Animate << " " << name;
    System(cmd,false,false,"ASYMPTOTE_ANIMATE","your animated GIF viewer");
  }
  
  return ret;
}
