/*****
 * runtime.in
 * Tom Prince 2005/4/15
 *
 * Generated runtime functions.
 *
 *****/

void     => primVoid()
int      => primInt()
bool     => primBoolean()
double   => primReal()
string*  => primString()
string   => primString() 
pen*     => primPen()
pair     => primPair()
triple   => primTriple()
path     => primPath()
picture* => primPicture()

#include "angle.h"
#include "pair.h"
#include "triple.h"
#include "transform.h"
#include "path.h"
#include "pen.h"
#include "guide.h"
#include "picture.h"
#include "drawpath.h"
#include "drawfill.h"
#include "drawclipbegin.h"
#include "drawclipend.h"
#include "drawlabel.h"
#include "drawverbatim.h"
#include "drawgsave.h"
#include "drawgrestore.h"
#include "drawlayer.h"
#include "drawimage.h"
#include "drawgroup.h"
#include "fileio.h"
#include "genv.h"
#include "builtin.h"
#include "texfile.h"
#include "pipestream.h"
#include "parser.h"
#include "stack.h"
  
using namespace vm;
using namespace camp;
using namespace settings;

namespace run {
using camp::pair;
using mem::string;
}
namespace trans {
using namespace types;
}


void _label (picture *pic, string *t, double r, pair z, pair a, pen *p)
{
  drawLabel *d = new drawLabel(*t,r,z,a,p);
  pic->append(d);
}

pen *basealign(int n)
{
  return new pen(n >= 0 && n < nBaseLine 
                   ? (BaseLine) n
                   : DEFBASE);
}

void draw(picture *pic, path p, pen *n)
{
  drawPath *d = new drawPath(p,*n);
  pic->append(d);
}

void fill(picture *pic, path p,
          pen *pena, pair a, double ra,
          pen *penb, pair b, double rb)
{
  drawFill *d = new drawFill(p,*pena,a,ra,*penb,b,rb);
  pic->append(d);
}

// Clip a picture to a path using the given fill rule.
// Subsequent additions to the picture will not be affected by the path.
void clip(picture *pic, path p, pen *n)
{
  pic->prepend(new drawClipBegin(p,*n));
  pic->append(new drawClipEnd());
}

void beginclip(picture *pic, path p, pen *n)
{
  pic->append(new drawClipBegin(p,*n,false));
}

void endclip(picture *pic)
{
  pic->append(new drawClipEnd(false));
}

void gsave (picture *pic)
{
  pic->append(new drawGsave());
}

void grestore (picture *pic)
{
  pic->append(new drawGrestore());
}

void begingroup(picture *pic)
{
  pic->append(new drawBegin());
}

void endgroup(picture *pic)
{
  pic->append(new drawEnd());
}

void add(picture *to, picture *from)
{
  to->add(*from);
}

void prepend(picture *to, picture *from)
{
  to->prepend(*from);
}

string fileprefix()
{
  return outname;
}

// Interactive mode
void interact(bool interaction)
{
  if(interact::interactive) settings::suppressStandard=!interaction;
}

bool interact()
{
  return interact::interactive && !settings::suppressStandard;
}

// System commands
int system(string *str)
{
  if(settings::suppressStandard) return 0;
  
  if(safe) error("system() call disabled; override with option -unsafe");
  else return System(str->c_str());
}

void abort(string *msg)
{
  error(msg->c_str());
}

// Path operations
pair point(path p, int n)
{
  return p.point(n);
}

pair point(path p, double t)
{
  return p.point(t);
}

pair precontrol(path p, int n)
{
  return p.precontrol(n);
}

pair precontrol(path p, double t)
{
  return p.precontrol(t);
}

pair postcontrol(path p, int n)
{
  return p.postcontrol(n);
}

pair postcontrol(path p, double t)
{
  return p.postcontrol(t);
}

pair dir(path p, int n)
{
  return unit(p.direction(n));
}

pair dir(path p, double t)
{
  return unit(p.direction(t));
}

path reverse(path p)
{
  return p.reverse();
}

path subpath(path p, int b, int e)
{
  return p.subpath(b,e);
}

path subpath(path p, double b, double e)
{
  return p.subpath(b,e);
}

int length(path p)
{
  return p.length();
}

bool cyclic(path p)
{
  return p.cyclic();
}

bool straight(path p, int i)
{
  return p.straight(i);
}

double arclength(path p)
{
  return p.arclength();
}

double arctime(path p, double dval)
{
  return p.arctime(dval);
}

double dirtime(path p, pair z)
{
  return p.directiontime(z);
}

pair intersect(path x, path y)
{
  return intersectiontime(x,y);
}

int length(string *s)
{
  return (int) s->length();
}

int find(string *s, string *sub, int pos)
{
  return (int) s->find(*sub,pos);
}

int rfind(string *s, string *sub, int pos)
{
  return (int) s->rfind(*sub,pos);
}

string reverse(string s)
{
  reverse(s.begin(),s.end());
  return s;
}

string insert(string s, int pos, string *sub)
{
  if ((size_t)pos < s.length())
    return s.insert(pos,*sub);
  return s;
}

string substr(string* s, int pos, int n)
{
  if ((size_t)pos < s->length())
    return s->substr(pos,n);
  return ""; // TODO: Make this shared again.
}

string erase(string s, int pos, int n)
{
  if ((size_t)pos < s.length())
    return s.erase(pos,n);
  return s; 
}
