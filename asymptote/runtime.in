/*****
 * runtime.in
 * Tom Prince 2005/4/15
 *
 * Generate the runtime functions used by the vm::stack machine.
 *
 *****/

/* Autogenerated routines are specified like this (separated by a formfeed):
   type asyname:cname(cparams)
   {
   C code
   }

*/

// Use Void f() instead of void f() to force an explicit Stack argument.


pen      => primPen()
pair     => primPair()
triple   => primTriple()
path     => primPath()
path3     => primPath3()
guide*   => primGuide()
cycleToken => primCycleToken()
tensionSpecifier => primTensionSpecifier()
curlSpecifier => primCurlSpecifier()
file*    => primFile()
picture* => primPicture()
transform => primTransform()
callable* => voidFunction()
callableBp* => breakpointFunction()
callableReal* => realRealFunction()
callableTransform* => transformFunction()
runnable* => primCode()
boolarray* => booleanArray()
Intarray*  => IntArray()
Intarray2*  => IntArray2()
realarray* => realArray()
realarray2* => realArray2()
pairarray* => pairArray()
pairarray2* => pairArray2()
triplearray* => tripleArray()
triplearray2* => tripleArray2()
patharray* => pathArray()  
patharray2* => pathArray2()  
guidearray* => guideArray()  
transformarray* => transformArray()
penarray* => penArray()  
penarray2* => penArray2()  
stringarray* => stringArray()
stringarray2* => stringArray2()

#include <cfloat>
#include <iostream>
#include <fstream>
#include <time.h>
#include <sys/times.h>
#include <locale.h>
  
#include "angle.h"
#include "pair.h"
#include "triple.h"
#include "transform.h"
#include "path.h"
#include "path3.h"
#include "pen.h"
#include "guide.h"
#include "picture.h"
#include "drawpath.h"
#include "drawpath3.h"
#include "drawsurface.h"
#include "drawfill.h"
#include "drawclipbegin.h"
#include "drawclipend.h"
#include "drawlabel.h"
#include "drawverbatim.h"
#include "drawgsave.h"
#include "drawgrestore.h"
#include "drawlayer.h"
#include "drawimage.h"
#include "drawgroup.h"
#include "fileio.h"
#include "genv.h"
#include "builtin.h"
#include "texfile.h"
#include "pipestream.h"
#include "parser.h"
#include "stack.h"
#include "util.h"
#include "locate.h"
#include "mathop.h"
#include "callable.h"
#include "stm.h"
#include "lexical.h"
#include "process.h"
#include "arrayop.h"
#include "predicates.h"
   
#if defined(USEGC) && defined(GC_DEBUG) && defined(GC_BACKTRACE)
  extern "C" {
    void *GC_generate_random_valid_address(void);
    void GC_debug_print_heap_obj_proc(void *);
  }
#endif

using namespace vm;
using namespace camp;
using namespace settings;

namespace run {
using camp::pair;
using vm::array;
using vm::frame;
using vm::stack;
using camp::transform;
using absyntax::runnable;

typedef array boolarray;
typedef array Intarray;
typedef array Intarray2;
typedef array realarray;
typedef array realarray2;
typedef array pairarray;
typedef array pairarray2;
typedef array triplearray;
typedef array triplearray2;
typedef array patharray;
typedef array patharray2;
typedef array guidearray;
typedef array transformarray;
typedef array penarray;
typedef array penarray2;
typedef array stringarray;
typedef array stringarray2;
  
typedef callable callableBp;
typedef callable callableReal;
typedef callable callableTransform;
}

using vm::array;
using types::function;

#define PRIMITIVE(name,Name,asyName) using types::prim##Name;
#include <primitives.h>
#undef PRIMITIVE

using types::booleanArray;
using types::IntArray;
using types::IntArray2;
using types::realArray;
using types::realArray2;
using types::pairArray;
using types::pairArray2;
using types::tripleArray;
using types::tripleArray2;
using types::pathArray;
using types::pathArray2;
using types::guideArray;
using types::transformArray;
using types::penArray;
using types::penArray2;
using types::stringArray;
using types::stringArray2;
using types::formal;

function *voidFunction()
{
  return new function(primVoid());
}

function *breakpointFunction()
{
  return new function(primString(),primString(),primInt(),primInt(),
                      primCode());
}

function *realRealFunction()
{
  return new function(primReal(),primReal());
}

function *transformFunction()
{
  return new function(primTransform());
}

function *realTripleFunction()
{
  return new function(primReal(),primTriple());
}

const size_t camp::ColorComponents[]={0,0,1,3,4,0};

namespace vm {
}

namespace run {
  
const char *invalidargument="invalid argument";
const char *arrayempty="cannot take min or max of empty array";
const char *noruntime="no runtime environment for embedded eval";

// Return the factorial of a non-negative integer using a lookup table.
Int factorial(Int n)
{
  static Int *table;
  static Int size=0;
  if(size == 0) {
    Int f=1;
    size=2;
    while(f <= Int_MAX/size)
      f *= (size++);
    table=new Int[size];
    table[0]=f=1;
    for(Int i=1; i < size; ++i) {
      f *= i;
      table[i]=f;
    }
  }
  if(n >= size) integeroverflow(0);
  return table[n];
}

static inline Int Round(double x) 
{
  return Int(x+((x >= 0) ? 0.5 : -0.5));
}

inline Int sgn(double x) 
{
  return (x > 0.0 ? 1 : (x < 0.0 ? -1 : 0));
}

array *nop(array *a) 
{
  return a;
}
  
void writestring(stack *s)
{
  callable *suffix=pop<callable *>(s,NULL);
  string S=pop<string>(s);
  vm::item it=pop(s);
  bool defaultfile=isdefault(it);
  camp::file *f=defaultfile ? &camp::Stdout : vm::get<camp::file*>(it);
  if(!f->isOpen()) return;
  if(S != "") f->write(S);
  if(f->text()) {
    if(suffix) {
      s->push(f);
      suffix->call(s);
    } else if(defaultfile) f->writeline();
  }
}

void purge(Int divisor=0)
{
#ifdef USEGC
  if(divisor > 0) GC_set_free_space_divisor((GC_word) divisor);
  GC_gcollect();
#endif
}

void updateFunction(stack *Stack)
{
  callable *atUpdateFunction=processData().atUpdateFunction;
  if(atUpdateFunction && !nullfunc::instance()->compare(atUpdateFunction))
    atUpdateFunction->call(Stack);
}

void exitFunction(stack *Stack)
{
  callable *atExitFunction=processData().atExitFunction;
  if(atExitFunction && !nullfunc::instance()->compare(atExitFunction))
    atExitFunction->call(Stack);
}

default_t def;
array *emptyarray=new array(0);
string commentchar="#";
string emptystring;
pair zero;

void breakpoint(stack *Stack, runnable *r)
{
  callable *atBreakpointFunction=processData().atBreakpointFunction;
  if(atBreakpointFunction &&
     !nullfunc::instance()->compare(atBreakpointFunction)) {
    position curPos=getPos();
    Stack->push<string>(curPos.filename());
    Stack->push<Int>((Int) curPos.Line());
    Stack->push<Int>((Int) curPos.Column());
    Stack->push(r ? r : item(def));
    atBreakpointFunction->call(Stack); // returns a string
  } else Stack->push<string>("");
}

}

namespace types {
extern const char *names[];
}

void checkformat(const char *ptr, bool intformat) 
{
  while(*ptr != '\0') {
    if(*ptr != '%') /* While we have regular characters, print them.  */
      ptr++;
    else { /* We've got a format specifier. */
      ptr++;
      
      while(*ptr && strchr ("-+ #0'I", *ptr)) /* Move past flags.  */
        *ptr++;

      if(*ptr == '*')
        ptr++;
      else while(isdigit(*ptr)) /* Handle explicit numeric value.  */
             ptr++;
          
      if(*ptr == '.') {
        *ptr++; /* Go past the period.  */
        if(*ptr == '*') {
          ptr++;
        } else
          while(isdigit(*ptr)) /* Handle explicit numeric value.  */
            *ptr++;
      }
      while(*ptr && strchr ("hlL", *ptr))
        *ptr++;
          
      if(*ptr == '%') ++ptr;
      else if(*ptr != '\0') {
        if(intformat) {
          switch(*ptr) {
            case 'd':
            case 'i':
            case 'o':
            case 'u':
            case 'x':
            case 'X':
            case 'c':
              break;
            default:
              ostringstream buf;
              buf << "Invalid format '" << *ptr << "' for type " 
                  << types::names[types::ty_Int];
              error(buf);
              break;
          }
        } else {
          switch(*ptr) {
            case 'f':
            case 'F':
            case 'e':
            case 'E':
            case 'g':
            case 'G':
              break;
            default:
              ostringstream buf;
              buf << "Invalid format '" << *ptr << "' for type "
                  << types::names[types::ty_real];
              error(buf);
              break;
          }
        }
      }
    } /* End of else statement */
  }
}
  
// Return an angle in the interval [0,360).
inline double principalBranch(double deg)
{
  if(deg < 0) deg += 360; 
  return deg;
}

static string defaulttransparency=string("Compatible");
static const string defaulttimeformat=string("%a %b %d %T %Z %Y");
#ifdef HAVE_STRFTIME
static const size_t nTime=256;
static char Time[nTime];
#endif  

void clear(string file, Int line, bool warn=false) 
{
  bpinfo bp(file,line);
  for(mem::list<bpinfo>::iterator p=bplist.begin(); p != bplist.end(); ++p) {
    if(*p == bp) {
      cout << "cleared breakpoint at " << file << ": " << line << endl;
      bplist.remove(bp);
      return;
    }
  }
  if(warn)
    cout << "No such breakpoint at "  << file << ": " << line << endl;
}

Int windingnumber(array *p, camp::pair z)
{
  size_t size=checkArray(p);
  Int count=0;
  for(size_t i=0; i < size; i++) 
    count += read<path *>(p,i)->windingnumber(z);
  return count;
}

string convertname(string name, const string& format, bool check=true)
{
  if(name.empty())
    return buildname(outname(),format,"");
  else
    if(check) checkLocal(name);
  return format.empty() ? name : format+":"+name;
}

void unused(void *)
{
}

// Ignore unclosed begingroups but not spurious endgroups.
const char *nobegin="endgroup without matching begingroup";
  
// Return the component of vector v perpendicular to a unit vector u.
inline triple perp(triple v, triple u)
{
  return v-dot(v,u)*u;
}

pair sin(pair z)
{
  return pair(sin(z.getx())*cosh(z.gety()),cos(z.getx())*sinh(z.gety())); 
}

pair exp(pair z) 
{ 
  return exp(z.getx())*expi(z.gety());
}

pair gamma(pair z)
{
  static double p[]={0.99999999999980993,676.5203681218851,-1259.1392167224028,
                     771.32342877765313,-176.61502916214059,12.507343278686905,
                     -0.13857109526572012,9.9843695780195716e-6,
                     1.5056327351493116e-7};
  static int n=sizeof(p)/sizeof(double);
  static double root2pi=sqrt(2*PI);
  if(z.getx() < 0.5)
    return PI/(sin(PI*z)*gamma(1.0-z));
  z -= 1.0;
  pair x=p[0];
  for(int i=1; i < n; ++i)
    x += p[i]/(z+i);
  pair t=n-1.5+z;
  return root2pi*pow(t,z+0.5)*exp(-t)*x;
}

// Autogenerated routines:



// Initializers

Int :IntZero()
{
  return 0;
}

real :realZero()
{
  return 0.0;
}

bool :boolFalse()
{
  return false;
}

array* :pushNullArray()
{
  return 0;
}

frame* :pushNullRecord()
{
  return 0;
}

item :pushNullFunction()
{
  return nullfunc::instance();
}


// Default operations

// Put the default value token on the stack (in place of an argument when
// making a function call).
item :pushDefault()
{
  return def;
}


// Test if the value on the stack is the default value token.
bool :isDefault(item i)
{
  return isdefault(i);
}


// Logical operations

bool !(bool b)
{
  return !b;
}

bool :boolMemEq(frame *a, frame *b)
{
  return a == b;
}

bool :boolMemNeq(frame *a, frame *b)
{
  return a != b;
}

bool :boolFuncEq(callable *a, callable *b)
{
  return a->compare(b);
}

bool :boolFuncNeq(callable *a, callable *b)
{
  return !(a->compare(b));
}


// Bit operations

Int AND(Int a, Int b) 
{
  return a & b;
}

Int OR(Int a, Int b) 
{
  return a | b;
}

Int XOR(Int a, Int b) 
{
  return a ^ b;
}

Int NOT(Int a)
{
  return ~a;
}


// Casts

guide* :pairToGuide(pair z) 
{
  return new pairguide(z);
}

guide* :pathToGuide(path p) 
{
  return new pathguide(p);
}

path :guideToPath(guide *g) 
{
  return g->solve();
}

void _draw(picture *f, path g, pen p)
{
  f->append(new drawPath(g,p));
}

void fill(picture *f, patharray *g, pen p=CURRENTPEN, bool copy=true)
{
  array *(*copyarray)(array *a)=copy ? copyArray: nop;
  f->append(new drawFill(*copyarray(g),false,p));
}

void latticeshade(picture *f, patharray *g, bool stroke=false,
                  pen fillrule=CURRENTPEN, penarray2 *p, bool copy=true)
{
  array *(*copyarray)(array *a)=copy ? copyArray: nop;
  f->append(new drawLatticeShade(*copyarray(g),stroke,fillrule,*copyarray(p)));
}

void axialshade(picture *f, patharray *g, bool stroke=false, pen pena, pair a,
                pen penb, pair b, bool copy=true)
{
  array *(*copyarray)(array *a)=copy ? copyArray: nop;
  f->append(new drawAxialShade(*copyarray(g),stroke,pena,a,penb,b));
}

void radialshade(picture *f, patharray *g, bool stroke=false, pen pena,
                 pair a, real ra, pen penb, pair b, real rb, bool copy=true)
{
  array *(*copyarray)(array *a)=copy ? copyArray: nop;
  f->append(new drawRadialShade(*copyarray(g),stroke,pena,a,ra,penb,b,rb));
}

void gouraudshade(picture *f, patharray *g, bool stroke=false,
                  pen fillrule=CURRENTPEN, penarray *p, pairarray *z,
                  Intarray *edges, bool copy=true)
{
  array *(*copyarray)(array *a)=copy ? copyArray: nop;
  checkArrays(p,z);
  checkArrays(z,edges);
  f->append(new drawGouraudShade(*copyarray(g),stroke,fillrule,*copyarray(p),
                                 *copyarray(z),*copyarray(edges)));
}

void gouraudshade(picture *f, patharray *g, bool stroke=false,
                  pen fillrule=CURRENTPEN, penarray *p, Intarray *edges,
                  bool copy=true)
{
  array *(*copyarray)(array *a)=copy ? copyArray: nop;
  size_t n=checkArrays(p,edges);
  size_t m=checkArray(g);
  array *z=new array(n);
  Int k=0;
  Int in=(Int) n;
  for(size_t j=0; j < m; ++j) {
    path *P=read<path *>(g,j);
    assert(P);
    Int stop=Min(P->size(),in-k);
    mem::vector<solvedKnot>& nodes=P->Nodes();
    for(Int i=0; i < stop; ++i)
      (*z)[k++]=nodes[i].point;
  }
  checkArrays(p,z);
  
  f->append(new drawGouraudShade(*copyarray(g),stroke,fillrule,*copyarray(p),
                                 *z,*copyarray(edges)));
}

void tensorshade(picture *f, patharray *g, bool stroke=false,
                 pen fillrule=CURRENTPEN, penarray2 *p, patharray *b=NULL,
                 pairarray2 *z=emptyarray, bool copy=true)
{
  array *(*copyarray)(array *a)=copy ? copyArray: nop;
  array *(*copyarray2)(array *a)=copy ? copyArray2: nop;
  if(b == NULL) b=g;
  size_t n=checkArrays(p,b);
  size_t nz=checkArray(z);
  if(nz != 0)
    checkEqual(nz,n);
  f->append(new drawTensorShade(*copyarray(g),stroke,fillrule,*copyarray2(p),
                                *copyarray(b),*copyarray2(z)));
}

void functionshade(picture *f, patharray *g, bool stroke=false,
                   pen fillrule=CURRENTPEN, string shader=emptystring,
                   bool copy=true)
{
  array *(*copyarray)(array *a)=copy ? copyArray: nop;
  f->append(new drawFunctionShade(*copyarray(g),stroke,fillrule,shader));
}

// Clip a picture to a superpath using the given fill rule.
// Subsequent additions to the picture will not be affected by the clipping.
void clip(picture *f, patharray *g, bool stroke=false,
          pen fillrule=CURRENTPEN, bool copy=true)
{
  array *(*copyarray)(array *a)=copy ? copyArray: nop;
  drawClipBegin *begin=new drawClipBegin(*copyarray(g),stroke,fillrule,true);
  f->enclose(begin,new drawClipEnd(true,begin));
}

void beginclip(picture *f, patharray *g, bool stroke=false,
               pen fillrule=CURRENTPEN, bool copy=true)
{
  array *(*copyarray)(array *a)=copy ? copyArray: nop;
  f->append(new drawClipBegin(*copyarray(g),stroke,fillrule,false));
}

void endclip(picture *f)
{
  f->append(new drawClipEnd(false));
}

void gsave(picture *f)
{
  f->append(new drawGsave());
}

void grestore(picture *f)
{
  f->append(new drawGrestore());
}

void begingroup(picture *f)
{
  f->append(new drawBegin());
}

void endgroup(picture *f)
{
  f->append(new drawEnd());
}

void add(picture *dest, picture *src)
{
  dest->add(*src);
}

void prepend(picture *dest, picture *src)
{
  dest->prepend(*src);
}

void postscript(picture *f, string s)
{
  f->append(new drawVerbatim(PostScript,s));
}

void tex(picture *f, string s)
{
  f->append(new drawVerbatim(TeX,s));
}

void postscript(picture *f, string s, pair min, pair max)
{
  f->append(new drawVerbatim(PostScript,s,min,max));
}

void tex(picture *f, string s, pair min, pair max)
{
  f->append(new drawVerbatim(TeX,s,min,max));
}

void texpreamble(string s)
{
  string t=s+"\n";
  processDataStruct &pd=processData();
  pd.TeXpipepreamble.push_back(t);
  pd.TeXpreamble.push_back(t);
}

void deletepreamble() 
{
  if(getSetting<bool>("inlinetex")) {
    unlink(auxname(outname(),"pre").c_str());
  }
}

void _labelpath(picture *f, string s, string size, path g, string justify,
                pair offset, pen p)
{
  f->append(new drawLabelPath(s,size,g,justify,offset,p));
}

void texreset()
{
  processDataStruct &pd=processData();
  pd.TeXpipepreamble.clear();
  pd.TeXpreamble.clear();
  pd.tex.pipeclose();
}

void layer(picture *f)
{
  f->append(new drawLayer());
}

void newpage(picture *f)
{
  f->append(new drawNewPage());
}

void _image(picture *f, realarray2 *data, pair initial, pair final,
            penarray *palette=NULL, transform t=identity, bool copy=true,
            bool antialias=false)
{
  array *(*copyarray)(array *a)=copy ? copyArray: nop;
  array *(*copyarray2)(array *a)=copy ? copyArray2: nop;
  f->append(new drawImage(*copyarray2(data),*copyarray(palette),
                          t*matrix(initial,final),antialias));
}

void _image(picture *f, penarray2 *data, pair initial, pair final,
            transform t=identity, bool copy=true, bool antialias=false)
{
  array *(*copyarray2)(array *a)=copy ? copyArray2: nop;
  f->append(new drawImage(*copyarray2(data),t*matrix(initial,final),antialias));
}

string nativeformat()
{
  return nativeformat();
}

bool latex()
{
  return latex(getSetting<string>("tex"));
}

bool pdf()
{
  return pdf(getSetting<string>("tex"));
}

void shipout(string prefix=emptystring, picture *f, picture *preamble=NULL,
             string format=emptystring, bool wait=false, bool view=true,
             callableTransform *xform)
{
  if(prefix.empty()) prefix=outname();

  picture *result=new picture;
  unsigned level=0;
  picture::nodelist::iterator p;
  for(p = f->nodes.begin(); p != f->nodes.end(); ++p) {
    xform->call(Stack);
    transform t=pop<transform>(Stack);
    static transform Zero=transform(0.0,0.0,0.0,0.0,0.0,0.0);
    bool Delete=(t == Zero);
    picture *group=new picture;
    assert(*p);
    if((*p)->endgroup()) error(nobegin);
    if((*p)->begingroup()) {
      ++level;
      while(p != f->nodes.end() && level) {
        if(!Delete) {
          drawElement *e=t.isIdentity() ? *p : (*p)->transformed(t);
          group->append(e);
        }
        ++p;
        if(p == f->nodes.end()) break;
        assert(*p);
        if((*p)->begingroup()) ++level;
        if((*p)->endgroup()) {
          if(level) --level;
          else error(nobegin);
        }
      }
    }
    if(p == f->nodes.end()) break;
    assert(*p);
    if(!Delete) {
      drawElement *e=t.isIdentity() ? *p : (*p)->transformed(t);
      group->append(e);
      result->add(*group);
    }
  }
    
  result->shipout(preamble,prefix,format,0.0,wait,view);
}

void shipout3(string prefix, picture *f, string format=emptystring,
              real width, real height, real angle, real zoom,
              triple m, triple M, pair shift, realarray2 *t,
              realarray *background, triplearray *lights, realarray2 *diffuse,
              realarray2 *ambient, realarray2 *specular,
              bool viewportlighting, bool view=true)
{
  size_t n=checkArrays(lights,diffuse);
  checkEqual(n,checkArray(ambient));
  checkEqual(n,checkArray(specular));
  
  real *T=copyArray2C(t,true,4);
  triple *Lights=copyTripleArrayC(lights);
  real* Background=copyArrayC(background);
  real *Diffuse=copyArray2C(diffuse,false,4);
  real *Ambient=copyArray2C(ambient,false,4);
  real *Specular=copyArray2C(specular,false,4);
    
  f->shipout3(prefix,format,width,height,angle,zoom,m,M,shift,T,Background,n,
              Lights,Diffuse,Ambient,Specular,viewportlighting,view);
  
  delete[] Specular;
  delete[] Ambient;
  delete[] Diffuse;
  delete[] Background;
  delete[] Lights;
  delete[] T;
}

void shipout3(string prefix, picture *f)
{
  f->shipout3(prefix);
}

void deconstruct(picture *f, picture *preamble=NULL, real magnification=1, 
                 callableTransform *xform)
{
  unsigned level=0;
  unsigned n=0;

  string prefix=outname();
  const string xformat="png";

  static long arg_max=sysconf(_SC_ARG_MAX);
  const unsigned maxargs=::min(arg_max/(prefix.size()+xformat.size()+25ul),
                               256ul);
  
  cout << maxargs << newl;
  
  string preformat=nativeformat();
  const string Done="Done";
  const string Error="Error";
  
  mem::vector<string> cmd;
  
  // Enforce ghostscript limitations.
  magnification=::max(magnification,0.0001);
  real res=::min(::max(magnification*72.0,2.0),8192.0);
  
  const char *converter=NULL, *hint=NULL;
  
  if(magnification > 0.0) {
    mem::list<string> nameStack;
    string outname;
    unsigned arg=0;
    unsigned batch=0;
    for(picture::nodelist::iterator p=f->nodes.begin();;) {
      if(p == f->nodes.end()) break;
      if(arg == 0) {
        cmd.clear();
        ostringstream buf;
        buf << batch << "_";
        outname=buildname(prefix+buf.str()+"%d",xformat,"");
        converter="gs";
        hint="Ghostscript";
        cmd.push_back(getSetting<string>(converter));
        cmd.push_back("-q");
        cmd.push_back("-dNOPAUSE");
        cmd.push_back("-dBATCH");
        cmd.push_back("-sDEVICE=pngalpha");
        cmd.push_back("-dEPSCrop");
        if(safe)
          cmd.push_back("-dSAFER");
        cmd.push_back("-r"+String(res)+"x"+String(res));
        cmd.push_back("-sOutputFile="+outname);
      }
      
      picture *group=new picture;
      xform->call(Stack);
      transform t=pop<transform>(Stack);
      assert(*p);
      if((*p)->endgroup()) {
        cout << Error << endl;
        error(nobegin);
      }
      if((*p)->begingroup()) {
        ++level;
        while(p != f->nodes.end() && level) {
          drawElement *e=t.isIdentity() ? *p : (*p)->transformed(t);
          group->append(e);
          ++p;
          if(p == f->nodes.end()) break;
          assert(*p);
          if((*p)->begingroup()) ++level;
          if((*p)->endgroup()) {
            if(level) --level;
            else {
              cout << Error << endl;
              error(nobegin);
            }
          }
        }
      }
      if(p != f->nodes.end()) {
        assert(*p);
        drawElement *e=t.isIdentity() ? *p : (*p)->transformed(t);
        group->append(e);
        bbox b;
        ostringstream buf;
        buf << prefix << "_" << n;
        group->shipout(preamble,buf.str(),preformat,magnification,false,false);
        string Preformat=group->Transparency() ? "pdf" : preformat;
        string name=buildname(buf.str(),Preformat);
        nameStack.push_back(name);
        cmd.push_back(name);
        b=group->bounds();
        b *= magnification;
      
        cout << b << newl;
        ++n;
        ++p;
        ++arg;
      }
      
      if(p == f->nodes.end() || arg >= maxargs) {
        arg=0;
        ++batch;
        cout.flush();
  
        int status=System(cmd,0,true,converter,hint);
        if(status) {
          cout << Error << endl;
          error("deconstruct failed");
        }
      }
    }
    
    if(!getSetting<bool>("keep")) {
      for(mem::list<string>::iterator p=nameStack.begin();
          p != nameStack.end(); ++p)
        unlink(p->c_str());
    }
    
    cout << Done << endl;
  }
}

void purge(Int divisor=0)
{
  purge(divisor);
}


// Pen operations

pen :newPen()
{
  return pen();
}

bool ==(pen a, pen b)
{
  return a == b;
}

bool !=(pen a, pen b)
{
  return a != b;
}

pen +(pen a, pen b)
{
  return a+b;
}

pen Operator *(real a, pen b)
{
  return a*b;
}

pen Operator *(pen a, real b)
{
  return b*a;
}

pair max(pen p)
{
  return p.bounds().Max();
}

pair min(pen p)
{
  return p.bounds().Min();
}

// Reset the meaning of pen default attributes.
void resetdefaultpen()
{
  processData().defaultpen=camp::pen::initialpen();
}

void defaultpen(pen p)
{
  processData().defaultpen=pen(resolvepen,p);
}

pen defaultpen()
{
  return processData().defaultpen;
}

bool invisible(pen p)
{
  return p.invisible();
}

pen invisible()
{
  return pen(invisiblepen);
}

pen gray(pen p)
{
  p.togrey();
  return p;
}

pen rgb(pen p)
{
  p.torgb();
  return p;
}

pen cmyk(pen p)
{
  p.tocmyk();
  return p;
}

pen interp(pen a, pen b, real t)
{
  return interpolate(a,b,t);
}

pen rgb(real r, real g, real b)
{
  return pen(r,g,b);
}

pen cmyk(real c, real m, real y, real k)
{
  return pen(c,m,y,k);  
}

pen gray(real gray)
{
  return pen(gray);
}

realarray *colors(pen p)
{  
  size_t n=ColorComponents[p.colorspace()];
  array *a=new array(n);
  
  switch(n) {
    case 0:
      break;
    case 1: 
      (*a)[0]=p.gray(); 
      break;
    case 3:
      (*a)[0]=p.red(); 
      (*a)[1]=p.green(); 
      (*a)[2]=p.blue(); 
      break;
    case 4:
      (*a)[0]=p.cyan();
      (*a)[1]=p.magenta(); 
      (*a)[2]=p.yellow(); 
      (*a)[3]=p.black();
      break;
    default:
      break;
  }
  return a;
}

string colorspace(pen p)
{
  string s=ColorDeviceSuffix[p.colorspace()];
  std::transform(s.begin(),s.end(),s.begin(),tolower);
  return s;
}

pen pattern(string *s)
{
  return pen(setpattern,*s);
}

string pattern(pen p)
{
  return p.fillpattern();  
}

pen fillrule(Int n)
{
  return pen(n >= 0 && n < nFill ? (FillRule) n : DEFFILL);
}

Int fillrule(pen p)
{
  return p.Fillrule();  
}

pen opacity(real opacity=1.0, string blend=defaulttransparency)
{
  for(Int i=0; i < nBlendMode; ++i)
    if(blend == BlendMode[i]) return pen(Transparency(blend,opacity));

  ostringstream buf;
  buf << "Unknown blend mode: " << "'" << blend << "'";
  error(buf);
}

real opacity(pen p)
{
  return p.opacity();
}

string blend(pen p)
{
  return p.blend();
}

pen linetype(string *s, real offset=0, bool scale=true, bool adjust=true)
{
  return pen(LineType(*s,offset,scale,adjust)); 
}

string linetype(pen p=CURRENTPEN)
{
  return p.stroke();  
}

real offset(pen p)
{
  return p.linetype().offset;
}

bool scale(pen p)
{
  return p.linetype().scale;
}

bool adjust(pen p)
{
  return p.linetype().adjust;
}

pen adjust(pen p, real arclength, bool cyclic)
{
  return adjustdash(p,arclength,cyclic);
}

pen linecap(Int n)
{
  return pen(setlinecap,n >= 0 && n < nCap ? n : DEFCAP);
}

Int linecap(pen p=CURRENTPEN)
{
  return p.cap();  
}

pen linejoin(Int n)
{
  return pen(setlinejoin,n >= 0 && n < nJoin ? n : DEFJOIN);
}

Int linejoin(pen p=CURRENTPEN)
{
  return p.join();  
}

pen miterlimit(real x)
{
  return pen(setmiterlimit,x >= 1.0 ? x : DEFJOIN);
}

real miterlimit(pen p=CURRENTPEN)
{
  return p.miter();  
}

pen linewidth(real x)
{
  return pen(setlinewidth,x >= 0.0 ? x : DEFWIDTH);
}

real linewidth(pen p=CURRENTPEN)
{
  return p.width();  
}

pen fontcommand(string *s)
{
  return pen(setfont,*s);
}

string font(pen p=CURRENTPEN)
{
  return p.Font();
}

pen fontsize(real size, real lineskip)
{
  return pen(setfontsize,size > 0.0 ? size : 0.0,
             lineskip > 0.0 ? lineskip : 0.0);
}

real fontsize(pen p=CURRENTPEN)
{
  return p.size();
}

real lineskip(pen p=CURRENTPEN)
{
  return p.Lineskip();  
}

pen overwrite(Int n)
{
  return pen(setoverwrite,n >= 0 && n < nOverwrite ? (overwrite_t) n :
             DEFWRITE);
}

Int overwrite(pen p=CURRENTPEN)
{
  return p.Overwrite();  
}

pen basealign(Int n)
{
  return pen(n >= 0 && n < nBaseLine ? (BaseLine) n : DEFBASE);
}

Int basealign(pen p=CURRENTPEN)
{
  return p.Baseline();
}

transform transform(pen p)
{
  return p.getTransform();
}

path nib(pen p)
{
  return p.Path();
}

pen makepen(path p)
{
  return pen(p);
}

pen colorless(pen p)
{
  p.colorless();
  return p;
}

// Interactive mode

bool interactive()
{
  return interact::interactive;
}

bool uptodate()
{
  return interact::uptodate;
}


// System commands

Int system(stringarray *s)
{
  if(safe) error("system() call disabled; override with option -nosafe");
  size_t size=checkArray(s);
  if(size == 0) return 0;
  mem::vector<string> cmd;
  for(size_t i=0; i < size; ++i)
    cmd.push_back(read<string>(s,i));
  return System(cmd);
}

bool view()
{
  return view();
}

string asydir() 
{
  return systemDir;
}

string locale(string s=emptystring)
{
  char *L=setlocale(LC_ALL,s.empty() ? NULL : s.c_str());
  return L != NULL ? string(L) : "";
}

void abort(string s=emptystring)
{
  if(s.empty()) throw handled_error();
  error(s.c_str());
}

void exit()
{
  throw quit();
}

void assert(bool b, string s=emptystring)
{
  flush(cout);
  if(!b) {
    ostringstream buf;
    buf << "assert FAILED";
    if(s != "") buf << ": " << s;
    error(buf);
  }
}

void sleep(Int seconds)
{
  if(seconds <= 0) return;      
  sleep(seconds);
}

void usleep(Int microseconds)
{
  if(microseconds <= 0) return; 
  usleep((unsigned long) microseconds); 
}

void _eval(string *s, bool embedded, bool interactiveWrite=false)
{
  if(embedded) {
    trans::coenv *e=Stack->getEnvironment();
    vm::interactiveStack *is=dynamic_cast<vm::interactiveStack *>(Stack);
    if(e && is)
      runStringEmbedded(*s, *e, *is);
    else
      error(noruntime);
  } else
    runString(*s,interactiveWrite);
}

void _eval(runnable *s, bool embedded)
{
  absyntax::block *ast=new absyntax::block(s->getPos(), false);
  ast->add(s);

  if(embedded) {
    trans::coenv *e=Stack->getEnvironment();
    vm::interactiveStack *is=dynamic_cast<vm::interactiveStack *>(Stack);
    if(e && is)
      runCodeEmbedded(ast, *e, *is);
    else
      error(noruntime);
  } else
    runCode(ast);
}

string location() {
  ostringstream buf;
  buf << getPos();
  return buf.str();
}

// Wrapper for the stack::load() method.
void :loadModule(string *index)
{
  Stack->load(*index);
}

string cd(string s=emptystring)
{
  if(!s.empty() && !globalwrite()) writeDisabled();
  return setPath(s.c_str());
}

void list(string *s, bool imports=false)
{
  if(*s == "-") return;
  trans::genv ge;
  symbol *name=symbol::trans(*s);
  record *r=ge.getModule(name,*s);
  r->e.list(imports ? 0 : r);
}


// Path operations

path :nullPath()
{
  return nullpath;
}

bool ==(path a, path b)
{
  return a == b;
}

bool !=(path a, path b)
{
  return !(a == b);
}

pair point(path p, Int t)
{
  return p.point((Int) t);
}

pair point(path p, real t)
{
  return p.point(t);
}

pair precontrol(path p, Int t)
{
  return p.precontrol((Int) t);
}

pair precontrol(path p, real t)
{
  return p.precontrol(t);
}

pair postcontrol(path p, Int t)
{
  return p.postcontrol((Int) t);
}

pair postcontrol(path p, real t)
{
  return p.postcontrol(t);
}

pair dir(path p, Int t, Int sign=0, bool normalize=true)
{
  return p.dir(t,sign,normalize);
}

pair dir(path p, real t, bool normalize=true)
{
  return p.dir(t,normalize);
}

pair accel(path p, Int t, Int sign=0)
{
  return p.accel(t,sign);
}

pair accel(path p, real t)
{
  return p.accel(t);
}

real radius(path p, real t)
{
  pair v=p.dir(t,false);
  pair a=p.accel(t);
  real d=dot(a,v);
  real v2=v.abs2();
  real a2=a.abs2();
  real denom=v2*a2-d*d;
  real r=v2*sqrt(v2);
  return denom > 0 ? r/sqrt(denom) : 0.0;
}

path reverse(path p)
{
  return p.reverse();
}

path subpath(path p, Int a, Int b)
{
  return p.subpath((Int) a, (Int) b);
}

path subpath(path p, real a, real b)
{
  return p.subpath(a,b);
}

path nurb(pair z0, pair z1, pair z2, pair z3,
          real w0, real w1, real w2, real w3, Int m)
{
  return nurb(z0,z1,z2,z3,w0,w1,w2,w3,m);
}

Int length(path p)
{
  return p.length();
}

bool cyclic(path p)
{
  return p.cyclic();
}

bool straight(path p, Int t)
{
  return p.straight(t);
}

path unstraighten(path p)
{
  return p.unstraighten();
}

bool piecewisestraight(path p)
{
  return p.piecewisestraight();
}

real arclength(path p)
{
  return p.arclength();
}

real arctime(path p, real dval)
{
  return p.arctime(dval);
}

real dirtime(path p, pair z)
{
  return p.directiontime(z);
}

realarray* intersect(path p, path q, real fuzz=-1)
{
  bool exact=fuzz <= 0.0;
  if(fuzz < 0)
    fuzz=BigFuzz*::max(::max(length(p.max()),length(p.min())),
                       ::max(length(q.max()),length(q.min())));
  std::vector<real> S,T;
  real s,t;
  if(intersections(s,t,S,T,p,q,fuzz,true,exact)) {
    array *V=new array(2);
    (*V)[0]=s;
    (*V)[1]=t;
    return V;
  }
  return new array(0);
}

realarray2* intersections(path p, path q, real fuzz=-1)
{
  bool exact=fuzz <= 0.0;
  if(fuzz < 0.0)
    fuzz=BigFuzz*::max(::max(length(p.max()),length(p.min())),
                       ::max(length(q.max()),length(q.min())));
  real s,t;
  std::vector<real> S,T;
  intersections(s,t,S,T,p,q,fuzz,false,true);
  size_t n=S.size();
  if(n == 0 && !exact) {
    if(intersections(s,t,S,T,p,q,fuzz,true,false)) {
      array *V=new array(1);
      array *Vi=new array(2);
      (*V)[0]=Vi;
      (*Vi)[0]=s;
      (*Vi)[1]=t;
      return V;
    }
  }
  array *V=new array(n);
  for(size_t i=0; i < n; ++i) {
    array *Vi=new array(2);
    (*V)[i]=Vi;
    (*Vi)[0]=S[i];
    (*Vi)[1]=T[i];
  }
  stable_sort(V->begin(),V->end(),run::compare2<real>());
  return V;
}

realarray* intersections(path p, explicit pair a, explicit pair b, real fuzz=-1)
{
  if(fuzz < 0)
    fuzz=BigFuzz*::max(::max(length(p.max()),length(p.min())),
                       ::max(length(a),length(b)));
  std::vector<real> S;
  intersections(S,p,a,b,fuzz);
  sort(S.begin(),S.end());
  size_t n=S.size();
  array *V=new array(n);
  for(size_t i=0; i < n; ++i)
    (*V)[i]=S[i];
  return V;
}

// Return the intersection point of the extensions of the line segments 
// PQ and pq.
pair extension(pair P, pair Q, pair p, pair q)
{
  pair ac=P-Q;
  pair bd=q-p;
  real det=ac.getx()*bd.gety()-ac.gety()*bd.getx();
  if(det == 0) return pair(infinity,infinity);
  return P+((p.getx()-P.getx())*bd.gety()-(p.gety()-P.gety())*bd.getx())*ac/det;
}

Int size(path p)
{
  return p.size();
}

path &(path p, path q)
{
  return camp::concat(p,q);
}

pair min(path p)
{
  return p.min();
}

pair max(path p)
{
  return p.max();
}

realarray *mintimes(path p)
{
  array *V=new array(2);
  pair z=p.mintimes();
  (*V)[0]=z.getx();
  (*V)[1]=z.gety();
  return V;
}

realarray *maxtimes(path p)
{
  array *V=new array(2);
  pair z=p.maxtimes();
  (*V)[0]=z.getx();
  (*V)[1]=z.gety();
  return V;
}

real relativedistance(real theta, real phi, real t, bool atleast)
{
  return camp::velocity(theta,phi,tension(t,atleast));
}

Int windingnumber(patharray *p, pair z)
{
  return windingnumber(p,z);
}

bool inside(explicit patharray *g, pair z, pen fillrule=CURRENTPEN)
{
  return fillrule.inside(windingnumber(g,z));
}

bool inside(path g, pair z, pen fillrule=CURRENTPEN)
{
  return fillrule.inside(g.windingnumber(z));
}

// Determine the side of a--b that c lies on
// (negative=left, zero=on line, positive=right).
real side(pair a, pair b, pair c) 
{
  return orient2d(a,b,c);
}

// Determine the side of the counterclockwise circle through a,b,c that d
// lies on (negative=inside, 0=on circle, positive=right). 
real incircle(pair a, pair b, pair c, pair d)
{
  return incircle(a.getx(),a.gety(),b.getx(),b.gety(),c.getx(),c.gety(),
                  d.getx(),d.gety());
}


// Path3 operations

path3 path3(triplearray *pre, triplearray *point, triplearray *post,
            boolarray *straight, bool cyclic)
{
  size_t n=checkArrays(pre,point);
  checkEqual(n,checkArray(post));
  checkEqual(n,checkArray(straight));
  mem::vector<solvedKnot3> nodes(n);
  for(size_t i=0; i < n; ++i) {
    nodes[i].pre=read<triple>(pre,i);
    nodes[i].point=read<triple>(point,i);
    nodes[i].post=read<triple>(post,i);
    nodes[i].straight=read<bool>(straight,i);
  }

  return path3(nodes,(Int) n,cyclic);
}

path3 :nullPath3()
{
  return nullpath3;
}

bool ==(path3 a, path3 b)
{
  return a == b;
}

bool !=(path3 a, path3 b)
{
  return !(a == b);
}

triple point(path3 p, Int t)
{
  return p.point((Int) t);
}

triple point(path3 p, real t)
{
  return p.point(t);
}

triple precontrol(path3 p, Int t)
{
  return p.precontrol((Int) t);
}

triple precontrol(path3 p, real t)
{
  return p.precontrol(t);
}

triple postcontrol(path3 p, Int t)
{
  return p.postcontrol((Int) t);
}

triple postcontrol(path3 p, real t)
{
  return p.postcontrol(t);
}

triple dir(path3 p, Int t, Int sign=0, bool normalize=true)
{
  return p.dir(t,sign,normalize);
}

triple dir(path3 p, real t, bool normalize=true)
{
  return p.dir(t,normalize);
}

triple accel(path3 p, Int t, Int sign=0)
{
  return p.accel(t,sign);
}

triple accel(path3 p, real t)
{
  return p.accel(t);
}

real radius(path3 p, real t)
{
  triple v=p.dir(t,false);
  triple a=p.accel(t);
  real d=dot(a,v);
  real v2=v.abs2();
  real a2=a.abs2();
  real denom=v2*a2-d*d;
  real r=v2*sqrt(v2);
  return denom > 0 ? r/sqrt(denom) : 0.0;
}

real radius(triple z0, triple c0, triple c1, triple z1, real t)
{
  triple v=(3.0*(z1-z0)+9.0*(c0-c1))*t*t+(6.0*(z0+c1)-12.0*c0)*t+3.0*(c0-z0);
  triple a=6.0*(z1-z0+3.0*(c0-c1))*t+6.0*(z0+c1)-12.0*c0;
  real d=dot(a,v);
  real v2=v.abs2();
  real a2=a.abs2();
  real denom=v2*a2-d*d;
  real r=v2*sqrt(v2);
  return denom > 0 ? r/sqrt(denom) : 0.0;
}

path3 reverse(path3 p)
{
  return p.reverse();
}

path3 subpath(path3 p, Int a, Int b)
{
  return p.subpath((Int) a, (Int) b);
}

path3 subpath(path3 p, real a, real b)
{
  return p.subpath(a,b);
}

Int length(path3 p)
{
  return p.length();
}

bool cyclic(path3 p)
{
  return p.cyclic();
}

bool straight(path3 p, Int t)
{
  return p.straight(t);
}

// Return the component of vector v perpendicular to a unit vector u.
triple perp(triple v, triple u)
{
  return perp(v,u);
}

// Return the maximum perpendicular deviation of segment i of path3 g
// from a straight line.
real straightness(path3 p, Int t) 
{
  if(p.straight(t)) return 0;
  triple z0=p.point(t);
  triple u=unit(p.point(t+1)-z0);
  return ::max(length(perp(p.postcontrol(t)-z0,u)),
               length(perp(p.precontrol(t+1)-z0,u)));
}

// Return the maximum perpendicular deviation of z0..controls c0 and c1..z1
// from a straight line.
real straightness(triple z0, triple c0, triple c1, triple z1)
{
  triple u=unit(z1-z0);
  return ::max(length(perp(c0-z0,u)),length(perp(c1-z0,u)));
}

bool piecewisestraight(path3 p)
{
  return p.piecewisestraight();
}

real arclength(path3 p)
{
  return p.arclength();
}

real arctime(path3 p, real dval)
{
  return p.arctime(dval);
}

realarray* intersect(path3 p, path3 q, real fuzz=-1)
{
  bool exact=fuzz <= 0.0;
  if(fuzz < 0)
    fuzz=BigFuzz*::max(::max(length(p.max()),length(p.min())),
                       ::max(length(q.max()),length(q.min())));
  
  std::vector<real> S,T;
  real s,t;
  if(intersections(s,t,S,T,p,q,fuzz,true,exact)) {
    array *V=new array(2);
    (*V)[0]=s;
    (*V)[1]=t;
    return V;
  } else
    return new array(0);
}

realarray2* intersections(path3 p, path3 q, real fuzz=-1)
{
  bool exact=fuzz <= 0.0;
  if(fuzz < 0)
    fuzz=BigFuzz*::max(::max(length(p.max()),length(p.min())),
                       ::max(length(q.max()),length(q.min())));
  bool single=!exact;
  
  real s,t;
  std::vector<real> S,T;
  bool found=intersections(s,t,S,T,p,q,fuzz,single,exact);
  if(!found) return new array(0);
  array *V;
  if(single) {
    V=new array(1);
    array *Vi=new array(2);
    (*V)[0]=Vi;
    (*Vi)[0]=s;
    (*Vi)[1]=t;
  } else {
    size_t n=S.size();
    V=new array(n);
    for(size_t i=0; i < n; ++i) {
      array *Vi=new array(2);
      (*V)[i]=Vi;
      (*Vi)[0]=S[i];
      (*Vi)[1]=T[i];
    }
  }
  stable_sort(V->begin(),V->end(),run::compare2<real>());
  return V;
}

realarray2* intersections(path3 p, triplearray2 *P, real fuzz=-1)
{
  triple *A=copyTripleArray2C(P,true,4);
  if(fuzz <= 0) fuzz=BigFuzz*::max(::max(length(p.max()),length(p.min())),
                                   norm(A,16));
  std::vector<real> T,U,V;
  intersections(T,U,V,p,A,fuzz);
  delete[] A;
  size_t n=T.size();
  array *W=new array(n);
  for(size_t i=0; i < n; ++i) {
    array *Wi=new array(3);
    (*W)[i]=Wi;
    (*Wi)[0]=T[i];
    (*Wi)[1]=U[i];
    (*Wi)[2]=V[i];
  }
  return W; // Sorting will done in asy.
}

Int size(path3 p)
{
  return p.size();
}

path3 &(path3 p, path3 q)
{
  return camp::concat(p,q);
}

triple min(path3 p)
{
  return p.min();
}

triple max(path3 p)
{
  return p.max();
}

realarray *mintimes(path3 p)
{
  array *V=new array(3);
  triple v=p.mintimes();
  (*V)[0]=v.getx();
  (*V)[1]=v.gety();
  (*V)[2]=v.getz();
  return V;
}

realarray *maxtimes(path3 p)
{
  array *V=new array(3);
  triple v=p.maxtimes();
  (*V)[0]=v.getx();
  (*V)[1]=v.gety();
  (*V)[2]=v.getz();
  return V;
}

path3 Operator *(realarray2 *t, path3 g)
{
  return transformed(*t,g);
}


// Guide operations

guide* :nullGuide()
{
  return new pathguide(path());
}

guide* :dotsGuide(guidearray *a)
{
  guidevector v;
  size_t size=checkArray(a);
  for (size_t i=0; i < size; ++i)
    v.push_back(a->read<guide*>(i));

  return new multiguide(v);
}

guide* :dashesGuide(guidearray *a)
{
  static camp::curlSpec curly;
  static specguide curlout(&curly, camp::OUT);
  static specguide curlin(&curly, camp::IN);

  size_t n=checkArray(a);

  // a--b is equivalent to a{curl 1}..{curl 1}b
  guidevector v;
  if (n > 0)
    v.push_back(a->read<guide*>(0));

  if (n==1) {
    v.push_back(&curlout);
    v.push_back(&curlin);
  }
  else
    for (size_t i=1; i<n; ++i) {
      v.push_back(&curlout);
      v.push_back(&curlin);
      v.push_back(a->read<guide*>(i));
    }

  return new multiguide(v);
}

cycleToken :newCycleToken()
{
  return cycleToken();
}

guide *operator cast(cycleToken tok)
{
// Avoid unused variable warning messages.
  unused(&tok);
  return new cycletokguide();
}

guide* operator spec(pair z, Int p)
{
  camp::side d=(camp::side) p;
  camp::dirSpec *sp=new camp::dirSpec(z);

  return new specguide(sp,d);
}

curlSpecifier operator curl(real gamma, Int p)
{
  camp::side s=(camp::side) p;
  return curlSpecifier(gamma,s);
}

real :curlSpecifierValuePart(curlSpecifier spec)
{
  return spec.getValue();
}

Int :curlSpecifierSidePart(curlSpecifier spec)
{
  return spec.getSide();
}

guide *operator cast(curlSpecifier spec)
{
  return new specguide(spec);
}

tensionSpecifier operator tension(real tout, real tin, bool atleast)
{
  return tensionSpecifier(tout, tin, atleast);
}

real :tensionSpecifierOutPart(tensionSpecifier t)
{
  return t.getOut();
}

real :tensionSpecifierInPart(tensionSpecifier t)
{
  return t.getIn();
}

bool :tensionSpecifierAtleastPart(tensionSpecifier t)
{
  return t.getAtleast();
}

guide *operator cast(tensionSpecifier t)
{
  return new tensionguide(t);
}

guide* operator controls(pair zout, pair zin)
{
  return new controlguide(zout, zin);
}

Int size(guide *g)
{
  flatguide f;
  g->flatten(f,false);
  return f.size();
}

Int length(guide *g)
{
  flatguide f;
  g->flatten(f,false);
  return g->cyclic() ? f.size() : f.size()-1;
}

bool cyclic(guide *g)
{
  flatguide f;
  g->flatten(f,false);
  return g->cyclic();
}

pair point(guide *g, Int t)
{
  flatguide f;
  g->flatten(f,false);
  return f.Nodes(adjustedIndex(t,f.size(),g->cyclic())).z;
}

pairarray *dirSpecifier(guide *g, Int t)
{
  flatguide f;
  g->flatten(f,false);
  Int n=f.size();
  if(!g->cyclic() && (t < 0 || t >= n-1)) return new array(0);
  array *c=new array(2);
  (*c)[0]=f.Nodes(t).out->dir();
  (*c)[1]=f.Nodes(t+1).in->dir();
  return c;
}

pairarray *controlSpecifier(guide *g, Int t)
{
  flatguide f;
  g->flatten(f,false);
  Int n=f.size();
  if(!g->cyclic() && (t < 0 || t >= n-1)) return new array(0);
  knot curr=f.Nodes(t);
  knot next=f.Nodes(t+1);
  if(curr.out->controlled()) {
    assert(next.in->controlled());
    array *c=new array(2);
    (*c)[0]=curr.out->control();
    (*c)[1]=next.in->control();
    return c;
  } else return new array(0);
}

tensionSpecifier tensionSpecifier(guide *g, Int t)
{
  flatguide f;
  g->flatten(f,false);
  Int n=f.size();
  if(!g->cyclic() && (t < 0 || t >= n-1)) return tensionSpecifier(1.0,1.0,false);
  knot curr=f.Nodes(t);
  return tensionSpecifier(curr.tout.val,f.Nodes(t+1).tin.val,curr.tout.atleast);
}

realarray *curlSpecifier(guide *g, Int t)
{
  flatguide f;
  g->flatten(f,false);
  Int n=f.size();
  if(!g->cyclic() && (t < 0 || t >= n-1)) return new array(0);
  array *c=new array(2);
  real c0=f.Nodes(t).out->curl();
  real c1=f.Nodes(t+1).in->curl();
  (*c)[0]=c0 >= 0.0 ? c0 : 1.0;
  (*c)[1]=c1 >= 0.0 ? c1 : 1.0;
  return c;
}

guide *reverse(guide *g)
{
  flatguide f;
  g->flatten(f,false);
  if(f.precyclic())
    return new pathguide(g->solve().reverse());

  size_t n=f.size();
  bool cyclic=g->cyclic();
  guidevector v;
  if(n >= 0) {
    size_t start=cyclic ? n : n-1;
    knot curr=f.Nodes(start);
    knot next;
    for(size_t i=start; i > 0; --i) {
      next=f.Nodes(i-1);
      v.push_back(new pairguide(curr.z));
      if(next.out->controlled()) {
        assert(curr.in->controlled());
        v.push_back(new controlguide(curr.in->control(),next.out->control()));
      } else {
        pair d=curr.in->dir();
        if(d != zero) 
          v.push_back(new specguide(new dirSpec(-d),camp::OUT));
        else {
          real C=curr.in->curl();
          if(C >= 0.0)
            v.push_back(new specguide(new curlSpec(C),camp::OUT));
        }
        real tout=curr.tin.val;
        real tin=next.tout.val;
        bool atleast=next.tout.atleast;
        if(tout != 1.0 || tin != 1.0 || next.tout.atleast)
          v.push_back(new tensionguide(tensionSpecifier(tout,tin,atleast)));
        d=next.out->dir();      
        if(d != zero) 
          v.push_back(new specguide(new dirSpec(-d),camp::IN));
        else {
          real C=next.out->curl();
          if(C >= 0.0)
            v.push_back(new specguide(new curlSpec(C),camp::IN));
        }
      }
      curr=next;
    }
    if(cyclic)
      v.push_back(new cycletokguide());
    else
      v.push_back(new pairguide(next.z));
      
  }
  return new multiguide(v);
}


// Three-dimensional picture and surface operations

void _draw(picture *f, path3 g, pen p)
{
  if(g.size() > 0)
    f->append(new drawPath3(g,p));
}

// Bezier patch
void draw(picture *f, triplearray2 *P, bool straight, penarray *p, real opacity,
          real shininess, real PRCshininess, real granularity, triple normal,
          penarray *colors, bool lighton)
{
  f->append(new drawSurface(*P,straight,*p,opacity,shininess,PRCshininess,
                            granularity,normal,*colors,lighton));
}

// General NURBS surface
void draw(picture *f, triplearray2 *P, realarray *uknot, realarray *vknot,
          realarray2 *weights=emptyarray, penarray *p,
          real opacity, real shininess, real PRCshininess, real granularity,
          penarray *colors, bool lighton)
{
  f->append(new drawNurbs(*P,uknot,vknot,weights,*p,opacity,shininess,
                          PRCshininess,granularity,*colors,lighton));
}

triple min3(picture *f)
{
  return f->bounds3().Min();
}

triple max3(picture *f)
{
  return f->bounds3().Max();
}

pair minratio(picture *f)
{
  return f->ratio(::min);
}

pair maxratio(picture *f)
{
  return f->ratio(::max);
}

triple minbezier(triplearray2 *P, triple b)
{
  real *A=copyTripleArray2Components(P,true,4);
  b=triple(bound(A,::min,b.getx(),sqrtFuzz*norm(A,16)),
           bound(A+16,::min,b.gety(),sqrtFuzz*norm(A+16,16)),
           bound(A+32,::min,b.getz(),sqrtFuzz*norm(A+32,16)));
  delete[] A;
  return b;
}

triple maxbezier(triplearray2 *P, triple b)
{
  real *A=copyTripleArray2Components(P,true,4);
  b=triple(bound(A,::max,b.getx(),sqrtFuzz*norm(A,16)),
           bound(A+16,::max,b.gety(),sqrtFuzz*norm(A+16,16)),
           bound(A+32,::max,b.getz(),sqrtFuzz*norm(A+32,16)));
  delete[] A;
  return b;
}

pair minratio(triplearray2 *P, pair b)
{
  triple *A=copyTripleArray2C(P,true,4);
  real fuzz=sqrtFuzz*norm(A,16);
  b=pair(bound(A,::min,xratio,b.getx(),fuzz),
         bound(A,::min,yratio,b.gety(),fuzz));
  delete[] A;
  return b;
}

pair maxratio(triplearray2 *P, pair b)
{
  triple *A=copyTripleArray2C(P,true,4);
  real fuzz=sqrtFuzz*norm(A,16);
  b=pair(bound(A,::max,xratio,b.getx(),fuzz),
         bound(A,::max,yratio,b.gety(),fuzz));
  delete[] A;
  return b;
}

pair minratio(path3 g)
{
  return g.ratio(::min);
}

pair maxratio(path3 g)
{
  return g.ratio(::max);
}

real norm(realarray *a)
{
  size_t n=checkArray(a);
  real M=0.0;
  for(size_t i=0; i < n; ++i) {
    real x=fabs(vm::read<real>(a,i));
    if(x > M) M=x;
  }
  return M;
}

real norm(realarray2 *a)
{
  size_t n=checkArray(a);
  real M=0.0;
  for(size_t i=0; i < n; ++i) {
    vm::array *ai=vm::read<vm::array*>(a,i);
    size_t m=checkArray(ai);
    for(size_t j=0; j < m; ++j) {
      real a=fabs(vm::read<real>(ai,j));
      if(a > M) M=a;
    }
  }
  return M;
}

real norm(triplearray2 *a)
{
  size_t n=checkArray(a);
  real M=0.0;
  for(size_t i=0; i < n; ++i) {
    vm::array *ai=vm::read<vm::array*>(a,i);
    size_t m=checkArray(ai);
    for(size_t j=0; j < m; ++j) {
      real a=vm::read<triple>(ai,j).abs2();
      if(a > M) M=a;
    }
  }
  return sqrt(M);
}

real change2(triplearray2 *a)
{
  size_t n=checkArray(a);
  if(n == 0) return 0.0;
  
  vm::array *a0=vm::read<vm::array*>(a,0);
  size_t m=checkArray(a0);
  if(m == 0) return 0.0;
  triple a00=vm::read<triple>(a0,0);
  real M=0.0;
    
  for(size_t i=0; i < n; ++i) {
    vm::array *ai=vm::read<vm::array*>(a,i);
    size_t m=checkArray(ai);
    for(size_t j=0; j < m; ++j) {
      real a=(vm::read<triple>(ai,j)-a00).abs2();
      if(a > M) M=a;
    }
  }
  return M;
}

bool is3D(picture *f)
{
  return f->have3D();
}

pair bezier(pair a, pair b, pair c, pair d, real t) 
{
  real onemt=1-t;
  real onemt2=onemt*onemt;
  return onemt2*onemt*a+t*(3.0*(onemt2*b+t*onemt*c)+t*t*d);
}

pair bezierP(pair a, pair b, pair c, pair d, real t) 
{
  return 3.0*(t*t*(d-a+3.0*(b-c))+t*(2.0*(a+c)-4.0*b)+b-a);
}

pair bezierPP(pair a, pair b, pair c, pair d, real t) 
{
  return 6.0*(t*(d-a+3.0*(b-c))+a+c-2.0*b);
}

pair bezierPPP(pair a, pair b, pair c, pair d) 
{
  return 6.0*(d-a+3.0*(b-c));
}

triple bezier(triple a, triple b, triple c, triple d, real t) 
{
  real onemt=1-t;
  real onemt2=onemt*onemt;
  return onemt2*onemt*a+t*(3.0*(onemt2*b+t*onemt*c)+t*t*d);
}

triple bezierP(triple a, triple b, triple c, triple d, real t) 
{
  return 3.0*(t*t*(d-a+3.0*(b-c))+t*(2.0*(a+c)-4.0*b)+b-a);
}

triple bezierPP(triple a, triple b, triple c, triple d, real t) 
{
  return 6.0*(t*(d-a+3.0*(b-c))+a+c-2.0*b);
}

triple bezierPPP(triple a, triple b, triple c, triple d) 
{
  return 6.0*(d-a+3.0*(b-c));
}


// String operations

string :emptyString()
{
  return emptystring;
}

Int length(string *s)
{
  return (Int) s->length();
}

Int find(string *s, string t, Int pos=0)
{
  size_t n=s->find(t,pos);
  return n == string::npos ? (Int) -1 : (Int) n;
}

Int rfind(string *s, string t, Int pos=-1)
{
  size_t n=s->rfind(t,pos);
  return n == string::npos ? (Int) -1 : (Int) n;
}

string reverse(string s)
{
  reverse(s.begin(),s.end());
  return s;
}

string insert(string s, Int pos, string t)
{
  if ((size_t) pos < s.length())
    return s.insert(pos,t);
  return s;
}

string substr(string* s, Int pos, Int n=-1)
{
  if ((size_t) pos < s->length())
    return s->substr(pos,n);
  return emptystring;
}

string erase(string s, Int pos, Int n)
{
  if ((size_t) pos < s.length())
    return s.erase(pos,n);
  return s; 
}

string downcase(string s)
{
  std::transform(s.begin(),s.end(),s.begin(),tolower);
  return s;
}

string upcase(string s)
{
  std::transform(s.begin(),s.end(),s.begin(),toupper);
  return s;
}

// returns a string constructed by translating all occurrences of the string
// from in an array of string pairs {from,to} to the string to in string s.
string replace(string *S, stringarray2 *translate)
{
  size_t size=checkArray(translate);
  for(size_t i=0; i < size; i++) {
    array *a=read<array*>(translate,i);
    checkArray(a);
  }
  const char *p=S->c_str();
  ostringstream buf;
  while(*p) {
    for(size_t i=0; i < size;) {
      array *a=read<array*>(translate,i);
      string* from=read<string*>(a,0);
      size_t len=from->length();
      if(strncmp(p,from->c_str(),len) != 0) {i++; continue;}
      buf << read<string>(a,1);
      p += len;
      if(*p == 0) return buf.str();
      i=0;
    }
    buf << *(p++);
  }
  return buf.str();
}

string format(string *format, Int x)
{
  const char *f=format->c_str();
  
  checkformat(f,true);
  
  Int size=snprintf(NULL,0,f,x)+1;
  if(size < 1) size=255; // Workaround for non-C99 compliant systems.
  char *buf=new char[size];
  snprintf(buf,size,f,x);
  string s=string(buf);
  delete[] buf;
  return s;
}

string format(string *format, real x, string locale=emptystring) 
{
  bool tex=getSetting<string>("tex") != "none";
  bool texify=false;
  ostringstream out;
  
  checkformat(format->c_str(),false);

  const char *phantom="\\phantom{+}";
  const char *p0=format->c_str();
  
  const char *p=p0;
  const char *start=NULL;
  char prev=0;
  while(*p != 0) {
    char curr=*p;
    if(tex && curr == '$' && prev != '\\') texify=true;
    prev=curr;
    if(curr == '%') {
      p++;
      if(*p != '%') {start=p-1; break;}
    }
    out << *(p++);
  }
  
  if(!start) return out.str();
  
  // Allow at most 1 argument  
  while(*p != 0) {
    if(*p == '*' || *p == '$') return out.str();
    if(isupper(*p) || islower(*p)) {p++; break;}
    p++;
  }
  
  const char *tail=p;
  string f=format->substr(start-p0,tail-start);

  const char *oldlocale=NULL;
  if(!locale.empty()) {
    oldlocale=setlocale(LC_ALL,NULL);
    if(oldlocale) oldlocale=StrdupNoGC(oldlocale);
    setlocale(LC_ALL,locale.c_str());
  }

  Int size=snprintf(NULL,0,f.c_str(),x)+1;
  if(size < 1) size=255; // Workaround for non-C99 compliant systems.
  char *buf=new char[size];
  snprintf(buf,size,f.c_str(),x);

  if(oldlocale) {
    setlocale(LC_ALL,oldlocale);
    delete[] oldlocale;
  }
  
  bool trailingzero=f.find("#") < string::npos;
  bool plus=f.find("+") < string::npos;
  bool space=f.find(" ") < string::npos;
  
  char *q=buf; // beginning of formatted number

  if(*q == ' ') {
    out << phantom;
    q++;
  }
  
  const char decimal=*(localeconv()->decimal_point);

  // Remove any spurious sign
  if(*q == '-' || *q == '+') {
    p=q+1;
    bool zero=true;
    while(*p != 0) {
      if(!isdigit(*p) && *p != decimal) break;
      if(isdigit(*p) && *p != '0') {zero=false; break;}
      p++;
    }
    if(zero) {
      q++;
      if(plus || space) out << phantom;
    }
  }
  
  const char *r=p=q;
  bool dp=false;
  while(*r != 0 && (isdigit(*r) || *r == decimal || *r == '+' || *r == '-')) {
    if(*r == decimal) dp=true;
    r++;
  }
  if(dp) { // Remove trailing zeros and/or decimal point
    r--;
    unsigned n=0;
    while(r > q && *r == '0') {r--; n++;}
    if(*r == decimal) {r--; n++;}
    while(q <= r) out << *(q++);
    if(!trailingzero) q += n;
  }
  
  bool zero=(r == p && *r == '0') && !trailingzero;
  
  // Translate "E+/E-/e+/e-" exponential notation to TeX
  while(*q != 0) {
    if(texify && (*q == 'E' || *q == 'e') && 
       (*(q+1) == '+' || *(q+1) == '-')) {
      if(!zero) out << "\\!\\times\\!10^{";
      bool plus=(*(q+1) == '+');
      q++;
      if(plus) q++;
      if(*q == '-') out << *(q++);
      while(*q == '0' && (zero || isdigit(*(q+1)))) q++;
      while(isdigit(*q)) out << *(q++);
      if(!zero)
        out << "}";
      break;
    }
    out << *(q++);
  }
  
  while(*tail != 0) 
    out << *(tail++);
  
  delete[] buf;

  return out.str();
}

Int hex(string s)
{
  istringstream is(s);
  is.setf(std::ios::hex,std::ios::basefield);
  Int value;
  if(is && is >> value && ((is >> std::ws).eof())) return value;
  ostringstream buf;
  buf << "invalid hexidecimal cast from string \"" << s << "\"";
  error(buf);
}

string string(Int x)
{
  ostringstream buf;
  buf << x;
  return buf.str();
}

string string(real x, Int digits=DBL_DIG)
{
  ostringstream buf;
  buf.precision(digits);
  buf << x;
  return buf.str();
}

string time(string format=defaulttimeformat)
{
#ifdef HAVE_STRFTIME
  const time_t bintime=time(NULL);
  if(!strftime(Time,nTime,format.c_str(),localtime(&bintime))) return "";
  return Time;
#else
  return format;
#endif  
}

string time(Int seconds, string format=defaulttimeformat)
{
#ifdef HAVE_STRFTIME
  const time_t bintime=seconds;
  if(!strftime(Time,nTime,format.c_str(),localtime(&bintime))) return "";
  return Time;
#else
// Avoid unused variable warning messages
  unused(&seconds);
  return format;
#endif
}

Int seconds(string t=emptystring, string format=emptystring)
{
#if defined(HAVE_STRPTIME)
  const time_t bintime=time(NULL);
  tm tm=*localtime(&bintime);
  if(t != "" && !strptime(t.c_str(),format.c_str(),&tm)) return -1;
  return (Int) mktime(&tm);
#else
  return -1;
#endif  
}

realarray *_cputime()
{
  static const real ticktime=1.0/sysconf(_SC_CLK_TCK);
  struct tms buf;

  ::times(&buf);
  array *t=new array(4);
  (*t)[0] = ((real) buf.tms_utime)*ticktime;
  (*t)[1] = ((real) buf.tms_stime)*ticktime;
  (*t)[2] = ((real) buf.tms_cutime)*ticktime;
  (*t)[3] = ((real) buf.tms_cstime)*ticktime;
  return t;
}


// Math

real ^(real x, Int y)
{
  return pow(x,y);
}

pair ^(pair z, Int y)
{
  return pow(z,y);
}

Int quotient(Int x, Int y)
{ 
  if(y == 0) dividebyzero();
  if(y == -1) return Negate(x);
// Implementation-independent definition of integer division: round down
  return (x-portableMod(x,y))/y;
}  

Int abs(Int x)
{ 
  return Abs(x);
}  

Int sgn(real x)
{ 
  return sgn(x);
}  

Int rand()
{ 
  return rand();
}  

void srand(Int seed)
{ 
  srand(intcast(seed));
}  

// a random number uniformly distributed in the interval [0,1]
real unitrand()
{                         
  return ((real) rand())/RAND_MAX;
}

Int ceil(real x)
{ 
  return Intcast(ceil(x));
}

Int floor(real x)
{ 
  return Intcast(floor(x));
}

Int round(real x)
{ 
  if(validInt(x)) return Round(x);
  integeroverflow(0);
}

Int Ceil(real x)
{ 
  return Ceil(x);
}

Int Floor(real x)
{ 
  return Floor(x);
}

Int Round(real x)
{ 
  return Round(Intcap(x));
}

real fmod(real x, real y)
{
  if (y == 0.0) dividebyzero();
  return fmod(x,y);
}

real atan2(real y, real x)
{ 
  return atan2(y,x);
}  

real hypot(real x, real y)
{ 
  return hypot(x,y);
}  

real remainder(real x, real y)
{ 
  return remainder(x,y);
}  

real J(Int n, real x)
{
  return jn(n,x);
}

real Y(Int n, real x)
{
  return yn(n,x);
}

real erf(real x)
{
  return erf(x);
}

real erfc(real x)
{
  return erfc(x);
}

Int factorial(Int n) {
  if(n < 0) error(invalidargument);
  return factorial(n);
}

Int choose(Int n, Int k) {
  if(n < 0 || k < 0 || k > n) error(invalidargument);
  Int f=1;
  Int r=n-k;
  for(Int i=n; i > r; --i) {
    if(f > Int_MAX/i) integeroverflow(0);
    f=(f*i)/(n-i+1);
  }
  return f;
}

real gamma(real x)
{
#ifdef HAVE_TGAMMA
  return tgamma(x);
#else
  real lg = lgamma(x);
  return signgam*exp(lg);
#endif
}

// Complex Gamma function
pair gamma(explicit pair z)
{
  return gamma(z);
}

realarray *quadraticroots(real a, real b, real c)
{
  quadraticroots q(a,b,c);
  array *roots=new array(q.roots);
  if(q.roots >= 1) (*roots)[0]=q.t1;
  if(q.roots == 2) (*roots)[1]=q.t2;
  return roots;
}

pairarray *quadraticroots(explicit pair a, explicit pair b, explicit pair c)
{
  Quadraticroots q(a,b,c);
  array *roots=new array(q.roots);
  if(q.roots >= 1) (*roots)[0]=q.z1;
  if(q.roots == 2) (*roots)[1]=q.z2;
  return roots;
}

realarray *cubicroots(real a, real b, real c, real d)
{
  cubicroots q(a,b,c,d);
  array *roots=new array(q.roots);
  if(q.roots >= 1) (*roots)[0]=q.t1;
  if(q.roots >= 2) (*roots)[1]=q.t2;
  if(q.roots == 3) (*roots)[2]=q.t3;
  return roots;
}

  
// Transforms

bool ==(transform a, transform b)
{
  return a == b;
}

bool !=(transform a, transform b)
{
  return a != b;
}

transform +(transform a, transform b)
{
  return a+b;
}

transform Operator *(transform a, transform b)
{
  return a*b;
}

pair Operator *(transform t, pair z)
{
  return t*z;
}

path Operator *(transform t, path g)
{
  return transformed(t,g);
}

pen Operator *(transform t, pen p)
{
  return transformed(t,p);
}

picture * Operator *(transform t, picture *f)
{
  return transformed(t,f);
}

picture * Operator *(realarray2 *t, picture *f)
{
  return transformed(*t,f);
}

transform ^(transform t, Int n)
{
  transform T;
  if(n < 0) {
    n=-n;
    t=inverse(t);
  }
  for(Int i=0; i < n; i++) T=T*t;
  return T;
}

real :transformXPart(transform t)
{
  return t.getx();
}

real :transformYPart(transform t)
{
  return t.gety();
}

real :transformXXPart(transform t)
{
  return t.getxx();
}

real :transformXYPart(transform t)
{
  return t.getxy();
}

real :transformYXPart(transform t)
{
  return t.getyx();
}

real :transformYYPart(transform t)
{
  return t.getyy();
}

transform :real6ToTransform(real x, real y, real xx, real xy,
                            real yx, real yy)
{
  return transform(x,y,xx,xy,yx,yy);
}

transform shift(transform t)
{
  return transform(t.getx(),t.gety(),0,0,0,0);
}

transform shiftless(transform t)
{
  return transform(0,0,t.getxx(),t.getxy(),t.getyx(),t.getyy());
}

transform identity:transformIdentity()
{
  return identity;
}

transform inverse(transform t)
{
  return inverse(t);
}

transform shift(pair z)
{
  return shift(z);
}

transform shift(real x, real y)
{
  return shift(pair(x,y));
}

transform xscale(real x)
{
  return xscale(x);
}

transform yscale(real y)
{
  return yscale(y);
}

transform scale(real x)
{
  return scale(x);
}

transform scale(real x, real y)
{
  return xscale(x)*yscale(y);
}

transform slant(real s)
{
  return slant(s);
}

transform rotate(real angle, pair z=0)
{
  return rotatearound(z,radians(angle));
}

transform reflect(pair a, pair b)
{
  return reflectabout(a,b);
}


// Pair operations

pair :pairZero()
{
  return zero;
}

pair :realRealToPair(real x, real y)
{
  return pair(x,y);
}

pair :pairNegate(pair z)
{
  return -z;
}

real xpart:pairXPart(pair z)
{
  return z.getx();
}

real ypart:pairYPart(pair z)
{
  return z.gety();
}

real length(pair z)
{
  return z.length();
}

real abs(pair z)
{
  return z.length();
}

pair sqrt(explicit pair z)
{
  return Sqrt(z);
}

// Return the angle of z in radians.
real angle(pair z, bool warn=true)
{
  if(!warn && z.getx() == 0.0 && z.gety() == 0.0) return 0.0;
  return z.angle();
}

// Return the angle of z in degrees in the interval [0,360).
real degrees(pair z, bool warn=true)
{
  if(!warn && z.getx() == 0.0 && z.gety() == 0.0) return 0.0;
  return principalBranch(degrees(z.angle()));
}

// Convert degrees to radians.
real radians(real degrees)
{
  return radians(degrees);
}

// Convert radians to degrees.
real degrees(real radians) 
{
  return degrees(radians);
}

// Convert radians to degrees in [0,360).
real Degrees(real radians) 
{
  return principalBranch(degrees(radians));
}

real Sin(real deg)
{
  return sin(radians(deg));
}

real Cos(real deg)
{
  return cos(radians(deg));
}

real Tan(real deg)
{
  return tan(radians(deg));
}

real aSin(real x)
{
  return degrees(asin(x));
}

real aCos(real x)
{
  return degrees(acos(x));
}

real aTan(real x)
{
  return degrees(atan(x));
}

pair unit(pair z)
{
  return unit(z);
}

pair dir(real degrees)
{
  return expi(radians(degrees));
}

pair dir(explicit pair z)
{
  return unit(z);
}

pair expi(real angle)
{
  return expi(angle);
}

pair exp(explicit pair z) 
{ 
  return exp(z);
}

pair log(explicit pair z) 
{ 
  return pair(log(z.length()),z.angle());
}

pair sin(explicit pair z) 
{ 
  return sin(z);
}

pair cos(explicit pair z) 
{ 
  return pair(cos(z.getx())*cosh(z.gety()),-sin(z.getx())*sinh(z.gety())); 
}

pair conj(pair z)
{
  return conj(z);
}

pair realmult(pair z, pair w) 
{
  return pair (z.getx()*w.getx(),z.gety()*w.gety());
}

triple realmult(triple u, triple v) 
{
  return triple (u.getx()*v.getx(),u.gety()*v.gety(),u.getz()*v.getz());
}

// To avoid confusion, a dot product requires explicit pair arguments.
real dot(explicit pair z, explicit pair w)
{
  return dot(z,w);
}


// Triple operations

triple :tripleZero()
{
  static triple zero;
  return zero;
}

triple :realRealRealToTriple(real x, real y, real z)
{
  return triple(x,y,z);
}

real xpart:tripleXPart(triple v)
{
  return v.getx();
}

real ypart:tripleYPart(triple v)
{
  return v.gety();
}

real zpart:tripleZPart(triple v)
{
  return v.getz();
}

triple Operator *(real x, triple v)
{
  return x*v;
}

triple Operator *(triple v, real x)
{
  return v*x;
}

triple /(triple v, real x)
{
  return v/x;
}

real length(triple v)
{
  return v.length();
}

real abs(triple v)
{
  return v.length();
}

real polar(triple v, bool warn=true) 
{
  if(!warn && v.getx() == 0.0 && v.gety() == 0.0 && v.getz() == 0.0) return 0.0;
  return v.polar();
}

real azimuth(triple v, bool warn=true) 
{
  if(!warn && v.getx() == 0.0 && v.gety() == 0.0) return 0.0;
  return v.azimuth();
}

real colatitude(triple v, bool warn=true) 
{
  if(!warn && v.getx() == 0.0 && v.gety() == 0.0 && v.getz() == 0.0) return 0.0;
  return degrees(v.polar());
}

real latitude(triple v, bool warn=true) 
{
  if(!warn && v.getx() == 0.0 && v.gety() == 0.0 && v.getz() == 0.0) return 0.0;
  return 90.0-degrees(v.polar());
}

// Return the longitude of v in [0,360).
real longitude(triple v, bool warn=true)
{
  if(!warn && v.getx() == 0.0 && v.gety() == 0.0) return 0.0;
  return principalBranch(degrees(v.azimuth()));
}

triple unit(triple v) 
{
  return unit(v);
}

real dot(triple u, triple v) 
{
  return dot(u,v);
}

triple cross(triple u, triple v) 
{
  return cross(u,v);
}

triple dir(explicit triple z)
{
  return unit(z);
}

triple expi(real polar, real azimuth)
{
  return expi(polar,azimuth);
}

triple dir(real colatitude, real longitude)
{
  return expi(radians(colatitude),radians(longitude));
}


// System routines

void atupdate(callable *f)
{
  processData().atUpdateFunction=f;
}

callable *atupdate()
{
  return processData().atUpdateFunction;
}

void atexit(callable *f)
{
  processData().atExitFunction=f;
}

callable *atexit()
{
  return processData().atExitFunction;
}

void atbreakpoint(callableBp *f)
{
  processData().atBreakpointFunction=f;
}

void breakpoint(runnable *s=NULL)
{
  breakpoint(Stack,s);
}

string locatefile(string file)
{
  return locateFile(file);
}

void stop(string file, Int line, runnable *s=NULL)
{
  file=locateFile(file);
  clear(file,line);
  cout << "setting breakpoint at " << file << ": " << line << endl;
  bplist.push_back(bpinfo(file,line,s));
}

void breakpoints()
{
  for(mem::list<bpinfo>::iterator p=bplist.begin(); p != bplist.end(); ++p)
    cout << p->f.name() << ": " << p->f.line() << endl;
}

void clear(string file, Int line)
{
  file=locateFile(file);
  clear(file,line,true);
}

void clear()
{
  bplist.clear();
}

void warn(string s)
{
  Warn(s);
}

void nowarn(string s)
{
  noWarn(s);
}

void warning(string s, string t, bool position=false)
{
  if(settings::warn(s)) {
    em.warning(position ? getPos() : nullPos,s);
    em << t;
  }
}

// Strip directory from string
string stripdirectory(string *s)
{
  return stripDir(*s);
}

// Strip directory from string
string stripfile(string *s)
{
  return stripFile(*s);
}

// Strip file extension from string
string stripextension(string *s)
{
  return stripExt(*s);
}

// Call ImageMagick convert.
Int convert(string args=emptystring, string file=emptystring,
            string format=emptystring)
{
  string name=convertname(file,format);
  mem::vector<string> cmd;
  cmd.push_back(getSetting<string>("convert"));
  push_split(cmd,args);
  cmd.push_back(name);
  bool quiet=verbose <= 1;
  Int ret=System(cmd,quiet ? 1 : 0,true,"convert",
                 "your ImageMagick convert utility");
  
  if(ret == 0 && verbose > 0)
    cout << "Wrote " << ((file.empty()) ? name : file) << endl;
  
  return ret;
}

// Call ImageMagick animate.
Int animate(string args=emptystring, string file=emptystring,
            string format=emptystring)
{
#ifndef __CYGWIN__
  string name=convertname(file,format,false);
  if(view()) {
    mem::vector<string> cmd;
    cmd.push_back(getSetting<string>("animate"));
    push_split(cmd,args);
    cmd.push_back(name);
    return System(cmd,0,false,"animate","your animated GIF viewer");
  }
#endif  
  return 0;
}

// Delete file named s.
Int delete(string *s) 
{
  checkLocal(*s);
  Int rc=unlink(s->c_str());
  if(rc == 0 && verbose > 0) 
    cout << "Deleted " << *s << endl;
  return rc;
}

// Rename file "from" to file "to".
Int rename(string *from, string *to) 
{
  checkLocal(*from);
  checkLocal(*to);
  Int rc=rename(from->c_str(),to->c_str());
  if(rc == 0 && verbose > 0) 
    cout << "Renamed " << *from << " to " << *to << endl;
  return rc;
}


// File operations

bool ==(file *a, file *b)
{
  return a == b;
}

bool !=(file *a, file *b)
{
  return a != b;
}

file* :nullFile()
{
  return &camp::nullfile;
}

file* input(string name, bool check=true, string comment=commentchar)
{
  char c=comment.empty() ? (char) 0 : comment[0];
  file *f=new ifile(name,c,check);
  f->open();
  return f;
}

file* output(string name, bool update=false, string comment=commentchar)
{
  file *f;
  if(update) {
    char c=comment.empty() ? (char) 0 : comment[0];
    f=new iofile(name,c);
  } else f=new ofile(name);
  f->open();
  if(update) f->seek(0,false);
  return f;
}

file* xinput(string name, bool check=true)
{
#ifdef HAVE_RPC_RPC_H
  file *f=new ixfile(name,check);
  f->open();
  return f;
#else  
  ostringstream buf;
  buf << name << ": XDR read support not enabled";
  error(buf);
  unused(&check); // Suppress unused variable warning
#endif
}

file* xoutput(string name, bool update=false)
{
#ifdef HAVE_RPC_RPC_H
  file *f;
  if(update)
    f=new ioxfile(name);
  else f=new oxfile(name);
  f->open();
  if(update) f->seek(0,false);
  return f;
#else  
  ostringstream buf;
  buf << name << ": XDR write support not enabled";
  error(buf);
  unused(&update); // Suppress unused variable warning
#endif
}

file* binput(string name, bool check=true)
{
  file *f=new ibfile(name,check);
  f->open();
  return f;
}

file* boutput(string name, bool update=false)
{
  file *f;
  if(update) f=new iobfile(name);
  else f=new obfile(name);
  f->open();
  if(update) f->seek(0,false);
  return f;
}

bool eof(file *f)
{
  return f->eof();
}

bool eol(file *f)
{
  return f->eol();
}

bool error(file *f)
{
  return f->error();
}

void clear(file *f)
{
  f->clear();
}

void close(file *f)
{
  f->close();
}

Int precision(file *f=NULL, Int digits=0) 
{
  if(f == 0) f=&camp::Stdout;
  return f->precision(digits);
}

void flush(file *f) 
{
  f->flush();
}

string getc(file *f)
{
  char c=0;
  if(f->isOpen()) f->read(c);
  static char str[1];
  str[0]=c;
  return string(str);
}

Int tell(file *f)
{
  return f->tell();
}

void seek(file *f, Int pos)
{
  f->seek(pos,pos >= 0);
}

void seekeof(file *f)
{
  f->seek(0,false);
}

string :namePart(file f)
{
  return f.filename();
}

string :modePart(file f)
{
  return f.FileMode();
}

// Set file dimensions
file* :dimensionSetHelper(Int nx=-1, Int ny=-1, Int nz=-1, file *f)
{
  f->dimension(nx,ny,nz);
  return f;
}

callable* :dimensionSet(file *f)
{
  return new thunk(new bfunc(dimensionSetHelper),f);
}

array * :dimensionPart(file f)
{
  array *a=new array(3);
  (*a)[0]=f.Nx();
  (*a)[1]=f.Ny();
  (*a)[2]=f.Nz();
  return a;
}

// Set file f to read arrays in line-at-a-time mode
file* :lineSetHelper(bool b=true, file *f)
{
  f->LineMode(b);
  return f;
}

callable* :lineSet(file *f)
{
  return new thunk(new bfunc(lineSetHelper),f);
}

bool :linePart(file f)
{
  return f.LineMode();
}

// Set file to read comma-separated values
file* :csvSetHelper(bool b=true, file *f)
{
  f->CSVMode(b);
  return f;
}

callable* :csvSet(file *f)
{
  return new thunk(new bfunc(csvSetHelper),f);
}

bool :csvPart(file f)
{
  return f.CSVMode();
}

// Set file to read whitespace-separated values
file* :wordSetHelper(bool b=true, file *f)
{
  f->WordMode(b);
  return f;
}

callable* :wordSet(file *f)
{
  return new thunk(new bfunc(wordSetHelper),f);
}

bool :wordPart(file f)
{
  return f.WordMode();
}

// Set file to read/write single precision real XDR values.
file* :singlerealSetHelper(bool b=true, file *f)
{
  f->SingleReal(b);
  return f;
}

callable* :singlerealSet(file *f)
{
  return new thunk(new bfunc(singlerealSetHelper),f);
}

bool :singlerealPart(file f)
{
  return f.SingleReal();
}

// Set file to read/write single precision int XDR values.
file* :singleintSetHelper(bool b=true, file *f)
{
  f->SingleInt(b);
  return f;
}

callable* :singleintSet(file *f)
{
  return new thunk(new bfunc(singleintSetHelper),f);
}

bool :singleintPart(file f)
{
  return f.SingleInt();
}

// Set file to read/write signed int XDR values.
file* :signedintSetHelper(bool b=true, file *f)
{
  f->SignedInt(b);
  return f;
}

callable* :signedintSet(file *f)
{
  return new thunk(new bfunc(signedintSetHelper),f);
}

bool :signedintPart(file f)
{
  return f.SignedInt();
}

// Set file to read an arrayi (i int sizes followed by an i-dimensional array)
file* :readSetHelper(Int i, file *f)
{
  switch(i) {
    case 1:
      f->dimension(-2);
      break;
      
    case 2:
      f->dimension(-2,-2);
      break;
      
    case 3:
      f->dimension(-2,-2,-2);
      break;
      
    default:
      f->dimension();
  }
  
  return f;
}

callable* :readSet(file *f)
{
  return new thunk(new bfunc(readSetHelper),f);
}
