/***** Autogenerated from runtime.in; changes will be overwritten *****/

/*****
 * runtime.in
 * Tom Prince 2005/4/15
 *
 * Generate the runtime functions used by the vm::stack machine.
 *
 *****/

#include <cfloat>
#include "angle.h"
#include "pair.h"
#include "triple.h"
#include "transform.h"
#include "path.h"
#include "pen.h"
#include "guide.h"
#include "picture.h"
#include "drawpath.h"
#include "drawfill.h"
#include "drawclipbegin.h"
#include "drawclipend.h"
#include "drawlabel.h"
#include "drawverbatim.h"
#include "drawgsave.h"
#include "drawgrestore.h"
#include "drawlayer.h"
#include "drawimage.h"
#include "drawgroup.h"
#include "fileio.h"
#include "genv.h"
#include "builtin.h"
#include "texfile.h"
#include "pipestream.h"
#include "parser.h"
#include "stack.h"
#include "util.h"
#include "mathop.h"
#include "callable.h"
#include "stm.h"
  
#ifdef HAVE_LIBFFTW3
#include "fftw++.h"
#endif
  
using namespace vm;
using namespace camp;
using namespace settings;

namespace vm {
const char *arraymismatch=
  "operation attempted on arrays of different lengths.";
}

namespace run {
using camp::pair;
using mem::string;
using vm::array;
using vm::frame;
using absyntax::runnable;

callable *atExitFunction=NULL;
callable *atDrawFunction=NULL;
  
typedef array boolarray;
typedef array intarray;
typedef array realarray;
typedef array realarray2;
typedef array pairarray;
typedef array triplearray;
typedef array patharray;
typedef array guidearray;
typedef array transformarray;
typedef array penarray;
typedef array penarray2;
typedef array stringarray;
typedef array stringarray2;
}

using vm::array;
using types::function;
using types::primVoid;
using types::primBoolean;
using types::primInt;
using types::primReal;
using types::primPair;
using types::primTriple;
using types::primPen;
using types::primPath;
using types::primGuide;
using types::primPicture;
using types::primString;
using types::primCode;
using types::primFile;
using types::primTransform;
using types::boolArray;
using types::intArray;
using types::realArray;
using types::realArray2;
using types::pairArray;
using types::tripleArray;
using types::pathArray;
using types::guideArray;
using types::transformArray;
using types::penArray;
using types::penArray2;
using types::stringArray;
using types::stringArray2;

namespace loop {
  void doIRunnable(absyntax::runnable *r, bool embedded=false);
  void doITree(absyntax::block *tree, bool embedded=false);
}
  
function *voidFunction()
{
  function *ft = new function(primVoid());
  return ft;
}

const int camp::ColorComponents[]={0,0,1,3,4,0};

namespace run {
  
static inline int Round(double x) 
{
  return int(x+((x >= 0) ? 0.5 : -0.5));
}

inline int sgn(double x) 
{
  return (x > 0.0 ? 1 : (x < 0.0 ? -1 : 0));
}

inline void CheckReallocate(double *& A, size_t n, size_t& old)
{
  if(n > old) {delete A; A=new double[n]; old=n;}
}

inline void CheckReallocate(double *& A, double *& B, size_t n, size_t& old)
{
  if(n > old) {delete A; A=new double[n]; delete B; B=new double[n]; old=n;}
}

void outOfBounds(const char *op, size_t len, int n)
{
  ostringstream buf;
  buf << op << " array of length " << len << " with out-of-bounds index "
      << n;
  error(buf.str().c_str());
}

item& arrayRead(array *a, int n)  
{
  checkArray(a);
  size_t len=a->size();
  bool cyclic=a->cyclic();
  if(cyclic && len > 0) n=imod(n,len);
  else if(n < 0 || n >= (int) len) outOfBounds("reading",len,n);
  return (*a)[(unsigned) n];
}

// Helper function to create deep arrays.
static array* deepArray(int depth, int *dims)
{
  assert(depth > 0);
  
  if (depth == 1) {
    return new array(dims[0]);
  } else {
    int length = dims[0];
    depth--; dims++;

    array *a = new array(length);

    for (int index = 0; index < length; index++) {
      (*a)[index] = deepArray(depth, dims);
    }
    return a;
  }
}
  
array *copyArray(array *a)
{
  checkArray(a);
  size_t size=a->size();
  array *c=new array(size);
  for(size_t i=0; i < size; i++) 
    (*c)[i]=(*a)[i];
  return c;
}

array *copyArray2(array *a)
{
  checkArray(a);
  size_t size=a->size();
  array *c=new array(size);
  for(size_t i=0; i < size; i++) {
    array *ai=read<array*>(a,i);
    checkArray(ai);
    size_t aisize=ai->size();
    array *ci=new array(aisize);
    (*c)[i]=ci;
    for(size_t j=0; j < aisize; j++) 
      (*ci)[j]=(*ai)[j];
  }
  return c;
}

void writestring(stack *s)
{
  callable *suffix=pop<callable *>(s,NULL);
  string S=pop<string>(s);
  vm::item it=pop(s);
  bool defaultfile=isdefault(it);
  camp::file *f=defaultfile ? &camp::Stdout : vm::get<camp::file*>(it);
  if(!f->isOpen()) return;
  if(S != "") f->write(S);
  if(f->text()) {
    if(suffix) {
      s->push(f);
      suffix->call(s);
    } else if(defaultfile) f->writeline();
  }
}

void dividebyzero(size_t i)
{
  std::ostringstream buf;
  if(i > 0) buf << "array element " << i << ": ";
  buf << "Divide by zero";
  error(buf.str().c_str());
}
  
void integeroverflow(size_t i)
{
  std::ostringstream buf;
  if(i > 0) buf << "array element " << i << ": ";
  buf << "Integer overflow";
  error(buf.str().c_str());
}
  
void cleanup()
{
  defaultpen=camp::pen::startupdefaultpen();
  if(!interact::interactive) settings::scrollLines=0;
  
  if(TeXinitialized) {
    camp::TeXpipepreamble.clear();
    camp::TeXpreamble.clear();
    camp::tex.pipeclose();
    TeXinitialized=false;
  }
}

default_t def;
string emptystring;
string commentchar="#";

}

// Autogenerated routines are specified like this (separated by a formfeed):
// type asyname:cname(cparams)
// {
//   C code
// }



namespace run {

// Initializers
void intZero(vm::stack *Stack)
{

  {Stack->push<int>(0); return;}
}

void realZero(vm::stack *Stack)
{

  {Stack->push<double>(0.0); return;}
}

void boolFalse(vm::stack *Stack)
{

  {Stack->push<bool>(false); return;}
}

void pushNullArray(vm::stack *Stack)
{

  {Stack->push<array*>(0); return;}
}

void pushNullRecord(vm::stack *Stack)
{

  {Stack->push<frame*>(0); return;}
}

void pushNullFunction(vm::stack *Stack)
{

  {Stack->push(nullfunc::instance()); return;}
}


// Default operations

// Put the default value token on the stack (in place of an argument when
// making a function call).
void pushDefault(vm::stack *Stack)
{

  {Stack->push(def); return;}
}


// Test if the value on the stack is the default value token.
void isDefault(vm::stack *Stack)
{
  item i = vm::pop(Stack);

  {Stack->push<bool>(isdefault(i)); return;}
}


// Logical operations
// bool !(bool b);
void gen8(vm::stack *Stack)
{
  bool b = vm::pop<bool>(Stack);

  {Stack->push<bool>(!b); return;}
}

// bool ^(bool a, bool b);
void gen9(vm::stack *Stack)
{
  bool b = vm::pop<bool>(Stack);
  bool a = vm::pop<bool>(Stack);

  {Stack->push<bool>(a^b ? true : false); return;}
}

void boolMemEq(vm::stack *Stack)
{
  frame * b = vm::pop<frame *>(Stack);
  frame * a = vm::pop<frame *>(Stack);

  {Stack->push<bool>(a == b); return;}
}

void boolMemNeq(vm::stack *Stack)
{
  frame * b = vm::pop<frame *>(Stack);
  frame * a = vm::pop<frame *>(Stack);

  {Stack->push<bool>(a != b); return;}
}

void boolFuncEq(vm::stack *Stack)
{
  callable * b = vm::pop<callable *>(Stack);
  callable * a = vm::pop<callable *>(Stack);

  {Stack->push<bool>(a->compare(b)); return;}
}

void boolFuncNeq(vm::stack *Stack)
{
  callable * b = vm::pop<callable *>(Stack);
  callable * a = vm::pop<callable *>(Stack);

  {Stack->push<bool>(!(a->compare(b))); return;}
}


// Casts
void pairToGuide(vm::stack *Stack)
{
  pair z = vm::pop<pair>(Stack);

  {Stack->push<guide*>(new pairguide(z)); return;}
}

void pathToGuide(vm::stack *Stack)
{
  path p = vm::pop<path>(Stack);

  {Stack->push<guide*>(new pathguide(p)); return;}
}

void guideToPath(vm::stack *Stack)
{
  guide * g = vm::pop<guide *>(Stack);

  {Stack->push<path>(g->solve()); return;}
}


// Picture operations
void newPicture(vm::stack *Stack)
{

  {Stack->push<picture*>(new picture()); return;}
}

// bool empty(picture *f);
void gen18(vm::stack *Stack)
{
  picture * f = vm::pop<picture *>(Stack);

  {Stack->push<bool>(f->null()); return;}
}

// pair max(picture *f);
void gen19(vm::stack *Stack)
{
  picture * f = vm::pop<picture *>(Stack);

  {Stack->push<pair>(f->bounds().Max()); return;}
}

// pair min(picture *f);
void gen20(vm::stack *Stack)
{
  picture * f = vm::pop<picture *>(Stack);

  {Stack->push<pair>(f->bounds().Min()); return;}
}

// void _label(picture *f, string *s, string *size, double angle, pair position,	    pair align, pair scale, pen p);
void gen21(vm::stack *Stack)
{
  pen p = vm::pop<pen>(Stack);
  pair scale = vm::pop<pair>(Stack);
  pair align = vm::pop<pair>(Stack);
  pair position = vm::pop<pair>(Stack);
  double angle = vm::pop<double>(Stack);
  string * size = vm::pop<string *>(Stack);
  string * s = vm::pop<string *>(Stack);
  picture * f = vm::pop<picture *>(Stack);

  f->append(new drawLabel(*s,*size,angle,position,align,scale,p));
}

// bool labels(picture *f);
void gen22(vm::stack *Stack)
{
  picture * f = vm::pop<picture *>(Stack);

  {Stack->push<bool>(f->havelabels()); return;}
}

// void fill(picture *f, patharray *g, pen p);
void gen23(vm::stack *Stack)
{
  pen p = vm::pop<pen>(Stack);
  patharray * g = vm::pop<patharray *>(Stack);
  picture * f = vm::pop<picture *>(Stack);

  f->append(new drawFill(copyArray(g),p));
}

// void latticeshade(picture *f, patharray *g, pen fillrule, penarray2 *p);
void gen24(vm::stack *Stack)
{
  penarray2 * p = vm::pop<penarray2 *>(Stack);
  pen fillrule = vm::pop<pen>(Stack);
  patharray * g = vm::pop<patharray *>(Stack);
  picture * f = vm::pop<picture *>(Stack);

  f->append(new drawLatticeShade(copyArray(g),fillrule,copyArray(p)));
}

// void axialshade(picture *f, patharray *g, pen pena, pair a, pen penb, pair b);
void gen25(vm::stack *Stack)
{
  pair b = vm::pop<pair>(Stack);
  pen penb = vm::pop<pen>(Stack);
  pair a = vm::pop<pair>(Stack);
  pen pena = vm::pop<pen>(Stack);
  patharray * g = vm::pop<patharray *>(Stack);
  picture * f = vm::pop<picture *>(Stack);

  f->append(new drawAxialShade(copyArray(g),pena,a,penb,b));
}

// void radialshade(picture *f, patharray *g, pen pena, pair a, double ra,		 pen penb, pair b, double rb);
void gen26(vm::stack *Stack)
{
  double rb = vm::pop<double>(Stack);
  pair b = vm::pop<pair>(Stack);
  pen penb = vm::pop<pen>(Stack);
  double ra = vm::pop<double>(Stack);
  pair a = vm::pop<pair>(Stack);
  pen pena = vm::pop<pen>(Stack);
  patharray * g = vm::pop<patharray *>(Stack);
  picture * f = vm::pop<picture *>(Stack);

  f->append(new drawRadialShade(copyArray(g),pena,a,ra,penb,b,rb));
}

// void gouraudshade(picture *f, patharray *g, pen fillrule, penarray *p,		  pairarray *z, intarray *edges);
void gen27(vm::stack *Stack)
{
  intarray * edges = vm::pop<intarray *>(Stack);
  pairarray * z = vm::pop<pairarray *>(Stack);
  penarray * p = vm::pop<penarray *>(Stack);
  pen fillrule = vm::pop<pen>(Stack);
  patharray * g = vm::pop<patharray *>(Stack);
  picture * f = vm::pop<picture *>(Stack);

  checkArrays(p,z);
  checkArrays(z,edges);
  f->append(new drawGouraudShade(copyArray(g),fillrule,copyArray(p),
				 copyArray(z),copyArray(edges)));
}

// Clip a picture to a superpath using the given fill rule.
// Subsequent additions to the picture will not be affected by the clipping.
// void clip(picture *f, patharray *g, pen p);
void gen28(vm::stack *Stack)
{
  pen p = vm::pop<pen>(Stack);
  patharray * g = vm::pop<patharray *>(Stack);
  picture * f = vm::pop<picture *>(Stack);

  f->enclose(new drawClipBegin(copyArray(g),p),new drawClipEnd());
}

// void beginclip(picture *f, patharray *g, pen p);
void gen29(vm::stack *Stack)
{
  pen p = vm::pop<pen>(Stack);
  patharray * g = vm::pop<patharray *>(Stack);
  picture * f = vm::pop<picture *>(Stack);

  f->append(new drawClipBegin(copyArray(g),p,false));
}

// void postscript(picture *f, string s);
void gen30(vm::stack *Stack)
{
  string s = vm::pop<string>(Stack);
  picture * f = vm::pop<picture *>(Stack);

  f->append(new drawVerbatim(PostScript,s));
}

// void tex(picture *f, string s);
void gen31(vm::stack *Stack)
{
  string s = vm::pop<string>(Stack);
  picture * f = vm::pop<picture *>(Stack);

  f->append(new drawVerbatim(TeX,s));
}

// void texpreamble(string s);
void gen32(vm::stack *Stack)
{
  string s = vm::pop<string>(Stack);

  string t=s+"\n";
  camp::TeXpipepreamble.push_back(t);
  camp::TeXpreamble.push_back(t);
}

// void layer(picture *f);
void gen33(vm::stack *Stack)
{
  picture * f = vm::pop<picture *>(Stack);

  f->append(new drawLayer());
}

// void image(picture *f, realarray2 *data, penarray *palette, 	   pair initial, pair final);
void gen34(vm::stack *Stack)
{
  pair final = vm::pop<pair>(Stack);
  pair initial = vm::pop<pair>(Stack);
  penarray * palette = vm::pop<penarray *>(Stack);
  realarray2 * data = vm::pop<realarray2 *>(Stack);
  picture * f = vm::pop<picture *>(Stack);

  f->append(new drawImage(copyArray2(data),copyArray(palette),
			  matrix(initial,final)));
}

// void shipout(string prefix=emptystring, picture *f, picture *preamble=NULL,	     string format=emptystring, bool wait=0, bool quiet=0,	     transformarray *GUItransform, boolarray *GUIdelete);
void gen35(vm::stack *Stack)
{
  boolarray * GUIdelete = vm::pop<boolarray *>(Stack);
  transformarray * GUItransform = vm::pop<transformarray *>(Stack);
  bool quiet = vm::pop<bool>(Stack,0);
  bool wait = vm::pop<bool>(Stack,0);
  string format = vm::pop<string>(Stack,emptystring);
  picture * preamble = vm::pop<picture *>(Stack,NULL);
  picture * f = vm::pop<picture *>(Stack);
  string prefix = vm::pop<string>(Stack,emptystring);

  if(prefix.empty()) prefix=outname;
  
  size_t size=GUItransform && GUIdelete ?
    checkArrays(GUItransform,GUIdelete) : 0;
 
  if(settings::deconstruct || size) {
    picture *result=new picture;
    unsigned level=0;
    unsigned i=0;
    nodelist::iterator p;
    for(p = f->nodes.begin(); p != f->nodes.end(); ++p) {
      bool Delete;
      transform t;
      if(i < size) {
	t=*(read<transform*>(GUItransform,i));
	Delete=read<bool>(GUIdelete,i);
      } else {
	t=identity();
	Delete=false;
      }
      picture *group=new picture;
// Ignore unclosed begingroups but not spurious endgroups.
      const char *nobegin="endgroup without matching begingroup";
      assert(*p);
      if((*p)->endgroup()) error(nobegin);
      if((*p)->begingroup()) {
	++level;
	while(p != f->nodes.end() && level) {
	  drawElement *e=t.isIdentity() ? *p : (*p)->transformed(t);
	  group->append(e);
	  ++p;
	  if(p == f->nodes.end()) break;
	  assert(*p);
	  if((*p)->begingroup()) ++level;
	  if((*p)->endgroup()) if(level) --level;
	  else error(nobegin);
	}
      }
      if(p == f->nodes.end()) break;
      assert(*p);
      drawElement *e=t.isIdentity() ? *p : (*p)->transformed(t);
      group->append(e);
      if(!group->empty()) {
	if(settings::deconstruct) {
	  ostringstream buf;
	  buf << prefix << "_" << i;
	  group->shipout(preamble,buf.str(),"tgif",false,true,Delete);
	}
	++i;
      }
      if(size && !Delete) result->add(*group);
    }
    if(size) f=result;
  }

  f->shipout(preamble,prefix,format,wait,quiet);
}


// Pen operations
void newPen(vm::stack *Stack)
{

  {Stack->push<pen>(pen()); return;}
}

// bool ==(pen a, pen b);
void gen37(vm::stack *Stack)
{
  pen b = vm::pop<pen>(Stack);
  pen a = vm::pop<pen>(Stack);

  {Stack->push<bool>(a == b); return;}
}

// bool !=(pen a, pen b);
void gen38(vm::stack *Stack)
{
  pen b = vm::pop<pen>(Stack);
  pen a = vm::pop<pen>(Stack);

  {Stack->push<bool>(a != b); return;}
}

// pen +(pen a, pen b);
void gen39(vm::stack *Stack)
{
  pen b = vm::pop<pen>(Stack);
  pen a = vm::pop<pen>(Stack);

  {Stack->push<pen>(a+b); return;}
}

// pen *(double a, pen b);
void gen40(vm::stack *Stack)
{
  pen b = vm::pop<pen>(Stack);
  double a = vm::pop<double>(Stack);

  {Stack->push<pen>(a*b); return;}
}

// pen *(pen a, double b);
void gen41(vm::stack *Stack)
{
  double b = vm::pop<double>(Stack);
  pen a = vm::pop<pen>(Stack);

  {Stack->push<pen>(b*a); return;}
}

// pair max(pen p);
void gen42(vm::stack *Stack)
{
  pen p = vm::pop<pen>(Stack);

  {Stack->push<pair>(p.bounds().Max()); return;}
}

// pair min(pen p);
void gen43(vm::stack *Stack)
{
  pen p = vm::pop<pen>(Stack);

  {Stack->push<pair>(p.bounds().Min()); return;}
}

// Reset the meaning of pen default attributes.
// void resetdefaultpen();
void gen44(vm::stack *Stack)
{

  defaultpen=camp::pen::startupdefaultpen();
}

// void defaultpen(pen p);
void gen45(vm::stack *Stack)
{
  pen p = vm::pop<pen>(Stack);

  defaultpen=pen(resolvepen,p);
}

// pen defaultpen();
void gen46(vm::stack *Stack)
{

  {Stack->push<pen>(defaultpen); return;}
}

// pen invisible();
void gen47(vm::stack *Stack)
{

  {Stack->push<pen>(pen(invisiblepen)); return;}
}

// pen gray(pen p);
void gen48(vm::stack *Stack)
{
  pen p = vm::pop<pen>(Stack);

  if(p.rgb()) p.rgbtogrey();
  else if (p.cmyk()) p.cmyktogrey();
  {Stack->push<pen>(p); return;}
}

// pen rgb(pen p);
void gen49(vm::stack *Stack)
{
  pen p = vm::pop<pen>(Stack);

  if(p.grayscale()) p.greytorgb();
  else if (p.cmyk()) p.cmyktorgb();
  {Stack->push<pen>(p); return;}
}

// pen rgb(double r, double g, double b);
void gen50(vm::stack *Stack)
{
  double b = vm::pop<double>(Stack);
  double g = vm::pop<double>(Stack);
  double r = vm::pop<double>(Stack);

  {Stack->push<pen>(pen(r,g,b)); return;}
}

// pen cmyk(double c, double m, double y, double k);
void gen51(vm::stack *Stack)
{
  double k = vm::pop<double>(Stack);
  double y = vm::pop<double>(Stack);
  double m = vm::pop<double>(Stack);
  double c = vm::pop<double>(Stack);

  {Stack->push<pen>(pen(c,m,y,k)); return;}  
}

// pen gray(double gray);
void gen52(vm::stack *Stack)
{
  double gray = vm::pop<double>(Stack);

  {Stack->push<pen>(pen(gray)); return;}
}

// realarray* colors(pen p);
void gen53(vm::stack *Stack)
{
  pen p = vm::pop<pen>(Stack);
  
  int n=ColorComponents[p.colorspace()];
  array *a=new array(n);
  
  switch(n) {
  case 0:
    break;
  case 1: 
    (*a)[0]=p.gray(); 
    break;
  case 3:
    (*a)[0]=p.red(); 
    (*a)[1]=p.green(); 
    (*a)[2]=p.blue(); 
    break;
  case 4:
    (*a)[0]=p.cyan();
    (*a)[1]=p.magenta(); 
    (*a)[2]=p.yellow(); 
    (*a)[3]=p.black();
    break;
  default:
    break;
  }
  {Stack->push<realarray*>(a); return;}
}

// pen pattern(string *s);
void gen54(vm::stack *Stack)
{
  string * s = vm::pop<string *>(Stack);

  {Stack->push<pen>(pen(setpattern,*s)); return;}
}

// string pattern(pen p);
void gen55(vm::stack *Stack)
{
  pen p = vm::pop<pen>(Stack);

  {Stack->push<string>(p.fillpattern()); return;}  
}

// pen fillrule(int n);
void gen56(vm::stack *Stack)
{
  int n = vm::pop<int>(Stack);

  {Stack->push<pen>(pen(n >= 0 && n < nFill ? (FillRule) n : DEFFILL)); return;}
}

// int fillrule(pen p);
void gen57(vm::stack *Stack)
{
  pen p = vm::pop<pen>(Stack);

  {Stack->push<int>(p.Fillrule()); return;}  
}

// pen linetype(string *s, bool scale);
void gen58(vm::stack *Stack)
{
  bool scale = vm::pop<bool>(Stack);
  string * s = vm::pop<string *>(Stack);

  {Stack->push<pen>(pen(LineType(*s,scale))); return;} 
}

// string linetype(pen p);
void gen59(vm::stack *Stack)
{
  pen p = vm::pop<pen>(Stack);

  {Stack->push<string>(p.stroke()); return;}  
}

// pen linecap(int n);
void gen60(vm::stack *Stack)
{
  int n = vm::pop<int>(Stack);

  {Stack->push<pen>(pen(setlinecap,n >= 0 && n < nCap ? n : DEFCAP)); return;}
}

// int linecap(pen p);
void gen61(vm::stack *Stack)
{
  pen p = vm::pop<pen>(Stack);

  {Stack->push<int>(p.cap()); return;}  
}

// pen linejoin(int n);
void gen62(vm::stack *Stack)
{
  int n = vm::pop<int>(Stack);

  {Stack->push<pen>(pen(setlinejoin,n >= 0 && n < nJoin ? n : DEFJOIN)); return;}
}

// int linejoin(pen p);
void gen63(vm::stack *Stack)
{
  pen p = vm::pop<pen>(Stack);

  {Stack->push<int>(p.join()); return;}  
}

// pen linewidth(double x);
void gen64(vm::stack *Stack)
{
  double x = vm::pop<double>(Stack);

  {Stack->push<pen>(pen(setlinewidth,x >= 0.0 ? x : DEFWIDTH)); return;}
}

// double linewidth(pen p);
void gen65(vm::stack *Stack)
{
  pen p = vm::pop<pen>(Stack);

  {Stack->push<double>(p.width()); return;}  
}

// pen fontcommand(string *s);
void gen66(vm::stack *Stack)
{
  string * s = vm::pop<string *>(Stack);

  {Stack->push<pen>(pen(setfont,*s)); return;}
}

// string font(pen p);
void gen67(vm::stack *Stack)
{
  pen p = vm::pop<pen>(Stack);

  {Stack->push<string>(p.Font()); return;}
}

// pen fontsize(double size, double skip);
void gen68(vm::stack *Stack)
{
  double skip = vm::pop<double>(Stack);
  double size = vm::pop<double>(Stack);

  {Stack->push<pen>(pen(setfontsize,size > 0.0 ? size : 0.0,
	     skip > 0.0 ? skip : 0.0)); return;}
}

// double fontsize(pen p);
void gen69(vm::stack *Stack)
{
  pen p = vm::pop<pen>(Stack);

  {Stack->push<double>(p.size()); return;}
}

// double lineskip(pen p);
void gen70(vm::stack *Stack)
{
  pen p = vm::pop<pen>(Stack);

  {Stack->push<double>(p.Lineskip()); return;}  
}

// pen overwrite(int n);
void gen71(vm::stack *Stack)
{
  int n = vm::pop<int>(Stack);

  {Stack->push<pen>(pen(setoverwrite,n >= 0 && n < nOverwrite ? (overwrite_t) n :
	     DEFWRITE)); return;}
}

// int overwrite(pen p);
void gen72(vm::stack *Stack)
{
  pen p = vm::pop<pen>(Stack);

  {Stack->push<int>(p.Overwrite()); return;}  
}

// pen basealign(int n);
void gen73(vm::stack *Stack)
{
  int n = vm::pop<int>(Stack);

  {Stack->push<pen>(pen(n >= 0 && n < nBaseLine ? (BaseLine) n : DEFBASE)); return;}
}

// int basealign(pen p);
void gen74(vm::stack *Stack)
{
  pen p = vm::pop<pen>(Stack);

  {Stack->push<int>(p.Baseline()); return;}
}

// path nib(pen p);
void gen75(vm::stack *Stack)
{
  pen p = vm::pop<pen>(Stack);

  static path nullpath;
  path *g=p.Path();
  {Stack->push<path>(g ? *g : nullpath); return;}
}

// pen makepen(path p);
void gen76(vm::stack *Stack)
{
  path p = vm::pop<path>(Stack);

  {Stack->push<pen>(p.size() == 0 ? pen() : pen(new path(p))); return;}
}

// void _draw(picture *f, path g, pen p);
void gen77(vm::stack *Stack)
{
  pen p = vm::pop<pen>(Stack);
  path g = vm::pop<path>(Stack);
  picture * f = vm::pop<picture *>(Stack);

  f->append(new drawPath(g,p));
}

// void endclip(picture *f);
void gen78(vm::stack *Stack)
{
  picture * f = vm::pop<picture *>(Stack);

  f->append(new drawClipEnd(false));
}

// void gsave(picture *f);
void gen79(vm::stack *Stack)
{
  picture * f = vm::pop<picture *>(Stack);

  f->append(new drawGsave());
}

// void grestore(picture *f);
void gen80(vm::stack *Stack)
{
  picture * f = vm::pop<picture *>(Stack);

  f->append(new drawGrestore());
}

// void begingroup(picture *f);
void gen81(vm::stack *Stack)
{
  picture * f = vm::pop<picture *>(Stack);

  f->append(new drawBegin());
}

// void endgroup(picture *f);
void gen82(vm::stack *Stack)
{
  picture * f = vm::pop<picture *>(Stack);

  f->append(new drawEnd());
}

// void add(picture *dest, picture *src);
void gen83(vm::stack *Stack)
{
  picture * src = vm::pop<picture *>(Stack);
  picture * dest = vm::pop<picture *>(Stack);

  dest->add(*src);
}

// void prepend(picture *dest, picture *src);
void gen84(vm::stack *Stack)
{
  picture * src = vm::pop<picture *>(Stack);
  picture * dest = vm::pop<picture *>(Stack);

  dest->prepend(*src);
}

// string fileprefix();
void gen85(vm::stack *Stack)
{

  {Stack->push<string>(outname); return;}
}


// Interactive mode
// bool interact();
void gen86(vm::stack *Stack)
{

  {Stack->push<bool>(interact::interactive); return;}
}

// void uptodate(bool b);
void gen87(vm::stack *Stack)
{
  bool b = vm::pop<bool>(Stack);

  interact::uptodate=b;
}

// bool uptodate();
void gen88(vm::stack *Stack)
{

  {Stack->push<bool>(interact::uptodate); return;}
}


// System commands
// int system(string *str);
void gen89(vm::stack *Stack)
{
  string * str = vm::pop<string *>(Stack);

  if(safe) error("system() call disabled; override with option -unsafe");
  else {Stack->push<int>(System(str->c_str())); return;}
}

// void abort(string *msg);
void gen90(vm::stack *Stack)
{
  string * msg = vm::pop<string *>(Stack);

  error(msg->c_str());
}

// void _eval(string *s, bool embedded=false);
void gen91(vm::stack *Stack)
{
  bool embedded = vm::pop<bool>(Stack,false);
  string * s = vm::pop<string *>(Stack);

  loop::doITree(parser::parseString(*s),embedded);
}

// void _eval(runnable *s, bool embedded=false);
void gen92(vm::stack *Stack)
{
  bool embedded = vm::pop<bool>(Stack,false);
  runnable * s = vm::pop<runnable *>(Stack);

  loop::doIRunnable(s,embedded);
}

void exitFunction(vm::stack *Stack)
{

  if(atExitFunction && !nullfunc::instance()->compare(atExitFunction)) {
    atExitFunction->call(Stack);
    atExitFunction=NULL;
  }
  cleanup();
}

void updateFunction(vm::stack *Stack)
{

  if(atExitFunction && !nullfunc::instance()->compare(atExitFunction))
    atExitFunction->call(Stack);
}

// void gui(double x);
void gen95(vm::stack *Stack)
{
  double x = vm::pop<double>(Stack);
 
  settings::deconstruct=(x > 0 ? x : 0);
}

// bool deconstruct();
void gen96(vm::stack *Stack)
{
 
  {Stack->push<bool>(settings::deconstruct); return;}
}

// void readGUI();
void gen97(vm::stack *Stack)
{

  static bool first=true;
  string name=buildname(outname,"gui");
  std::ifstream exists(name.c_str());
  if(exists) {
    if((settings::clearGUI && !interact::interactive) ||
       (first && interact::interactive)) unlink(name.c_str());
    else {
      if (!settings::ignoreGUI) {
	string cmd=string("include \"")+name+string("\";");
	absyntax::block *ast = parser::parseString(cmd);
	loop::doITree(ast,true);
      }
    }
  }
  first=false;
}

// Wrapper for the stack::load() method.
void loadModule(vm::stack *Stack)
{
  string * index = vm::pop<string *>(Stack);

  Stack->load(*index);
}

// string cd(string *d);
void gen99(vm::stack *Stack)
{
  string * d = vm::pop<string *>(Stack);

  int rc=setPath(d->c_str());
  if(rc != 0) {
    ostringstream buf;
    buf << "Cannot change to directory '" << *d << "'";
    error(buf.str().c_str());
  }
  char *p=getPath();
  if(p && interact::interactive) 
    cout << p << endl;
  {Stack->push<string>(p); return;}
}

// void scroll(int n);
void gen100(vm::stack *Stack)
{
  int n = vm::pop<int>(Stack);

  settings::scrollLines=n;
}


// Path operations
void nullPath(vm::stack *Stack)
{

  static path nullpath;
  {Stack->push<path>(nullpath); return;}
}

// pair point(path p, int n);
void gen102(vm::stack *Stack)
{
  int n = vm::pop<int>(Stack);
  path p = vm::pop<path>(Stack);

  {Stack->push<pair>(p.point(n)); return;}
}

// pair point(path p, double t);
void gen103(vm::stack *Stack)
{
  double t = vm::pop<double>(Stack);
  path p = vm::pop<path>(Stack);

  {Stack->push<pair>(p.point(t)); return;}
}

// pair precontrol(path p, int n);
void gen104(vm::stack *Stack)
{
  int n = vm::pop<int>(Stack);
  path p = vm::pop<path>(Stack);

  {Stack->push<pair>(p.precontrol(n)); return;}
}

// pair precontrol(path p, double t);
void gen105(vm::stack *Stack)
{
  double t = vm::pop<double>(Stack);
  path p = vm::pop<path>(Stack);

  {Stack->push<pair>(p.precontrol(t)); return;}
}

// pair postcontrol(path p, int n);
void gen106(vm::stack *Stack)
{
  int n = vm::pop<int>(Stack);
  path p = vm::pop<path>(Stack);

  {Stack->push<pair>(p.postcontrol(n)); return;}
}

// pair postcontrol(path p, double t);
void gen107(vm::stack *Stack)
{
  double t = vm::pop<double>(Stack);
  path p = vm::pop<path>(Stack);

  {Stack->push<pair>(p.postcontrol(t)); return;}
}

// pair dir(path p, int n);
void gen108(vm::stack *Stack)
{
  int n = vm::pop<int>(Stack);
  path p = vm::pop<path>(Stack);

  {Stack->push<pair>(unit(p.direction(n))); return;}
}

// pair dir(path p, double t);
void gen109(vm::stack *Stack)
{
  double t = vm::pop<double>(Stack);
  path p = vm::pop<path>(Stack);

  {Stack->push<pair>(unit(p.direction(t))); return;}
}

// path reverse(path p);
void gen110(vm::stack *Stack)
{
  path p = vm::pop<path>(Stack);

  {Stack->push<path>(p.reverse()); return;}
}

// path subpath(path p, int b, int e);
void gen111(vm::stack *Stack)
{
  int e = vm::pop<int>(Stack);
  int b = vm::pop<int>(Stack);
  path p = vm::pop<path>(Stack);

  {Stack->push<path>(p.subpath(b,e)); return;}
}

// path subpath(path p, double b, double e);
void gen112(vm::stack *Stack)
{
  double e = vm::pop<double>(Stack);
  double b = vm::pop<double>(Stack);
  path p = vm::pop<path>(Stack);

  {Stack->push<path>(p.subpath(b,e)); return;}
}

// int length(path p);
void gen113(vm::stack *Stack)
{
  path p = vm::pop<path>(Stack);

  {Stack->push<int>(p.length()); return;}
}

// bool cyclic(path p);
void gen114(vm::stack *Stack)
{
  path p = vm::pop<path>(Stack);

  {Stack->push<bool>(p.cyclic()); return;}
}

// bool straight(path p, int i);
void gen115(vm::stack *Stack)
{
  int i = vm::pop<int>(Stack);
  path p = vm::pop<path>(Stack);

  {Stack->push<bool>(p.straight(i)); return;}
}

// double arclength(path p);
void gen116(vm::stack *Stack)
{
  path p = vm::pop<path>(Stack);

  {Stack->push<double>(p.arclength()); return;}
}

// double arctime(path p, double dval);
void gen117(vm::stack *Stack)
{
  double dval = vm::pop<double>(Stack);
  path p = vm::pop<path>(Stack);

  {Stack->push<double>(p.arctime(dval)); return;}
}

// double dirtime(path p, pair z);
void gen118(vm::stack *Stack)
{
  pair z = vm::pop<pair>(Stack);
  path p = vm::pop<path>(Stack);

  {Stack->push<double>(p.directiontime(z)); return;}
}

// pair intersect(path x, path y, double fuzz);
void gen119(vm::stack *Stack)
{
  double fuzz = vm::pop<double>(Stack);
  path y = vm::pop<path>(Stack);
  path x = vm::pop<path>(Stack);

  {Stack->push<pair>(intersectiontime(x,y,fuzz)); return;}
}

// int size(path p);
void gen120(vm::stack *Stack)
{
  path p = vm::pop<path>(Stack);

  {Stack->push<int>(p.size()); return;}
}

// path &(path p, path q);
void gen121(vm::stack *Stack)
{
  path q = vm::pop<path>(Stack);
  path p = vm::pop<path>(Stack);

  {Stack->push<path>(camp::concat(p,q)); return;}
}

// pair min(path p);
void gen122(vm::stack *Stack)
{
  path p = vm::pop<path>(Stack);

  {Stack->push<pair>(p.bounds().Min()); return;}
}

// pair max(path p);
void gen123(vm::stack *Stack)
{
  path p = vm::pop<path>(Stack);

  {Stack->push<pair>(p.bounds().Max()); return;}
}

// double relativedistance(double theta, double phi, double t, bool atleast);
void gen124(vm::stack *Stack)
{
  bool atleast = vm::pop<bool>(Stack);
  double t = vm::pop<double>(Stack);
  double phi = vm::pop<double>(Stack);
  double theta = vm::pop<double>(Stack);

  {Stack->push<double>(camp::velocity(theta,phi,tension(t,atleast))); return;}
}

// bool inside(patharray *g, pair z, pen p);
void gen125(vm::stack *Stack)
{
  pen p = vm::pop<pen>(Stack);
  pair z = vm::pop<pair>(Stack);
  patharray * g = vm::pop<patharray *>(Stack);

  array *G=copyArray(g);
  size_t size=G->size();
  int count=0;
  for(size_t i=0; i < size; i++) 
    count += read<path *>(G,i)->inside(z);
  {Stack->push<bool>(p.inside(count)); return;}
}


// Guide operations
void nullGuide(vm::stack *Stack)
{

  {Stack->push<guide*>(new pathguide(path())); return;}
}

void dotsGuide(vm::stack *Stack)
{
  guidearray * a = vm::pop<guidearray *>(Stack);

  guidevector v;
  size_t size=a->size();
  for (size_t i=0; i < size; ++i)
    v.push_back(a->read<guide*>(i));

  {Stack->push<guide*>(new multiguide(v)); return;}
}

void dashesGuide(vm::stack *Stack)
{
  guidearray * a = vm::pop<guidearray *>(Stack);

  static camp::curlSpec curly;
  static specguide curlout(&curly, camp::OUT);
  static specguide curlin(&curly, camp::IN);

  size_t n=a->size();

  // a--b is equivalent to a{curl 1}..{curl 1}b
  guidevector v;
  if (n > 0)
    v.push_back(a->read<guide*>(0));

  if (n==1) {
    v.push_back(&curlout);
    v.push_back(&curlin);
  }
  else
    for (size_t i=1; i<n; ++i) {
      v.push_back(&curlout);
      v.push_back(&curlin);
      v.push_back(a->read<guide*>(i));
    }

  {Stack->push<guide*>(new multiguide(v)); return;}
}

// guide* operator cycle();
void gen129(vm::stack *Stack)
{

  {Stack->push<guide*>((guide*) new cycletokguide()); return;}
}

// guide* operator spec(pair z, int p);
void gen130(vm::stack *Stack)
{
  int p = vm::pop<int>(Stack);
  pair z = vm::pop<pair>(Stack);

  camp::side d=(camp::side) p;
  camp::dirSpec *sp=new camp::dirSpec(angle(z));

  {Stack->push<guide*>(new specguide(sp,d)); return;}
}

// guide* operator curl(double gamma, int p);
void gen131(vm::stack *Stack)
{
  int p = vm::pop<int>(Stack);
  double gamma = vm::pop<double>(Stack);

  camp::side d=(camp::side) p;
  camp::curlSpec *sp=new camp::curlSpec(gamma);

  {Stack->push<guide*>(new specguide(sp,d)); return;}
}

// guide* operator tension(double tout, double tin, bool atleast);
void gen132(vm::stack *Stack)
{
  bool atleast = vm::pop<bool>(Stack);
  double tin = vm::pop<double>(Stack);
  double tout = vm::pop<double>(Stack);

  tension Tin(tin, atleast),
         Tout(tout, atleast);

  {Stack->push<guide*>(new tensionguide(tout, tin)); return;}
}

// guide* operator controls(pair zout, pair zin);
void gen133(vm::stack *Stack)
{
  pair zin = vm::pop<pair>(Stack);
  pair zout = vm::pop<pair>(Stack);

  {Stack->push<guide*>(new controlguide(zout, zin)); return;}
}


// String operations
void emptyString(vm::stack *Stack)
{

  {Stack->push<string>(emptystring); return;}
}

// int length(string *s);
void gen135(vm::stack *Stack)
{
  string * s = vm::pop<string *>(Stack);

  {Stack->push<int>((int) s->length()); return;}
}

// int find(string *s, string *sub, int pos);
void gen136(vm::stack *Stack)
{
  int pos = vm::pop<int>(Stack);
  string * sub = vm::pop<string *>(Stack);
  string * s = vm::pop<string *>(Stack);

  {Stack->push<int>((int) s->find(*sub,pos)); return;}
}

// int rfind(string *s, string *sub, int pos);
void gen137(vm::stack *Stack)
{
  int pos = vm::pop<int>(Stack);
  string * sub = vm::pop<string *>(Stack);
  string * s = vm::pop<string *>(Stack);

  {Stack->push<int>((int) s->rfind(*sub,pos)); return;}
}

// string reverse(string s);
void gen138(vm::stack *Stack)
{
  string s = vm::pop<string>(Stack);

  reverse(s.begin(),s.end());
  {Stack->push<string>(s); return;}
}

// string insert(string s, int pos, string *sub);
void gen139(vm::stack *Stack)
{
  string * sub = vm::pop<string *>(Stack);
  int pos = vm::pop<int>(Stack);
  string s = vm::pop<string>(Stack);

  if ((size_t)pos < s.length())
    {Stack->push<string>(s.insert(pos,*sub)); return;}
  {Stack->push<string>(s); return;}
}

// string substr(string* s, int pos, int n);
void gen140(vm::stack *Stack)
{
  int n = vm::pop<int>(Stack);
  int pos = vm::pop<int>(Stack);
  string* s = vm::pop<string*>(Stack);

  if ((size_t)pos < s->length())
    {Stack->push<string>(s->substr(pos,n)); return;}
  {Stack->push<string>(emptystring); return;}
}

// string erase(string s, int pos, int n);
void gen141(vm::stack *Stack)
{
  int n = vm::pop<int>(Stack);
  int pos = vm::pop<int>(Stack);
  string s = vm::pop<string>(Stack);

  if ((size_t)pos < s.length())
    {Stack->push<string>(s.erase(pos,n)); return;}
  {Stack->push<string>(s); return;} 
}

// returns a string constructed by translating all occurrences of the string
// from in an array of string pairs {from,to} to the string to in string s.
// string replace(string *S, stringarray2 *translate);
void gen142(vm::stack *Stack)
{
  stringarray2 * translate = vm::pop<stringarray2 *>(Stack);
  string * S = vm::pop<string *>(Stack);

  checkArray(translate);
  size_t size=translate->size();
  for(size_t i=0; i < size; i++) {
    array *a=read<array*>(translate,i);
    checkArray(a);
  }
  const char *p=S->c_str();
  ostringstream buf;
  while(*p) {
    for(size_t i=0; i < size;) {
      array *a=read<array*>(translate,i);
      string* from=read<string*>(a,0);
      size_t len=from->length();
      if(strncmp(p,from->c_str(),len) != 0) {i++; continue;}
      buf << read<string>(a,1);
      p += len;
      if(*p == 0) {Stack->push<string>(buf.str()); return;}
      i=0;
    }
    buf << *(p++);
  }
  {Stack->push<string>(buf.str()); return;}
}

// string format(string *format, int x);
void gen143(vm::stack *Stack)
{
  int x = vm::pop<int>(Stack);
  string * format = vm::pop<string *>(Stack);

  int size=snprintf(NULL,0,format->c_str(),x)+1;
  if(size < 1) size=255; // Workaround for non-C99 compliant systems.
  char *buf=new char[size];
  snprintf(buf,size,format->c_str(),x);
  string s=string(buf);
  delete [] buf;
  {Stack->push<string>(s); return;}
}

// string format(string *format, double x);
void gen144(vm::stack *Stack)
{
  double x = vm::pop<double>(Stack);
  string * format = vm::pop<string *>(Stack);

  ostringstream out;
  
  const char *phantom="\\phantom{+}";
  const char *p0=format->c_str();
  
  const char *p=p0;
  const char *start=NULL;
  while (*p != 0) {
    if(*p == '%') {
      p++;
      if(*p != '%') {start=p-1; break;}
    }
    out << *(p++);
  }
  
  if(!start) {Stack->push<string>(out.str()); return;}
  
  // Allow at most 1 argument  
  while (*p != 0) {
    if(*p == '*' || *p == '$') {Stack->push<string>(out.str()); return;}
    if(isupper(*p) || islower(*p)) {p++; break;}
    p++;
  }
  
  const char *tail=p;
  string f=format->substr(start-p0,tail-start);
  int size=snprintf(NULL,0,f.c_str(),x)+1;
  if(size < 1) size=255; // Workaround for non-C99 compliant systems.
  char *buf=new char[size];
  snprintf(buf,size,f.c_str(),x);

  bool trailingzero=f.find("#") < string::npos;
  bool plus=f.find("+") < string::npos;
  bool space=f.find(" ") < string::npos;
  
  char *q=buf; // beginning of formatted number

  if(*q == ' ') {
    out << phantom;
    q++;
  }
  
  // Remove any spurious sign
  if(*q == '-' || *q == '+') {
    p=q+1;
    bool zero=true;
    while(*p != 0) {
      if(!isdigit(*p) && *p != '.') break;
      if(isdigit(*p) && *p != '0') {zero=false; break;}
      p++;
    }
    if(zero) {
      q++;
      if(plus || space) out << phantom;
    }
  }
  
  const char *r=p=q;
  bool dp=false;
  while(*r != 0 && (isdigit(*r) || *r == '.' || *r == '+' || *r == '-')) {
    if(*r == '.') dp=true;
    r++;
  }
  if(dp) { // Remove trailing zeros and/or decimal point
    r--;
    unsigned int n=0;
    while(r > q && *r == '0') {r--; n++;}
    if(*r == '.') {r--; n++;}
    while(q <= r) out << *(q++);
    if(!trailingzero) q += n;
  }
  
  bool zero=(r == p && *r == '0') && !trailingzero;
  
  // Translate "E+/E-/e+/e-" exponential notation to TeX
  while(*q != 0) {
    if((*q == 'E' || *q == 'e') && (*(q+1) == '+' || *(q+1) == '-')) {
      if(!zero) out << "\\!\\times\\!10^{";
      bool plus=(*(q+1) == '+');
      q++;
      if(plus) q++;
      if(*q == '-') out << *(q++);
      while(*q == '0' && (zero || isdigit(*(q+1)))) q++;
      while(isdigit(*q)) out << *(q++);
      if(!zero) {
	if(plus) out << phantom;
	out << "}";
      }
      break;
    }
    out << *(q++);
  }
  
  while(*tail != 0) 
    out << *(tail++);
  
  delete [] buf;
  {Stack->push<string>(out.str()); return;}
}

// string time(string *format);
void gen145(vm::stack *Stack)
{
  string * format = vm::pop<string *>(Stack);

  static const size_t n=256;
  static char Time[n]="";
#ifdef HAVE_STRFTIME
  const time_t bintime=time(NULL);
  strftime(Time,n,format->c_str(),localtime(&bintime));
#endif  
  {Stack->push<string>(Time); return;}
}


// Math
// double ^(double x, int y);
void gen146(vm::stack *Stack)
{
  int y = vm::pop<int>(Stack);
  double x = vm::pop<double>(Stack);

  {Stack->push<double>(pow(x,y)); return;}
}

// int quotient(int x, int y);
void gen147(vm::stack *Stack)
{
  int y = vm::pop<int>(Stack);
  int x = vm::pop<int>(Stack);
 
  if (y == 0) dividebyzero();
// Implementation-independent definition of integer division: round down
  {Stack->push<int>((x-portableMod(x,y))/y); return;}
}

// int abs(int x);
void gen148(vm::stack *Stack)
{
  int x = vm::pop<int>(Stack);
 
  {Stack->push<int>(abs(x)); return;}
}

// int sgn(double x);
void gen149(vm::stack *Stack)
{
  double x = vm::pop<double>(Stack);
 
  {Stack->push<int>(sgn(x)); return;}
}

// int rand();
void gen150(vm::stack *Stack)
{
 
  {Stack->push<int>(rand()); return;}
}

// void srand(int seed);
void gen151(vm::stack *Stack)
{
  int seed = vm::pop<int>(Stack);
 
  srand(seed);
}

// void srand(int seed);
void gen152(vm::stack *Stack)
{
  int seed = vm::pop<int>(Stack);
 
  srand(seed);
}

// int ceil(double x);
void gen153(vm::stack *Stack)
{
  double x = vm::pop<double>(Stack);
 
  double y=ceil(x);
  checkint(y,0);
  {Stack->push<int>((int) y); return;}
}

// int floor(double x);
void gen154(vm::stack *Stack)
{
  double x = vm::pop<double>(Stack);
 
  double y=floor(x);
  checkint(y,0);
  {Stack->push<int>((int) y); return;}
}

// int round(double x);
void gen155(vm::stack *Stack)
{
  double x = vm::pop<double>(Stack);
 
  if(fabs(x) >= INT_MAX+0.5) integeroverflow(0);
  {Stack->push<int>(Round(x)); return;}
}

// int Ceil(double x);
void gen156(vm::stack *Stack)
{
  double x = vm::pop<double>(Stack);
 
  {Stack->push<int>(Ceil(x)); return;}
}

// int Floor(double x);
void gen157(vm::stack *Stack)
{
  double x = vm::pop<double>(Stack);
 
  {Stack->push<int>(Floor(x)); return;}
}

// int Round(double x);
void gen158(vm::stack *Stack)
{
  double x = vm::pop<double>(Stack);
 
  {Stack->push<int>(Round(intcap(x))); return;}
}

// double fmod(double x, double y);
void gen159(vm::stack *Stack)
{
  double y = vm::pop<double>(Stack);
  double x = vm::pop<double>(Stack);

  if (y == 0.0) dividebyzero();
  {Stack->push<double>(fmod(x,y)); return;}
}

// double atan2(double y, double x);
void gen160(vm::stack *Stack)
{
  double x = vm::pop<double>(Stack);
  double y = vm::pop<double>(Stack);
 
  {Stack->push<double>(atan2(y,x)); return;}
}

// double hypot(double x, double y);
void gen161(vm::stack *Stack)
{
  double y = vm::pop<double>(Stack);
  double x = vm::pop<double>(Stack);
 
  {Stack->push<double>(hypot(x,y)); return;}
}

// double remainder(double x, double y);
void gen162(vm::stack *Stack)
{
  double y = vm::pop<double>(Stack);
  double x = vm::pop<double>(Stack);
 
  {Stack->push<double>(remainder(x,y)); return;}
}

// double J(int n, double x);
void gen163(vm::stack *Stack)
{
  double x = vm::pop<double>(Stack);
  int n = vm::pop<int>(Stack);

  {Stack->push<double>(jn(n,x)); return;}
}

// double Y(int n, double x);
void gen164(vm::stack *Stack)
{
  double x = vm::pop<double>(Stack);
  int n = vm::pop<int>(Stack);

  {Stack->push<double>(yn(n,x)); return;}
}

// double erf(double x);
void gen165(vm::stack *Stack)
{
  double x = vm::pop<double>(Stack);

  {Stack->push<double>(erf(x)); return;}
}

// double erfc(double x);
void gen166(vm::stack *Stack)
{
  double x = vm::pop<double>(Stack);

  {Stack->push<double>(erfc(x)); return;}
}

// double gamma(double x);
void gen167(vm::stack *Stack)
{
  double x = vm::pop<double>(Stack);

#ifdef HAVE_TGAMMA
  {Stack->push<double>(tgamma(x)); return;}
#else
 double lg = lgamma(x);
 {Stack->push<double>(signgam*exp(lg)); return;}
#endif
}

// realarray* quadraticroots(double a, double b, double c);
void gen168(vm::stack *Stack)
{
  double c = vm::pop<double>(Stack);
  double b = vm::pop<double>(Stack);
  double a = vm::pop<double>(Stack);

  quadraticroots q(a,b,c);
  array *roots=new array(q.roots);
  if(q.roots >= 1) (*roots)[0]=q.t1;
  if(q.roots == 2) (*roots)[1]=q.t2;
  {Stack->push<realarray*>(roots); return;}
}

// realarray* cubicroots(double a, double b, double c, double d);
void gen169(vm::stack *Stack)
{
  double d = vm::pop<double>(Stack);
  double c = vm::pop<double>(Stack);
  double b = vm::pop<double>(Stack);
  double a = vm::pop<double>(Stack);

  cubicroots q(a,b,c,d);
  array *roots=new array(q.roots);
  if(q.roots >= 1) (*roots)[0]=q.t1;
  if(q.roots >= 2) (*roots)[1]=q.t2;
  if(q.roots == 3) (*roots)[2]=q.t3;
  {Stack->push<realarray*>(roots); return;}
}

  
// Transforms
// bool ==(transform a, transform b);
void gen170(vm::stack *Stack)
{
  transform b = vm::pop<transform>(Stack);
  transform a = vm::pop<transform>(Stack);

  {Stack->push<bool>(a == b); return;}
}

// bool !=(transform a, transform b);
void gen171(vm::stack *Stack)
{
  transform b = vm::pop<transform>(Stack);
  transform a = vm::pop<transform>(Stack);

  {Stack->push<bool>(a != b); return;}
}

// transform *(transform a, transform b);
void gen172(vm::stack *Stack)
{
  transform b = vm::pop<transform>(Stack);
  transform a = vm::pop<transform>(Stack);

  {Stack->push<transform>(a*b); return;}
}

// pair *(transform t, pair z);
void gen173(vm::stack *Stack)
{
  pair z = vm::pop<pair>(Stack);
  transform t = vm::pop<transform>(Stack);

  {Stack->push<pair>(t*z); return;}
}

// path *(transform t, path g);
void gen174(vm::stack *Stack)
{
  path g = vm::pop<path>(Stack);
  transform t = vm::pop<transform>(Stack);

  {Stack->push<path>(transformed(t,g)); return;}
}

// pen *(transform t, pen p);
void gen175(vm::stack *Stack)
{
  pen p = vm::pop<pen>(Stack);
  transform t = vm::pop<transform>(Stack);

  {Stack->push<pen>(transformed(&t,p)); return;}
}

// picture* *(transform t, picture *f);
void gen176(vm::stack *Stack)
{
  picture * f = vm::pop<picture *>(Stack);
  transform t = vm::pop<transform>(Stack);

  {Stack->push<picture*>(transformed(t,f)); return;}
}

// transform ^(transform t, int n);
void gen177(vm::stack *Stack)
{
  int n = vm::pop<int>(Stack);
  transform t = vm::pop<transform>(Stack);

  transform T;
  if(n < 0) {
    n=-n;
    t=inverse(t);
  }
  for(int i=0; i < n; i++) T=T*t;
  {Stack->push<transform>(T); return;}
}

void transformXPart(vm::stack *Stack)
{
  transform t = vm::pop<transform>(Stack);

  {Stack->push<double>(t.getx()); return;}
}

void transformYPart(vm::stack *Stack)
{
  transform t = vm::pop<transform>(Stack);

  {Stack->push<double>(t.gety()); return;}
}

void transformXXPart(vm::stack *Stack)
{
  transform t = vm::pop<transform>(Stack);

  {Stack->push<double>(t.getxx()); return;}
}

void transformXYPart(vm::stack *Stack)
{
  transform t = vm::pop<transform>(Stack);

  {Stack->push<double>(t.getxy()); return;}
}

void transformYXPart(vm::stack *Stack)
{
  transform t = vm::pop<transform>(Stack);

  {Stack->push<double>(t.getyx()); return;}
}

void transformYYPart(vm::stack *Stack)
{
  transform t = vm::pop<transform>(Stack);

  {Stack->push<double>(t.getyy()); return;}
}

void real6ToTransform(vm::stack *Stack)
{
  double yy = vm::pop<double>(Stack);
  double yx = vm::pop<double>(Stack);
  double xy = vm::pop<double>(Stack);
  double xx = vm::pop<double>(Stack);
  double y = vm::pop<double>(Stack);
  double x = vm::pop<double>(Stack);

  {Stack->push<transform>(transform(x,y,xx,xy,yx,yy)); return;}
}

// transform identity();
void transformIdentity(vm::stack *Stack)
{

  {Stack->push<transform>(identity()); return;}
}

// transform inverse(transform t);
void gen186(vm::stack *Stack)
{
  transform t = vm::pop<transform>(Stack);

  {Stack->push<transform>(inverse(t)); return;}
}

// transform shift(pair z);
void gen187(vm::stack *Stack)
{
  pair z = vm::pop<pair>(Stack);

  {Stack->push<transform>(shift(z)); return;}
}

// transform xscale(double x);
void gen188(vm::stack *Stack)
{
  double x = vm::pop<double>(Stack);

  {Stack->push<transform>(xscale(x)); return;}
}

// transform yscale(double y);
void gen189(vm::stack *Stack)
{
  double y = vm::pop<double>(Stack);

  {Stack->push<transform>(yscale(y)); return;}
}

// transform scale(double x);
void gen190(vm::stack *Stack)
{
  double x = vm::pop<double>(Stack);

  {Stack->push<transform>(scale(x)); return;}
}

// transform slant(double s);
void gen191(vm::stack *Stack)
{
  double s = vm::pop<double>(Stack);

  {Stack->push<transform>(slant(s)); return;}
}

// transform rotate(double angle, pair z=0);
void gen192(vm::stack *Stack)
{
  pair z = vm::pop<pair>(Stack,0);
  double angle = vm::pop<double>(Stack);

  {Stack->push<transform>(rotatearound(z,radians(angle))); return;}
}

// transform reflect(pair a, pair b);
void gen193(vm::stack *Stack)
{
  pair b = vm::pop<pair>(Stack);
  pair a = vm::pop<pair>(Stack);

  {Stack->push<transform>(reflectabout(a,b)); return;}
}


// Pair operations
void pairZero(vm::stack *Stack)
{

  static pair zero;
  {Stack->push<pair>(zero); return;}
}

void realRealToPair(vm::stack *Stack)
{
  double y = vm::pop<double>(Stack);
  double x = vm::pop<double>(Stack);

  {Stack->push<pair>(pair(x,y)); return;}
}

void pairNegate(vm::stack *Stack)
{
  pair z = vm::pop<pair>(Stack);

  {Stack->push<pair>(-z); return;}
}

void pairXPart(vm::stack *Stack)
{
  pair z = vm::pop<pair>(Stack);

  {Stack->push<double>(z.getx()); return;}
}

void pairYPart(vm::stack *Stack)
{
  pair z = vm::pop<pair>(Stack);

  {Stack->push<double>(z.gety()); return;}
}

// double length(pair z);
void gen199(vm::stack *Stack)
{
  pair z = vm::pop<pair>(Stack);

  {Stack->push<double>(z.length()); return;}
}

// double abs(pair z);
void gen200(vm::stack *Stack)
{
  pair z = vm::pop<pair>(Stack);

  {Stack->push<double>(z.length()); return;}
}

// double angle(pair z);
void gen201(vm::stack *Stack)
{
  pair z = vm::pop<pair>(Stack);

  {Stack->push<double>(z.angle()); return;}
}

// Return the angle of z in degrees in the interval [0,360).
// double degrees(pair z);
void gen202(vm::stack *Stack)
{
  pair z = vm::pop<pair>(Stack);

  double deg=degrees(z.angle());
  if(deg < 0) deg += 360; 
  {Stack->push<double>(deg); return;}
}

// pair unit(pair z);
void gen203(vm::stack *Stack)
{
  pair z = vm::pop<pair>(Stack);

  {Stack->push<pair>(unit(z)); return;}
}

// pair dir(double theta);
void gen204(vm::stack *Stack)
{
  double theta = vm::pop<double>(Stack);

  {Stack->push<pair>(expi(radians(theta))); return;}
}

// pair expi(double theta);
void gen205(vm::stack *Stack)
{
  double theta = vm::pop<double>(Stack);

  {Stack->push<pair>(expi(theta)); return;}
}

// pair conj(pair z);
void gen206(vm::stack *Stack)
{
  pair z = vm::pop<pair>(Stack);

  {Stack->push<pair>(conj(z)); return;}
}

// double _dot(pair u, pair v);
void gen207(vm::stack *Stack)
{
  pair v = vm::pop<pair>(Stack);
  pair u = vm::pop<pair>(Stack);

  {Stack->push<double>(u.getx()*v.getx()+u.gety()*v.gety()); return;}
}


// Triple operations
void tripleZero(vm::stack *Stack)
{

  static triple zero;
  {Stack->push<triple>(zero); return;}
}

void realRealRealToTriple(vm::stack *Stack)
{
  double z = vm::pop<double>(Stack);
  double y = vm::pop<double>(Stack);
  double x = vm::pop<double>(Stack);

  {Stack->push<triple>(triple(x,y,z)); return;}
}

void tripleXPart(vm::stack *Stack)
{
  triple v = vm::pop<triple>(Stack);

  {Stack->push<double>(v.getx()); return;}
}

void tripleYPart(vm::stack *Stack)
{
  triple v = vm::pop<triple>(Stack);

  {Stack->push<double>(v.gety()); return;}
}

void tripleZPart(vm::stack *Stack)
{
  triple v = vm::pop<triple>(Stack);

  {Stack->push<double>(v.getz()); return;}
}

// triple *(double x, triple v);
void gen213(vm::stack *Stack)
{
  triple v = vm::pop<triple>(Stack);
  double x = vm::pop<double>(Stack);

  {Stack->push<triple>(x*v); return;}
}

// triple *(triple v, double x);
void gen214(vm::stack *Stack)
{
  double x = vm::pop<double>(Stack);
  triple v = vm::pop<triple>(Stack);

  {Stack->push<triple>(x*v); return;}
}

// triple /(triple v, double x);
void gen215(vm::stack *Stack)
{
  double x = vm::pop<double>(Stack);
  triple v = vm::pop<triple>(Stack);

  {Stack->push<triple>(v/x); return;}
}

// double length(triple v);
void gen216(vm::stack *Stack)
{
  triple v = vm::pop<triple>(Stack);

  {Stack->push<double>(v.length()); return;}
}

// double abs(triple v);
void gen217(vm::stack *Stack)
{
  triple v = vm::pop<triple>(Stack);

  {Stack->push<double>(v.length()); return;}
}

// double polar(triple v);
void gen218(vm::stack *Stack)
{
  triple v = vm::pop<triple>(Stack);

  {Stack->push<double>(v.polar()); return;}
}

// double azimuth(triple v);
void gen219(vm::stack *Stack)
{
  triple v = vm::pop<triple>(Stack);

  {Stack->push<double>(v.azimuth()); return;}
}

// double colatitude(triple v);
void gen220(vm::stack *Stack)
{
  triple v = vm::pop<triple>(Stack);

  {Stack->push<double>(degrees(v.polar())); return;}
}

// double latitude(triple v);
void gen221(vm::stack *Stack)
{
  triple v = vm::pop<triple>(Stack);

  {Stack->push<double>(90.0-degrees(v.polar())); return;}
}

// double longitude(triple v);
void gen222(vm::stack *Stack)
{
  triple v = vm::pop<triple>(Stack);

  double deg=degrees(v.azimuth());
  if(deg < 0) deg += 360; 
  {Stack->push<double>(deg); return;}
}

// triple unit(triple v);
void gen223(vm::stack *Stack)
{
  triple v = vm::pop<triple>(Stack);

  {Stack->push<triple>(unit(v)); return;}
}

// double dot(triple u, triple v);
void gen224(vm::stack *Stack)
{
  triple v = vm::pop<triple>(Stack);
  triple u = vm::pop<triple>(Stack);

  {Stack->push<double>(u.getx()*v.getx()+u.gety()*v.gety()+u.getz()*v.getz()); return;}
}

// triple cross(triple u, triple v);
void gen225(vm::stack *Stack)
{
  triple v = vm::pop<triple>(Stack);
  triple u = vm::pop<triple>(Stack);

  {Stack->push<triple>(triple(u.gety()*v.getz()-u.getz()*v.gety(),
		u.getz()*v.getx()-u.getx()*v.getz(),
		u.getx()*v.gety()-v.getx()*u.gety())); return;}
}

// triple expi(double theta, double phi);
void gen226(vm::stack *Stack)
{
  double phi = vm::pop<double>(Stack);
  double theta = vm::pop<double>(Stack);

  {Stack->push<triple>(expi(theta,phi)); return;}
  double sintheta=sin(theta);
  {Stack->push<triple>(triple(sintheta*cos(phi),sintheta*sin(phi),cos(theta))); return;}
}

// triple dir(double theta, double phi);
void gen227(vm::stack *Stack)
{
  double phi = vm::pop<double>(Stack);
  double theta = vm::pop<double>(Stack);

  {Stack->push<triple>(expi(radians(theta),radians(phi))); return;}
}

// double cubiclength(triple z0, triple z0p, triple z1m, triple z1, double goal);
void gen228(vm::stack *Stack)
{
  double goal = vm::pop<double>(Stack);
  triple z1 = vm::pop<triple>(Stack);
  triple z1m = vm::pop<triple>(Stack);
  triple z0p = vm::pop<triple>(Stack);
  triple z0 = vm::pop<triple>(Stack);

  {Stack->push<double>(cubiclength(z0,z0p,z1m,z1,goal)); return;}
}

// pair intersect(triplearray* pre1, triplearray* point1, triplearray* post1,               triplearray* pre2, triplearray* point2, triplearray* post2,	       double fuzz);
void gen229(vm::stack *Stack)
{
  double fuzz = vm::pop<double>(Stack);
  triplearray* post2 = vm::pop<triplearray*>(Stack);
  triplearray* point2 = vm::pop<triplearray*>(Stack);
  triplearray* pre2 = vm::pop<triplearray*>(Stack);
  triplearray* post1 = vm::pop<triplearray*>(Stack);
  triplearray* point1 = vm::pop<triplearray*>(Stack);
  triplearray* pre1 = vm::pop<triplearray*>(Stack);

  size_t size1=pre1->size();
  size_t size2=pre2->size();
      
  if(point1->size() != size1 || post1->size() != size1 ||
     point2->size() != size2 || post2->size() != size2)
    error("Mismatched array lengths");
  
  int single1=(size1 == 1);
  int single2=(size2 == 1);
  
  size_t Size1=size1+single1;
  size_t Size2=size2+single2;
  
  node *n1=new node[Size1];
  node *n2=new node[Size2];
      
  for(size_t i=0; i < size1; ++i)
    n1[i]=node(read<triple>(pre1,i),read<triple>(point1,i),
	       read<triple>(post1,i));

  for(size_t i=0; i < size2; ++i)
    n2[i]=node(read<triple>(pre2,i),read<triple>(point2,i),
	       read<triple>(post2,i));

  if(single1) n1[1]=n1[0];
  if(single2) n2[1]=n2[0];
  
  {Stack->push<pair>(intersect((int) Size1-1,(int) Size2-1,n1,n2,fuzz)); return;}
}

// double pi();
void gen230(vm::stack *Stack)
{
 
  {Stack->push<double>(PI); return;}
}

// int intMax();
void gen231(vm::stack *Stack)
{
 
  {Stack->push<int>(INT_MAX); return;}
}

// double infinity();
void gen232(vm::stack *Stack)
{
 
  {Stack->push<double>(HUGE_VAL); return;}
}

// double realMax();
void gen233(vm::stack *Stack)
{
 
  {Stack->push<double>(DBL_MAX); return;}
}

// double realMin();
void gen234(vm::stack *Stack)
{
 
  {Stack->push<double>(DBL_MIN); return;}
}

// double realEpsilon();
void gen235(vm::stack *Stack)
{
 
  {Stack->push<double>(DBL_EPSILON); return;}
}

// double randMax();
void gen236(vm::stack *Stack)
{
 
  {Stack->push<double>(RAND_MAX); return;}
}


// System routines
// string VERSION();
void gen237(vm::stack *Stack)
{

  {Stack->push<string>(VERSION); return;}
}

// void quiet(bool v);
void gen238(vm::stack *Stack)
{
  bool v = vm::pop<bool>(Stack);

  settings::view=!v;
}

// void atexit(callable *f);
void gen239(vm::stack *Stack)
{
  callable * f = vm::pop<callable *>(Stack);

  atExitFunction=f;
}

// callable* atexit();
void gen240(vm::stack *Stack)
{

  {Stack->push<callable*>(atExitFunction); return;}
}


// Merge output files  
// int merge(stringarray *files, string *args, string *format, bool keep);
void gen241(vm::stack *Stack)
{
  bool keep = vm::pop<bool>(Stack);
  string * format = vm::pop<string *>(Stack);
  string * args = vm::pop<string *>(Stack);
  stringarray * files = vm::pop<stringarray *>(Stack);

  int ret;
  
  checkArray(files);
  size_t size=files->size();
  
  if(!checkFormatString(*format)) return;
  
  ostringstream cmd,remove;
  cmd << Convert << " "+*args;
  
  for(size_t i=0; i < size; i++) 
    cmd << " " << read<string>(files,i);
  
  string name=buildname(outname,format->c_str());
  cmd << " " << name;
  ret=System(cmd,false,true,"ASYMPTOTE_CONVERT","convert");
  
  if(ret == 0)
    if(settings::verbose > 0) cout << "Wrote " << name << endl;
  
  if(!keep && !settings::keep)
    for(size_t i=0; i < size; i++) 
      unlink(read<string>(files,i).c_str());
    
  if(ret == 0 && settings::view) {
    ostringstream cmd;
    cmd << Animate << " " << name;
    System(cmd,false,false,"ASYMPTOTE_ANIMATE","your animated GIF viewer");
  }
  
  {Stack->push<int>(ret); return;}
}


// Array operations

// Create an empty array.
void emptyArray(vm::stack *Stack)
{

  {Stack->push<array*>(new array(0)); return;}
}

// Create a new array (technically a vector).
// This array will be multidimensional.  First the number of dimensions
// is popped off the stack, followed by each dimension in reverse order.
// The array itself is technically a one dimensional array of one
// dimension arrays and so on.
void newDeepArray(vm::stack *Stack)
{
  int depth = vm::pop<int>(Stack);

  assert(depth > 0);

  int *dims = new int[depth];

  for (int index = depth-1; index >= 0; index--)
    dims[index] = pop<int>(Stack);

  array *a=deepArray(depth, dims);
  delete [] dims;
  {Stack->push<array*>(a); return;}
}

// Creates an array with elements already specified.  First, the number
// of elements is popped off the stack, followed by each element in
// reverse order.
void newInitializedArray(vm::stack *Stack)
{
  int n = vm::pop<int>(Stack);

  assert(n >= 0);

  array *a = new array(n);

  for (int index = n-1; index >= 0; index--)
    (*a)[index] = pop(Stack);

  {Stack->push<array*>(a); return;}
}

// Similar to newInitializedArray, but after the n elements, append another
// array to it.
void newAppendedArray(vm::stack *Stack)
{
  array* tail = vm::pop<array*>(Stack);
  int n = vm::pop<int>(Stack);

  assert(n >= 0);

  array *a = new array(n);

  for (int index = n-1; index >= 0; index--)
    (*a)[index] = pop(Stack);
  
  copy(tail->begin(), tail->end(), back_inserter(*a));

  {Stack->push<array*>(a); return;}
}

// Read an element from an array. Checks for initialization & bounds.
void arrayRead(vm::stack *Stack)
{
  int n = vm::pop<int>(Stack);
  array * a = vm::pop<array *>(Stack);

  item& i=arrayRead(a,n);
  if (i.empty()) {
    ostringstream buf;
    buf << "read uninitialized value from array at index " << n;
    error(buf.str().c_str());
  }
  {Stack->push(i); return;}
}

// Read an element from an array of arrays. Check bounds and initialize
// as necessary.
void arrayArrayRead(vm::stack *Stack)
{
  int n = vm::pop<int>(Stack);
  array * a = vm::pop<array *>(Stack);

  item& i=arrayRead(a,n);
  if (i.empty()) i=new array(0);
  {Stack->push(i); return;}
}

// Write an element to an array.  Increase size if necessary.
void arrayWrite(vm::stack *Stack)
{
  int n = vm::pop<int>(Stack);
  array * a = vm::pop<array *>(Stack);
  item value = vm::pop(Stack);

  checkArray(a);
  size_t len=a->size();
  bool cyclic=a->cyclic();
  if(cyclic && len > 0) n=imod(n,len);
  else {
    if(cyclic) outOfBounds("writing cyclic",len,n);
    if(n < 0) outOfBounds("writing",len,n);
    if(a->size() <= (size_t) n)
      a->resize(n+1);
  }
  (*a)[n] = value;
  {Stack->push(value); return;}
}

// Returns the length of an array.
void arrayLength(vm::stack *Stack)
{
  array * a = vm::pop<array *>(Stack);

  checkArray(a);
  {Stack->push<int>(a->size()); return;}
}

// Return the cyclic flag for an array.
void arrayCyclicFlag(vm::stack *Stack)
{
  array * a = vm::pop<array *>(Stack);

  checkArray(a);
  {Stack->push<bool>(a->cyclic()); return;}
}

// The helper function for the cyclic method that sets the cyclic flag.
void arrayCyclicHelper(vm::stack *Stack)
{
  array * a = vm::pop<array *>(Stack);
  bool b = vm::pop<bool>(Stack);

  checkArray(a);
  a->cyclic(b);
}

// Set the cyclic flag for an array.
void arrayCyclic(vm::stack *Stack)
{
  array * a = vm::pop<array *>(Stack);

  checkArray(a);
  {Stack->push<callable*>(new thunk(new bfunc(arrayCyclicHelper),a)); return;}
}

// The helper function for the push method that does the actual operation.
void arrayPushHelper(vm::stack *Stack)
{
  array * a = vm::pop<array *>(Stack);
  item i = vm::pop(Stack);

  checkArray(a);
  a->push(i);
  {Stack->push(i); return;}
}

// Returns the push method for an array.
void arrayPush(vm::stack *Stack)
{
  array * a = vm::pop<array *>(Stack);

  checkArray(a);
  {Stack->push<callable*>(new thunk(new bfunc(arrayPushHelper),a)); return;}
}

// The helper function for the append method that appends b to a.
void arrayAppendHelper(vm::stack *Stack)
{
  array * a = vm::pop<array *>(Stack);
  array * b = vm::pop<array *>(Stack);

  checkArray(a);
  checkArray(b);
  size_t size=b->size();
  for(size_t i=0; i < size; i++)
    a->push((*b)[i]);
}

// Returns the append method for an array.
void arrayAppend(vm::stack *Stack)
{
  array * a = vm::pop<array *>(Stack);

  checkArray(a);
  {Stack->push<callable*>(new thunk(new bfunc(arrayAppendHelper),a)); return;}
}

// The helper function for the pop method.
void arrayPopHelper(vm::stack *Stack)
{
  array * a = vm::pop<array *>(Stack);

  checkArray(a);
  if(a->size() == 0) 
    error("cannot pop element from empty array");
  {Stack->push(a->pop()); return;}
}

// Returns the pop method for an array.
void arrayPop(vm::stack *Stack)
{
  array * a = vm::pop<array *>(Stack);

  checkArray(a);
  {Stack->push<callable*>(new thunk(new bfunc(arrayPopHelper),a)); return;}
}

void arrayAlias(vm::stack *Stack)
{
  array * b = vm::pop<array *>(Stack);
  array * a = vm::pop<array *>(Stack);

  {Stack->push<bool>(a==b); return;}
}

// Return array formed by indexing array a with elements of integer array b
void arrayIntArray(vm::stack *Stack)
{
  array * b = vm::pop<array *>(Stack);
  array * a = vm::pop<array *>(Stack);

  checkArray(a);
  checkArray(b);
  size_t asize=a->size();
  size_t bsize=b->size();
  array *r=new array(bsize);
  for(size_t i=0; i < bsize; i++) {
    int index=read<int>(b,i);
    if(index < 0) index += (int) asize;
    if(index < 0 || index >= (int) asize)
      error("reading out-of-bounds index from array");
    (*r)[i]=(*a)[index];
  }
  {Stack->push<array*>(r); return;}
}

// Generate the sequence {f_i : i=0,1,...n-1} given a function f and integer n
void arraySequence(vm::stack *Stack)
{
  int n = vm::pop<int>(Stack);
  callable * f = vm::pop<callable *>(Stack);

  if(n < 0) n=0;
  array *a=new array(n);
  for(int i=0; i < n; ++i) {
    Stack->push(i);
    f->call(Stack);
    (*a)[i]=pop(Stack);
  }
  {Stack->push<intarray*>(a); return;}
}

// Return the array {0,1,...n-1}
// intarray* sequence(int n);
void gen262(vm::stack *Stack)
{
  int n = vm::pop<int>(Stack);

  if(n < 0) n=0;
  array *a=new array(n);
  for(int i=0; i < n; ++i) {
    (*a)[i]=i;
  }
  {Stack->push<intarray*>(a); return;}
}

// Apply a function to each element of an array
void arrayFunction(vm::stack *Stack)
{
  array * a = vm::pop<array *>(Stack);
  callable * f = vm::pop<callable *>(Stack);

  checkArray(a);
  size_t size=a->size();
  array *b=new array(size);
  for(size_t i=0; i < size; ++i) {
    Stack->push((*a)[i]);
    f->call(Stack);
    (*b)[i]=pop(Stack);
  }
  {Stack->push<array*>(b); return;}
}

// bool all(boolarray *a);
void gen264(vm::stack *Stack)
{
  boolarray * a = vm::pop<boolarray *>(Stack);

  checkArray(a);
  unsigned int size=(unsigned int) a->size();
  bool c=true;
  for(unsigned i=0; i < size; i++)
    if(!get<bool>((*a)[i])) {c=false; break;}
  {Stack->push<bool>(c); return;}
}

// boolarray* !(boolarray* a);
void gen265(vm::stack *Stack)
{
  boolarray* a = vm::pop<boolarray*>(Stack);

  checkArray(a);
  size_t size=a->size();
  array *c=new array(size);
  for(size_t i=0; i < size; i++)
    (*c)[i]=!read<bool>(a,i);
  {Stack->push<boolarray*>(c); return;}
}

// int sum(boolarray *a);
void gen266(vm::stack *Stack)
{
  boolarray * a = vm::pop<boolarray *>(Stack);

  checkArray(a);
  size_t size=a->size();
  int sum=0;
  for(size_t i=0; i < size; i++)
    sum += read<bool>(a,i) ? 1 : 0;
  {Stack->push<int>(sum); return;}
}

void arrayCopy(vm::stack *Stack)
{
  array * a = vm::pop<array *>(Stack);

  {Stack->push<array*>(copyArray(a)); return;}
}

void arrayConcat(vm::stack *Stack)
{
  array * b = vm::pop<array *>(Stack);
  array * a = vm::pop<array *>(Stack);

  checkArray(a);
  checkArray(b);
  size_t asize=a->size();
  size_t bsize=b->size();
  array *c=new array(asize+bsize);
  for(size_t i=0; i < asize; i++) 
    (*c)[i]=(*a)[i];
  for(size_t i=0; i < bsize; i++, asize++) 
    (*c)[asize]=(*b)[i];
  {Stack->push<array*>(c); return;}
}

void array2Copy(vm::stack *Stack)
{
  array * a = vm::pop<array *>(Stack);

  {Stack->push<array*>(copyArray2(a)); return;}
}

void array2Transpose(vm::stack *Stack)
{
  array * a = vm::pop<array *>(Stack);

  checkArray(a);
  size_t asize=a->size();
  array *c=new array(0);
  for(size_t i=0; i < asize; i++) {
    size_t ip=i+1;
    array *ai=read<array*>(a,i);
    checkArray(ai);
    size_t aisize=ai->size();
    size_t csize=c->size();
    if(csize < aisize) {
      c->resize(aisize);
      for(size_t j=csize; j < aisize; j++) {
	(*c)[j]=new array(ip);
      }
    }
    for(size_t j=0; j < aisize; j++) {
    array *cj=read<array*>(c,j);
    if(cj->size() < ip) cj->resize(ip);
    (*cj)[i]=(*ai)[j];
    }
  }
  {Stack->push<array*>(c); return;}
}

// In a boolean array, find the index of the nth true value or -1 if not found
// If n is negative, search backwards.
// int find(boolarray *a, int n);
void gen271(vm::stack *Stack)
{
  int n = vm::pop<int>(Stack);
  boolarray * a = vm::pop<boolarray *>(Stack);

  checkArray(a);
  int size=(int) a->size();
  int j=-1;
  if(n > 0)
    for(int i=0; i < size; i++)
      if(read<bool>(a,i)) {
	n--; if(n == 0) {j=i; break;}
      }
  if(n < 0)
    for(int i=size-1; i >= 0; i--)
      if(read<bool>(a,i)) {
	n++; if(n == 0) {j=i; break;}
      }
  {Stack->push<int>(j); return;}
}

// construct vector obtained by replacing those elements of b for which the
// corresponding elements of a are false by the corresponding element of c.
void arrayConditional(vm::stack *Stack)
{
  array * c = vm::pop<array *>(Stack);
  array * b = vm::pop<array *>(Stack);
  array * a = vm::pop<array *>(Stack);

  size_t size=a->size();
  array *r=new array(size);
  if(b && c) {
    checkArrays(a,b);
    checkArrays(b,c);
    for(size_t i=0; i < size; i++)
      (*r)[i]=read<bool>(a,i) ? (*b)[i] : (*c)[i];
  } else {
    r->clear();
    if(b) {
      checkArrays(a,b);
      for(size_t i=0; i < size; i++)
        if(read<bool>(a,i)) r->push((*b)[i]);
    } else if(c) {
      checkArrays(a,c);
      for(size_t i=0; i < size; i++)
        if(!read<bool>(a,i)) r->push((*c)[i]);
    }
  }
  {Stack->push<array*>(r); return;}
}

// Solve the problem L\inv f, where f is an n vector and L is the n x n matrix
//
// [ b[0] c[0]           a[0]   ]
// [ a[1] b[1] c[1]             ]
// [      a[2] b[2] c[2]        ]
// [                ...         ]
// [       c[n-1] a[n-1] b[n-1] ]
// realarray* tridiagonal(realarray *a, realarray *b, realarray *c, realarray *f);
void gen273(vm::stack *Stack)
{
  realarray * f = vm::pop<realarray *>(Stack);
  realarray * c = vm::pop<realarray *>(Stack);
  realarray * b = vm::pop<realarray *>(Stack);
  realarray * a = vm::pop<realarray *>(Stack);

  checkArray(f);
  checkArray(c);
  checkArray(b);
  checkArray(a);
  
  size_t n=a->size();
  if(n != b->size() || n != c->size() || n != f->size())
    vm::error(arraymismatch);
  
  array *up=new array(n);
  array& u=*up;

  if(n == 0) {Stack->push<realarray*>(up); return;}
  
  // Special case: Zero Dirichlet boundary conditions
  if(read<double>(a,0) == 0.0 && read<double>(c,n-1) == 0.0) {
    static double *work;
    static size_t size=0;
  
    CheckReallocate(work,n,size);
    
    double temp=1.0/read<double>(b,0);
    u[0]=read<double>(f,0)*temp;
    work[0]=-read<double>(c,0)*temp;
	
    for(size_t i=1; i < n; i++) {
      double temp=1.0/(read<double>(b,i)+read<double>(a,i)*work[i-1]);
      u[i]=(read<double>(f,i)-read<double>(a,i)*read<double>(u,i-1))*temp;
      work[i]=-read<double>(c,i)*temp;
    }

    for(size_t i=n-1; i >= 1; i--)
      u[i-1]=read<double>(u,i-1)+work[i-1]*read<double>(u,i);
    {Stack->push<realarray*>(up); return;}
  }
  
  double binv=read<double>(b,0);
  if(binv == 0.0) dividebyzero();
  binv=1.0/binv;
  
  if(n == 1) {u[0]=read<double>(f,0)*binv; {Stack->push<realarray*>(up); return;}}
  if(n == 2) {
    double factor=(read<double>(b,0)*read<double>(b,1)-
		   read<double>(a,0)*read<double>(c,1));
    if(factor== 0.0) dividebyzero();
    factor=1.0/factor;
    double temp=(read<double>(b,0)*read<double>(f,1)-
	  read<double>(c,1)*read<double>(f,0))*factor;
    u[0]=(read<double>(b,1)*read<double>(f,0)-
	  read<double>(a,0)*read<double>(f,1))*factor;
    u[1]=temp;
    {Stack->push<realarray*>(up); return;}
  }
	
  static double *gamma,*delta;
  static size_t size=0;
  CheckReallocate(gamma,delta,n-2,size);
  
  gamma[0]=read<double>(c,0)*binv;
  delta[0]=read<double>(a,0)*binv;
  u[0]=read<double>(f,0)*binv;
  double beta=read<double>(c,n-1);
  double fn=read<double>(f,n-1)-beta*read<double>(u,0);
  double alpha=read<double>(b,n-1)-beta*delta[0];

  for(size_t i=1; i <= n-3; i++) {
    double alphainv=read<double>(b,i)-read<double>(a,i)*gamma[i-1];
    if(alphainv == 0.0) dividebyzero();
    alphainv=1.0/alphainv;
    beta *= -gamma[i-1];
    gamma[i]=read<double>(c,i)*alphainv;
    u[i]=(read<double>(f,i)-read<double>(a,i)*read<double>(u,i-1))*alphainv;
    fn -= beta*read<double>(u,i);
    delta[i]=-read<double>(a,i)*delta[i-1]*alphainv;
    alpha -= beta*delta[i];
  }
	
  double alphainv=read<double>(b,n-2)-read<double>(a,n-2)*gamma[n-3];
  if(alphainv == 0.0) dividebyzero();
  alphainv=1.0/alphainv;
  u[n-2]=(read<double>(f,n-2)-read<double>(a,n-2)*read<double>(u,n-3))
    *alphainv;
  beta=read<double>(a,n-1)-beta*gamma[n-3];
  double dnm1=(read<double>(c,n-2)-read<double>(a,n-2)*delta[n-3])*alphainv;
  double temp=alpha-beta*dnm1;
  if(temp == 0.0) dividebyzero();
  u[n-1]=temp=(fn-beta*read<double>(u,n-2))/temp;
  u[n-2]=read<double>(u,n-2)-dnm1*temp;
	
  for(size_t i=n-2; i >= 1; i--)
    u[i-1]=read<double>(u,i-1)-gamma[i-1]*read<double>(u,i)-delta[i-1]*temp;
  
  {Stack->push<realarray*>(up); return;}
}

// Compute the fast Fourier transform of a pair array
void pairArrayFFT(vm::stack *Stack)
{
  int sign = vm::pop<int>(Stack,1);
  pairarray * a = vm::pop<pairarray *>(Stack);

  checkArray(a);
  unsigned n=(unsigned) a->size();
  array *c=new array(n);
#ifdef HAVE_LIBFFTW3
  Complex *f=FFTWComplex(n);
  fft1d Forward(n,sign,f);
  
  for(size_t i=0; i < n; i++) {
    pair z=read<pair>(a,i);
    f[i]=Complex(z.getx(),z.gety());
  }
  Forward.fft(f);
  
  for(size_t i=0; i < n; i++) {
    Complex z=f[i];
    (*c)[i]=pair(z.real(),z.imag());
  }
  FFTWdelete(f);
#endif //  HAVE_LIBFFTW3
  {Stack->push<pairarray*>(c); return;}
}


// File operations
// bool ==(file *a, file *b);
void gen275(vm::stack *Stack)
{
  file * b = vm::pop<file *>(Stack);
  file * a = vm::pop<file *>(Stack);

  {Stack->push<bool>(a == b); return;}
}

// bool !=(file *a, file *b);
void gen276(vm::stack *Stack)
{
  file * b = vm::pop<file *>(Stack);
  file * a = vm::pop<file *>(Stack);

  {Stack->push<bool>(a != b); return;}
}

void standardOut(vm::stack *Stack)
{

  {Stack->push<file*>(&camp::Stdout); return;}
}

void nullFile(vm::stack *Stack)
{

  {Stack->push<file*>(&camp::nullfile); return;}
}

// file* input(string name, bool check=true, string comment=commentchar);
void gen279(vm::stack *Stack)
{
  string comment = vm::pop<string>(Stack,commentchar);
  bool check = vm::pop<bool>(Stack,true);
  string name = vm::pop<string>(Stack);

  char c=comment == "" ? (char) 0 : comment[0];
  file *f=new ifile(name,check,c);
  f->open();
  {Stack->push<file*>(f); return;}
}

// file* output(string name, bool append=false);
void gen280(vm::stack *Stack)
{
  bool append = vm::pop<bool>(Stack,false);
  string name = vm::pop<string>(Stack);

  file *f=new ofile(name,append);
  f->open();
  {Stack->push<file*>(f); return;}
}

// file* xinput(string name, bool check=true);
void gen281(vm::stack *Stack)
{
  bool check = vm::pop<bool>(Stack,true);
  string name = vm::pop<string>(Stack);

#ifdef HAVE_RPC_RPC_H
  file *f=new ixfile(name,check);
  {Stack->push<file*>(f); return;}
#else  
  error("XDR support not enabled");
#endif
}

// file* xoutput(string name, bool append=false);
void gen282(vm::stack *Stack)
{
  bool append = vm::pop<bool>(Stack,false);
  string name = vm::pop<string>(Stack);

#ifdef HAVE_RPC_RPC_H
  file *f=new oxfile(name,append);
  {Stack->push<file*>(f); return;}
#else  
  error("XDR support not enabled");
#endif
}

// bool eof(file *File);
void gen283(vm::stack *Stack)
{
  file * File = vm::pop<file *>(Stack);

  {Stack->push<bool>(File->eof()); return;}
}

// bool eol(file *File);
void gen284(vm::stack *Stack)
{
  file * File = vm::pop<file *>(Stack);

  {Stack->push<bool>(File->eol()); return;}
}

// bool error(file *File);
void gen285(vm::stack *Stack)
{
  file * File = vm::pop<file *>(Stack);

  {Stack->push<bool>(File->error()); return;}
}

// void clear(file *File);
void gen286(vm::stack *Stack)
{
  file * File = vm::pop<file *>(Stack);

  File->clear();
}

// void close(file *File);
void gen287(vm::stack *Stack)
{
  file * File = vm::pop<file *>(Stack);

  File->close();
}

// void precision(file *File, int digits);
void gen288(vm::stack *Stack)
{
  int digits = vm::pop<int>(Stack);
  file * File = vm::pop<file *>(Stack);

  File->precision(digits);
}

// void flush(file *File);
void gen289(vm::stack *Stack)
{
  file * File = vm::pop<file *>(Stack);

   File->flush();
}

// string getc(file *File);
void gen290(vm::stack *Stack)
{
  file * File = vm::pop<file *>(Stack);

  char c;
  if(File->isOpen()) File->read(c);
  static char str[1];
  str[0]=c;
  {Stack->push<string>(string(str)); return;}
}

// Set file dimensions
// file* dimension(file *File, int nx);
void gen291(vm::stack *Stack)
{
  int nx = vm::pop<int>(Stack);
  file * File = vm::pop<file *>(Stack);

  File->dimension(nx);
  {Stack->push<file*>(File); return;}
}

// file* dimension(file *File, int nx, int ny);
void gen292(vm::stack *Stack)
{
  int ny = vm::pop<int>(Stack);
  int nx = vm::pop<int>(Stack);
  file * File = vm::pop<file *>(Stack);

  File->dimension(nx,ny);
  {Stack->push<file*>(File); return;}
}

// file* dimension(file *File, int nx, int ny, int nz);
void gen293(vm::stack *Stack)
{
  int nz = vm::pop<int>(Stack);
  int ny = vm::pop<int>(Stack);
  int nx = vm::pop<int>(Stack);
  file * File = vm::pop<file *>(Stack);

  File->dimension(nx,ny,nz);
  {Stack->push<file*>(File); return;}
}

// Set file to read comma-separated values
// file* csv(file *File, bool b=true);
void gen294(vm::stack *Stack)
{
  bool b = vm::pop<bool>(Stack,true);
  file * File = vm::pop<file *>(Stack);

  File->CSVMode(b);
  {Stack->push<file*>(File); return;}
}

// Set file to read arrays in line-at-a-time mode
// file* line(file *File, bool b=true);
void gen295(vm::stack *Stack)
{
  bool b = vm::pop<bool>(Stack,true);
  file * File = vm::pop<file *>(Stack);

  File->LineMode(b);
  {Stack->push<file*>(File); return;}
}

// Set file to read/write single-precision XDR values.
// file* single(file *File, bool b=true);
void gen296(vm::stack *Stack)
{
  bool b = vm::pop<bool>(Stack,true);
  file * File = vm::pop<file *>(Stack);

  File->SingleMode(b);
  {Stack->push<file*>(File); return;}
}

// Set file to read an array1 (1 int size followed by a 1d array)
// file* read1(file *File);
void gen297(vm::stack *Stack)
{
  file * File = vm::pop<file *>(Stack);

  File->dimension(-2);
  {Stack->push<file*>(File); return;}
}

// Set file to read an array2 (2 int sizes followed by a 2d array)
// file* read2(file *File);
void gen298(vm::stack *Stack)
{
  file * File = vm::pop<file *>(Stack);

  File->dimension(-2,-2);
  {Stack->push<file*>(File); return;}
}

// Set file to read an array3 (3 int sizes followed by a 3d array)
// file* read3(file *File);
void gen299(vm::stack *Stack)
{
  file * File = vm::pop<file *>(Stack);

  File->dimension(-2,-2,-2);
  {Stack->push<file*>(File); return;}
}

} // namespace run

namespace trans {

void gen_base_venv(venv &ve)
{
  addFunc(ve, run::gen8, primBoolean(), "!", primBoolean(), "b", false);
  addFunc(ve, run::gen9, primBoolean(), "^", primBoolean(), "a", false, primBoolean(), "b", false);
  addFunc(ve, run::gen18, primBoolean(), "empty", primPicture(), "f", false);
  addFunc(ve, run::gen19, primPair(), "max", primPicture(), "f", false);
  addFunc(ve, run::gen20, primPair(), "min", primPicture(), "f", false);
  addFunc(ve, run::gen21, primVoid(), "_label", primPicture(), "f", false, primString(), "s", false, primString(), "size", false, primReal(), "angle", false, primPair(), "position", false, primPair(), "align", false, primPair(), "scale", false, primPen(), "p", false);
  addFunc(ve, run::gen22, primBoolean(), "labels", primPicture(), "f", false);
  addFunc(ve, run::gen23, primVoid(), "fill", primPicture(), "f", false, pathArray()  , "g", false, primPen(), "p", false);
  addFunc(ve, run::gen24, primVoid(), "latticeshade", primPicture(), "f", false, pathArray()  , "g", false, primPen(), "fillrule", false, penArray2()  , "p", false);
  addFunc(ve, run::gen25, primVoid(), "axialshade", primPicture(), "f", false, pathArray()  , "g", false, primPen(), "pena", false, primPair(), "a", false, primPen(), "penb", false, primPair(), "b", false);
  addFunc(ve, run::gen26, primVoid(), "radialshade", primPicture(), "f", false, pathArray()  , "g", false, primPen(), "pena", false, primPair(), "a", false, primReal(), "ra", false, primPen(), "penb", false, primPair(), "b", false, primReal(), "rb", false);
  addFunc(ve, run::gen27, primVoid(), "gouraudshade", primPicture(), "f", false, pathArray()  , "g", false, primPen(), "fillrule", false, penArray()  , "p", false, pairArray(), "z", false, intArray(), "edges", false);
  addFunc(ve, run::gen28, primVoid(), "clip", primPicture(), "f", false, pathArray()  , "g", false, primPen(), "p", false);
  addFunc(ve, run::gen29, primVoid(), "beginclip", primPicture(), "f", false, pathArray()  , "g", false, primPen(), "p", false);
  addFunc(ve, run::gen30, primVoid(), "postscript", primPicture(), "f", false, primString() , "s", false);
  addFunc(ve, run::gen31, primVoid(), "tex", primPicture(), "f", false, primString() , "s", false);
  addFunc(ve, run::gen32, primVoid(), "texpreamble", primString() , "s", false);
  addFunc(ve, run::gen33, primVoid(), "layer", primPicture(), "f", false);
  addFunc(ve, run::gen34, primVoid(), "image", primPicture(), "f", false, realArray2(), "data", false, penArray()  , "palette", false, primPair(), "initial", false, primPair(), "final", false);
  addFunc(ve, run::gen35, primVoid(), "shipout", primString() , "prefix", true, primPicture(), "f", false, primPicture(), "preamble", true, primString() , "format", true, primBoolean(), "wait", true, primBoolean(), "quiet", true, transformArray(), "guitransform", false, boolArray(), "guidelete", false);
  addFunc(ve, run::gen37, primBoolean(), "==", primPen(), "a", false, primPen(), "b", false);
  addFunc(ve, run::gen38, primBoolean(), "!=", primPen(), "a", false, primPen(), "b", false);
  addFunc(ve, run::gen39, primPen(), "+", primPen(), "a", false, primPen(), "b", false);
  addFunc(ve, run::gen40, primPen(), "*", primReal(), "a", false, primPen(), "b", false);
  addFunc(ve, run::gen41, primPen(), "*", primPen(), "a", false, primReal(), "b", false);
  addFunc(ve, run::gen42, primPair(), "max", primPen(), "p", false);
  addFunc(ve, run::gen43, primPair(), "min", primPen(), "p", false);
  addFunc(ve, run::gen44, primVoid(), "resetdefaultpen");
  addFunc(ve, run::gen45, primVoid(), "defaultpen", primPen(), "p", false);
  addFunc(ve, run::gen46, primPen(), "defaultpen");
  addFunc(ve, run::gen47, primPen(), "invisible");
  addFunc(ve, run::gen48, primPen(), "gray", primPen(), "p", false);
  addFunc(ve, run::gen49, primPen(), "rgb", primPen(), "p", false);
  addFunc(ve, run::gen50, primPen(), "rgb", primReal(), "r", false, primReal(), "g", false, primReal(), "b", false);
  addFunc(ve, run::gen51, primPen(), "cmyk", primReal(), "c", false, primReal(), "m", false, primReal(), "y", false, primReal(), "k", false);
  addFunc(ve, run::gen52, primPen(), "gray", primReal(), "gray", false);
  addFunc(ve, run::gen53, realArray(), "colors", primPen(), "p", false);
  addFunc(ve, run::gen54, primPen(), "pattern", primString(), "s", false);
  addFunc(ve, run::gen55, primString() , "pattern", primPen(), "p", false);
  addFunc(ve, run::gen56, primPen(), "fillrule", primInt(), "n", false);
  addFunc(ve, run::gen57, primInt(), "fillrule", primPen(), "p", false);
  addFunc(ve, run::gen58, primPen(), "linetype", primString(), "s", false, primBoolean(), "scale", false);
  addFunc(ve, run::gen59, primString() , "linetype", primPen(), "p", false);
  addFunc(ve, run::gen60, primPen(), "linecap", primInt(), "n", false);
  addFunc(ve, run::gen61, primInt(), "linecap", primPen(), "p", false);
  addFunc(ve, run::gen62, primPen(), "linejoin", primInt(), "n", false);
  addFunc(ve, run::gen63, primInt(), "linejoin", primPen(), "p", false);
  addFunc(ve, run::gen64, primPen(), "linewidth", primReal(), "x", false);
  addFunc(ve, run::gen65, primReal(), "linewidth", primPen(), "p", false);
  addFunc(ve, run::gen66, primPen(), "fontcommand", primString(), "s", false);
  addFunc(ve, run::gen67, primString() , "font", primPen(), "p", false);
  addFunc(ve, run::gen68, primPen(), "fontsize", primReal(), "size", false, primReal(), "skip", false);
  addFunc(ve, run::gen69, primReal(), "fontsize", primPen(), "p", false);
  addFunc(ve, run::gen70, primReal(), "lineskip", primPen(), "p", false);
  addFunc(ve, run::gen71, primPen(), "overwrite", primInt(), "n", false);
  addFunc(ve, run::gen72, primInt(), "overwrite", primPen(), "p", false);
  addFunc(ve, run::gen73, primPen(), "basealign", primInt(), "n", false);
  addFunc(ve, run::gen74, primInt(), "basealign", primPen(), "p", false);
  addFunc(ve, run::gen75, primPath(), "nib", primPen(), "p", false);
  addFunc(ve, run::gen76, primPen(), "makepen", primPath(), "p", false);
  addFunc(ve, run::gen77, primVoid(), "_draw", primPicture(), "f", false, primPath(), "g", false, primPen(), "p", false);
  addFunc(ve, run::gen78, primVoid(), "endclip", primPicture(), "f", false);
  addFunc(ve, run::gen79, primVoid(), "gsave", primPicture(), "f", false);
  addFunc(ve, run::gen80, primVoid(), "grestore", primPicture(), "f", false);
  addFunc(ve, run::gen81, primVoid(), "begingroup", primPicture(), "f", false);
  addFunc(ve, run::gen82, primVoid(), "endgroup", primPicture(), "f", false);
  addFunc(ve, run::gen83, primVoid(), "add", primPicture(), "dest", false, primPicture(), "src", false);
  addFunc(ve, run::gen84, primVoid(), "prepend", primPicture(), "dest", false, primPicture(), "src", false);
  addFunc(ve, run::gen85, primString() , "fileprefix");
  addFunc(ve, run::gen86, primBoolean(), "interact");
  addFunc(ve, run::gen87, primVoid(), "uptodate", primBoolean(), "b", false);
  addFunc(ve, run::gen88, primBoolean(), "uptodate");
  addFunc(ve, run::gen89, primInt(), "system", primString(), "str", false);
  addFunc(ve, run::gen90, primVoid(), "abort", primString(), "msg", false);
  addFunc(ve, run::gen91, primVoid(), "_eval", primString(), "s", false, primBoolean(), "embedded", true);
  addFunc(ve, run::gen92, primVoid(), "_eval", primCode(), "s", false, primBoolean(), "embedded", true);
  addFunc(ve, run::gen95, primVoid(), "gui", primReal(), "x", false);
  addFunc(ve, run::gen96, primBoolean(), "deconstruct");
  addFunc(ve, run::gen97, primVoid(), "readGUI");
  addFunc(ve, run::gen99, primString() , "cd", primString(), "d", false);
  addFunc(ve, run::gen100, primVoid(), "scroll", primInt(), "n", false);
  addFunc(ve, run::gen102, primPair(), "point", primPath(), "p", false, primInt(), "n", false);
  addFunc(ve, run::gen103, primPair(), "point", primPath(), "p", false, primReal(), "t", false);
  addFunc(ve, run::gen104, primPair(), "precontrol", primPath(), "p", false, primInt(), "n", false);
  addFunc(ve, run::gen105, primPair(), "precontrol", primPath(), "p", false, primReal(), "t", false);
  addFunc(ve, run::gen106, primPair(), "postcontrol", primPath(), "p", false, primInt(), "n", false);
  addFunc(ve, run::gen107, primPair(), "postcontrol", primPath(), "p", false, primReal(), "t", false);
  addFunc(ve, run::gen108, primPair(), "dir", primPath(), "p", false, primInt(), "n", false);
  addFunc(ve, run::gen109, primPair(), "dir", primPath(), "p", false, primReal(), "t", false);
  addFunc(ve, run::gen110, primPath(), "reverse", primPath(), "p", false);
  addFunc(ve, run::gen111, primPath(), "subpath", primPath(), "p", false, primInt(), "b", false, primInt(), "e", false);
  addFunc(ve, run::gen112, primPath(), "subpath", primPath(), "p", false, primReal(), "b", false, primReal(), "e", false);
  addFunc(ve, run::gen113, primInt(), "length", primPath(), "p", false);
  addFunc(ve, run::gen114, primBoolean(), "cyclic", primPath(), "p", false);
  addFunc(ve, run::gen115, primBoolean(), "straight", primPath(), "p", false, primInt(), "i", false);
  addFunc(ve, run::gen116, primReal(), "arclength", primPath(), "p", false);
  addFunc(ve, run::gen117, primReal(), "arctime", primPath(), "p", false, primReal(), "dval", false);
  addFunc(ve, run::gen118, primReal(), "dirtime", primPath(), "p", false, primPair(), "z", false);
  addFunc(ve, run::gen119, primPair(), "intersect", primPath(), "x", false, primPath(), "y", false, primReal(), "fuzz", false);
  addFunc(ve, run::gen120, primInt(), "size", primPath(), "p", false);
  addFunc(ve, run::gen121, primPath(), "&", primPath(), "p", false, primPath(), "q", false);
  addFunc(ve, run::gen122, primPair(), "min", primPath(), "p", false);
  addFunc(ve, run::gen123, primPair(), "max", primPath(), "p", false);
  addFunc(ve, run::gen124, primReal(), "relativedistance", primReal(), "theta", false, primReal(), "phi", false, primReal(), "t", false, primBoolean(), "atleast", false);
  addFunc(ve, run::gen125, primBoolean(), "inside", pathArray()  , "g", false, primPair(), "z", false, primPen(), "p", false);
  addFunc(ve, run::gen129, primGuide(), "operator cycle");
  addFunc(ve, run::gen130, primGuide(), "operator spec", primPair(), "z", false, primInt(), "p", false);
  addFunc(ve, run::gen131, primGuide(), "operator curl", primReal(), "gamma", false, primInt(), "p", false);
  addFunc(ve, run::gen132, primGuide(), "operator tension", primReal(), "tout", false, primReal(), "tin", false, primBoolean(), "atleast", false);
  addFunc(ve, run::gen133, primGuide(), "operator controls", primPair(), "zout", false, primPair(), "zin", false);
  addFunc(ve, run::gen135, primInt(), "length", primString(), "s", false);
  addFunc(ve, run::gen136, primInt(), "find", primString(), "s", false, primString(), "sub", false, primInt(), "pos", false);
  addFunc(ve, run::gen137, primInt(), "rfind", primString(), "s", false, primString(), "sub", false, primInt(), "pos", false);
  addFunc(ve, run::gen138, primString() , "reverse", primString() , "s", false);
  addFunc(ve, run::gen139, primString() , "insert", primString() , "s", false, primInt(), "pos", false, primString(), "sub", false);
  addFunc(ve, run::gen140, primString() , "substr", primString(), "s", false, primInt(), "pos", false, primInt(), "n", false);
  addFunc(ve, run::gen141, primString() , "erase", primString() , "s", false, primInt(), "pos", false, primInt(), "n", false);
  addFunc(ve, run::gen142, primString() , "replace", primString(), "s", false, stringArray2(), "translate", false);
  addFunc(ve, run::gen143, primString() , "format", primString(), "format", false, primInt(), "x", false);
  addFunc(ve, run::gen144, primString() , "format", primString(), "format", false, primReal(), "x", false);
  addFunc(ve, run::gen145, primString() , "time", primString(), "format", false);
  addFunc(ve, run::gen146, primReal(), "^", primReal(), "x", false, primInt(), "y", false);
  addFunc(ve, run::gen147, primInt(), "quotient", primInt(), "x", false, primInt(), "y", false);
  addFunc(ve, run::gen148, primInt(), "abs", primInt(), "x", false);
  addFunc(ve, run::gen149, primInt(), "sgn", primReal(), "x", false);
  addFunc(ve, run::gen150, primInt(), "rand");
  addFunc(ve, run::gen151, primVoid(), "srand", primInt(), "seed", false);
  addFunc(ve, run::gen152, primVoid(), "srand", primInt(), "seed", false);
  addFunc(ve, run::gen153, primInt(), "ceil", primReal(), "x", false);
  addFunc(ve, run::gen154, primInt(), "floor", primReal(), "x", false);
  addFunc(ve, run::gen155, primInt(), "round", primReal(), "x", false);
  addFunc(ve, run::gen156, primInt(), "Ceil", primReal(), "x", false);
  addFunc(ve, run::gen157, primInt(), "Floor", primReal(), "x", false);
  addFunc(ve, run::gen158, primInt(), "Round", primReal(), "x", false);
  addFunc(ve, run::gen159, primReal(), "fmod", primReal(), "x", false, primReal(), "y", false);
  addFunc(ve, run::gen160, primReal(), "atan2", primReal(), "y", false, primReal(), "x", false);
  addFunc(ve, run::gen161, primReal(), "hypot", primReal(), "x", false, primReal(), "y", false);
  addFunc(ve, run::gen162, primReal(), "remainder", primReal(), "x", false, primReal(), "y", false);
  addFunc(ve, run::gen163, primReal(), "J", primInt(), "n", false, primReal(), "x", false);
  addFunc(ve, run::gen164, primReal(), "Y", primInt(), "n", false, primReal(), "x", false);
  addFunc(ve, run::gen165, primReal(), "erf", primReal(), "x", false);
  addFunc(ve, run::gen166, primReal(), "erfc", primReal(), "x", false);
  addFunc(ve, run::gen167, primReal(), "gamma", primReal(), "x", false);
  addFunc(ve, run::gen168, realArray(), "quadraticroots", primReal(), "a", false, primReal(), "b", false, primReal(), "c", false);
  addFunc(ve, run::gen169, realArray(), "cubicroots", primReal(), "a", false, primReal(), "b", false, primReal(), "c", false, primReal(), "d", false);
  addFunc(ve, run::gen170, primBoolean(), "==", primTransform(), "a", false, primTransform(), "b", false);
  addFunc(ve, run::gen171, primBoolean(), "!=", primTransform(), "a", false, primTransform(), "b", false);
  addFunc(ve, run::gen172, primTransform(), "*", primTransform(), "a", false, primTransform(), "b", false);
  addFunc(ve, run::gen173, primPair(), "*", primTransform(), "t", false, primPair(), "z", false);
  addFunc(ve, run::gen174, primPath(), "*", primTransform(), "t", false, primPath(), "g", false);
  addFunc(ve, run::gen175, primPen(), "*", primTransform(), "t", false, primPen(), "p", false);
  addFunc(ve, run::gen176, primPicture(), "*", primTransform(), "t", false, primPicture(), "f", false);
  addFunc(ve, run::gen177, primTransform(), "^", primTransform(), "t", false, primInt(), "n", false);
  addFunc(ve, run::transformIdentity, primTransform(), "identity");
  addFunc(ve, run::gen186, primTransform(), "inverse", primTransform(), "t", false);
  addFunc(ve, run::gen187, primTransform(), "shift", primPair(), "z", false);
  addFunc(ve, run::gen188, primTransform(), "xscale", primReal(), "x", false);
  addFunc(ve, run::gen189, primTransform(), "yscale", primReal(), "y", false);
  addFunc(ve, run::gen190, primTransform(), "scale", primReal(), "x", false);
  addFunc(ve, run::gen191, primTransform(), "slant", primReal(), "s", false);
  addFunc(ve, run::gen192, primTransform(), "rotate", primReal(), "angle", false, primPair(), "z", true);
  addFunc(ve, run::gen193, primTransform(), "reflect", primPair(), "a", false, primPair(), "b", false);
  addFunc(ve, run::gen199, primReal(), "length", primPair(), "z", false);
  addFunc(ve, run::gen200, primReal(), "abs", primPair(), "z", false);
  addFunc(ve, run::gen201, primReal(), "angle", primPair(), "z", false);
  addFunc(ve, run::gen202, primReal(), "degrees", primPair(), "z", false);
  addFunc(ve, run::gen203, primPair(), "unit", primPair(), "z", false);
  addFunc(ve, run::gen204, primPair(), "dir", primReal(), "theta", false);
  addFunc(ve, run::gen205, primPair(), "expi", primReal(), "theta", false);
  addFunc(ve, run::gen206, primPair(), "conj", primPair(), "z", false);
  addFunc(ve, run::gen207, primReal(), "_dot", primPair(), "u", false, primPair(), "v", false);
  addFunc(ve, run::gen213, primTriple(), "*", primReal(), "x", false, primTriple(), "v", false);
  addFunc(ve, run::gen214, primTriple(), "*", primTriple(), "v", false, primReal(), "x", false);
  addFunc(ve, run::gen215, primTriple(), "/", primTriple(), "v", false, primReal(), "x", false);
  addFunc(ve, run::gen216, primReal(), "length", primTriple(), "v", false);
  addFunc(ve, run::gen217, primReal(), "abs", primTriple(), "v", false);
  addFunc(ve, run::gen218, primReal(), "polar", primTriple(), "v", false);
  addFunc(ve, run::gen219, primReal(), "azimuth", primTriple(), "v", false);
  addFunc(ve, run::gen220, primReal(), "colatitude", primTriple(), "v", false);
  addFunc(ve, run::gen221, primReal(), "latitude", primTriple(), "v", false);
  addFunc(ve, run::gen222, primReal(), "longitude", primTriple(), "v", false);
  addFunc(ve, run::gen223, primTriple(), "unit", primTriple(), "v", false);
  addFunc(ve, run::gen224, primReal(), "dot", primTriple(), "u", false, primTriple(), "v", false);
  addFunc(ve, run::gen225, primTriple(), "cross", primTriple(), "u", false, primTriple(), "v", false);
  addFunc(ve, run::gen226, primTriple(), "expi", primReal(), "theta", false, primReal(), "phi", false);
  addFunc(ve, run::gen227, primTriple(), "dir", primReal(), "theta", false, primReal(), "phi", false);
  addFunc(ve, run::gen228, primReal(), "cubiclength", primTriple(), "z0", false, primTriple(), "z0p", false, primTriple(), "z1m", false, primTriple(), "z1", false, primReal(), "goal", false);
  addFunc(ve, run::gen229, primPair(), "intersect", tripleArray(), "pre1", false, tripleArray(), "point1", false, tripleArray(), "post1", false, tripleArray(), "pre2", false, tripleArray(), "point2", false, tripleArray(), "post2", false, primReal(), "fuzz", false);
  addFunc(ve, run::gen230, primReal(), "pi");
  addFunc(ve, run::gen231, primInt(), "intMax");
  addFunc(ve, run::gen232, primReal(), "infinity");
  addFunc(ve, run::gen233, primReal(), "realMax");
  addFunc(ve, run::gen234, primReal(), "realMin");
  addFunc(ve, run::gen235, primReal(), "realEpsilon");
  addFunc(ve, run::gen236, primReal(), "randMax");
  addFunc(ve, run::gen237, primString() , "VERSION");
  addFunc(ve, run::gen238, primVoid(), "quiet", primBoolean(), "v", false);
  addFunc(ve, run::gen239, primVoid(), "atexit", voidFunction(), "f", false);
  addFunc(ve, run::gen240, voidFunction(), "atexit");
  addFunc(ve, run::gen241, primInt(), "merge", stringArray(), "files", false, primString(), "args", false, primString(), "format", false, primBoolean(), "keep", false);
  addFunc(ve, run::gen262, intArray(), "sequence", primInt(), "n", false);
  addFunc(ve, run::gen264, primBoolean(), "all", boolArray(), "a", false);
  addFunc(ve, run::gen265, boolArray(), "!", boolArray(), "a", false);
  addFunc(ve, run::gen266, primInt(), "sum", boolArray(), "a", false);
  addFunc(ve, run::gen271, primInt(), "find", boolArray(), "a", false, primInt(), "n", false);
  addFunc(ve, run::gen273, realArray(), "tridiagonal", realArray(), "a", false, realArray(), "b", false, realArray(), "c", false, realArray(), "f", false);
  addFunc(ve, run::gen275, primBoolean(), "==", primFile(), "a", false, primFile(), "b", false);
  addFunc(ve, run::gen276, primBoolean(), "!=", primFile(), "a", false, primFile(), "b", false);
  addFunc(ve, run::gen279, primFile(), "input", primString() , "name", false, primBoolean(), "check", true, primString() , "comment", true);
  addFunc(ve, run::gen280, primFile(), "output", primString() , "name", false, primBoolean(), "append", true);
  addFunc(ve, run::gen281, primFile(), "xinput", primString() , "name", false, primBoolean(), "check", true);
  addFunc(ve, run::gen282, primFile(), "xoutput", primString() , "name", false, primBoolean(), "append", true);
  addFunc(ve, run::gen283, primBoolean(), "eof", primFile(), "file", false);
  addFunc(ve, run::gen284, primBoolean(), "eol", primFile(), "file", false);
  addFunc(ve, run::gen285, primBoolean(), "error", primFile(), "file", false);
  addFunc(ve, run::gen286, primVoid(), "clear", primFile(), "file", false);
  addFunc(ve, run::gen287, primVoid(), "close", primFile(), "file", false);
  addFunc(ve, run::gen288, primVoid(), "precision", primFile(), "file", false, primInt(), "digits", false);
  addFunc(ve, run::gen289, primVoid(), "flush", primFile(), "file", false);
  addFunc(ve, run::gen290, primString() , "getc", primFile(), "file", false);
  addFunc(ve, run::gen291, primFile(), "dimension", primFile(), "file", false, primInt(), "nx", false);
  addFunc(ve, run::gen292, primFile(), "dimension", primFile(), "file", false, primInt(), "nx", false, primInt(), "ny", false);
  addFunc(ve, run::gen293, primFile(), "dimension", primFile(), "file", false, primInt(), "nx", false, primInt(), "ny", false, primInt(), "nz", false);
  addFunc(ve, run::gen294, primFile(), "csv", primFile(), "file", false, primBoolean(), "b", true);
  addFunc(ve, run::gen295, primFile(), "line", primFile(), "file", false, primBoolean(), "b", true);
  addFunc(ve, run::gen296, primFile(), "single", primFile(), "file", false, primBoolean(), "b", true);
  addFunc(ve, run::gen297, primFile(), "read1", primFile(), "file", false);
  addFunc(ve, run::gen298, primFile(), "read2", primFile(), "file", false);
  addFunc(ve, run::gen299, primFile(), "read3", primFile(), "file", false);
}

} // namespace trans
