import three;
import light;
import graph3;

// A solid geometry package.

// Try to find a bounding tangent line between two paths.
real[] tangent(path p, path q, bool side) 
{
  if((cyclic(p) && inside(p,point(q,0)) || 
      cyclic(q) && inside(q,point(p,0))) &&
     intersect(p,q) == (-1,-1)) return new real[];

  real time(path p) {
    pair m=min(p);
    pair M=max(p);
    path edge=side ? (m.x,m.y)--(M.x,m.y) : (m.x,M.y)--(M.x,M.y);
    return intersect(p,edge).x;
  }

  static real epsilon=sqrt(realEpsilon);
  
  transform T;
  for(int i=0; i < 100; ++i) {
    real ta=time(p);
    real tb=time(q);
    pair a=point(p,ta);
    pair b=point(q,tb);
    real angle=angle(b-a,warn=false);
    if(abs(angle) <= epsilon || abs(abs(0.5*angle)-pi) <= epsilon) {
      transform Tinv=inverse(T);
      return new real[] {ta,tb};
    }
    transform t=rotate(-degrees(angle));
    T *= t;
    p=t*p;
    q=t*q;
  }
  return new real[];
}

path line(path p, path q, real[] t) 
{
  return point(p,t[0])--point(q,t[1]);
}

// Return a generalized cylinder of height h constructed from area base in
// the XY plane and aligned with axis.
path[] cylinder(guide3 base, real h, triple axis=Z,
		projection P=currentprojection) 
{
  base=rotate(-colatitude(axis),cross(axis,Z))*base;
  guide3 top=shift(h*axis)*base;
  path Base=project(base,P);
  path Top=project(top,P);
  real[] t1=tangent(Base,Top,true);
  real[] t2=tangent(Base,Top,false);
  path p=subpath(Base,t1[0],t2[0]);
  path q=subpath(Base,t2[0],t1[0]);
  return base^^project(top,P)^^line(Base,Top,t1)^^line(Base,Top,t2);
}

struct skeleton {
  // transverse skeleton
  guide3[] front;
  guide3[] back;
  // longitudinal skeleton
  guide3[] longitudinal;
}

skeleton operator init() {return new skeleton;}
  
// A surface of revolution generated by rotating a planar guide3 g from
// angle1 to angle2 about c--c+axis.
struct revolution {
  public path3 g;
  public triple axis;
  public triple c;
  public real angle1,angle2;
  
  void init(path3 g, triple axis=Z, triple c=O, real angle1=0,
	    real angle2=360) {
    this.g=g;
    this.axis=unit(axis);
    this.c=c;
    this.angle1=angle1;
    this.angle2=angle2;
  }
  
  revolution copy() {
    revolution r=new revolution;
    r.init(g,axis,c,angle1,angle2);
    return r;
  }
  
  int m=12;
  
  path3 slice(real position) {
    triple v=point(g,position);
    triple center=c+dot(v-c,axis)*axis;
    return Circle(center,abs(v-center),axis,m);
  }
  
  skeleton skeleton(int m=0, projection P=currentprojection) {
    skeleton s=new skeleton;
    
    // transverse skeleton
    static real epsilon=sqrt(realEpsilon);
    int n=(m == 0) ? size(g) : m;
    real factor=1/(m-1);
    for(int i=0; i < n; ++i) {
      real t=(m == 0) ? i : reltime(g,i*factor);
      path3 S=slice(t);
      if((i == 0 && dot(axis,P.camera) < 0) ||
	 (i == n-1 && dot(axis,P.camera) >= 0))
	s.front.push(S);
      else {
	path3 Sp=slice(t+epsilon);
	path3 Sm=slice(t-epsilon);
	path sp=project(Sp,P);
	path sm=project(Sm,P);
	real[] t1=tangent(sp,sm,true);
	real[] t2=tangent(sp,sm,false);
	if(t1.length > 1 && t2.length > 1) {
	  real t1=t1[0];
	  real t2=t2[0];
	  if(t2 < t1) t2 += length(S);
	  path3 p1=subpath(S,t1,t2);
	  path3 p2=subpath(S,t2,t1+length(S));
	  if(dot(point(p1,0.5*length(p1))-c,P.camera) >= 0) {
	    s.front.push(p1);
	    s.back.push(p2);
	  } else {
	    s.front.push(p2);
	    s.back.push(p1);
	  }
	}
      }
    }
    
    // longitudinal skeleton
    real t, d=0;
    // Find a point on g of maximal distance from the axis.
    for(int i=0; i < n; ++i) {
      triple v=point(g,i);
      triple center=c+dot(v-c,axis)*axis;
      real r=abs(v-center);
      if(r > d) {
	t=i;
	d=r;
      }
    }

    triple v=point(g,t);
    path3 S=slice(t);
    path3 Sm=slice(t+epsilon);
    path3 Sp=slice(t-epsilon);
    path sp=project(Sp,P);
    path sm=project(Sm,P);
    real[] t1=tangent(sp,sm,true);
    real[] t2=tangent(sp,sm,false);
    transform3 t=align(axis);
    real ref=longitude(t*v-c,warn=false);
    if(t1.length > 1)
      s.longitudinal.push(rotate(longitude(t*point(S,t1[0])-c,warn=false)-ref,
				 c,c+axis)*g);
    if(t2.length > 1)
      s.longitudinal.push(rotate(longitude(t*point(S,t2[0])-c,warn=false)-ref,
				 c,c+axis)*g);
    return s;
  }
  
  void draw(picture pic=currentpicture, int m=0, pen p=currentpen,
	    pen backpen=p, projection P=currentprojection) {
    skeleton s=skeleton(m,P);
    begingroup(pic);
    draw(pic,s.longitudinal,p);
    draw(pic,s.back,linetype("8 8",8)+backpen);
    draw(pic,s.front,p);
    endgroup(pic);
  }
  
  // Fill on picture pic the surface of rotation generated by rotating g
  // from angle1 to angle2 sampled n times about the line c--c+axis, using
  // the spatially dependent pen color(triple).
  void fill(picture pic=currentpicture, int n=36, pen color(triple),
	    projection P=currentprojection) {
    real s=(angle2-angle1)/n;
  
    triple normal=normal(g);
    if(abs(normal) <= epsilon) normal=unit(cross(dir(g,0),axis));
    if(abs(normal) <= epsilon) normal=unit(cross(point(g,0)-c,axis));

    triple perp=cross(normal,axis);
  
    int L=length(g);
    triple[] point=new triple[L+1];
    triple[] midpoint=new triple[L+1];
  
    for(int i=0; i <= L; ++i) {
      point[i]=point(g,i);
      midpoint[i]=point(g,i+0.5);
    }
  
    triple surface(triple v, real j) {
      triple center=c+dot(v-c,axis)*axis;
      return center+abs(v-center)*(Cos(j)*perp+Sin(j)*normal);
    }
  
    triple vertex(int i, real j) {return surface(point[i],j);}
    triple center(int i, real j) {return surface(midpoint[i],j);}

    int[] edges={0,0,0,2};
    real depth[][];
  
    begingroup(pic);
    for(int i=0; i < L; ++i) {
      real phi=angle1;
      for(int j=0; j < n; ++j, phi += s) {
	triple v=P.camera-center(i,phi+0.5s);
	real d=sgn(dot(v,P.camera))*abs(v);
	depth.push(new real[] {d,i,phi});
      }
    }
  
    depth=sort(depth);
  
    while(depth.length > 0) {
      real[] a=depth.pop();
      int i=round(a[1]);
      real j=a[2];
      triple[] v={vertex(i,j),vertex(i+1,j),vertex(i+1,j+s),vertex(i,j+s)};
      pen[] p={color(v[0]),color(v[1]),color(v[2]),color(v[3])};
      gouraudshade(pic,project(v[0]--v[1]--v[2]--v[3]--cycle3,P),p,v,edges);
    }
    endgroup(pic);
  }
  
  void fill(picture pic=currentpicture, int n=36, pen p=currentpen,
	    projection P=currentprojection) {
    pen color(triple x) {return currentlight.intensity(x)*p;}
    fill(pic,n,color,P);
  }
  
  void filldraw(picture pic=currentpicture, int n=36,
		pen fillpen=currentpen,  int m=2, pen drawpen=currentpen,
		projection P=currentprojection) {
    fill(pic,n,fillpen,P);
    draw(pic,m,drawpen,P);
  }
  
}

revolution operator init() {return new revolution;}
  
revolution revolution(path3 g, triple axis=Z, triple c=O, real angle1=0,
		      real angle2=360) 
{
  revolution r;
  r.init(g,axis,c,angle1,angle2);
  return r;
}

revolution operator * (transform3 t, revolution r)
{
  triple trc=t*r.c;
  return revolution(t*r.g,t*(r.c+r.axis)-trc,trc,r.angle1,r.angle2);
}

// Return a vector perpendicular to axis.
triple perp(triple axis)
{
  triple v=cross(axis,X);
  if(v == O) v=cross(axis,Y);
  return v;
}

// Return a circular cylinder of radius r and height h centered at c and
// aligned with axis.
revolution cylinder(triple c=O, real r, real h, triple axis=Z) {
  c += r*perp(axis);
  axis=0.5*h*unit(axis);
  revolution r=revolution(c-axis--c+axis,axis);
  return r;
}
