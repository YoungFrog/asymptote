\input texinfo   @c -*-texinfo-*-
@setfilename asymptote.info
@include version.texi
@settitle asymptote

@copying
This file documents @code{Asymptote}, version @value{VERSION}.

http://asymptote.sourceforge.net
     
Copyright @copyright{} 2004 Andy Hammerlindl, John Bowman, and Tom Prince.
     
@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the @acronym{GNU} General Public License (see the
file LICENSE in the top-level source directory).

@end quotation
@end copying
     
@dircategory Languages
@direntry
* asymptote: (asymptote).		Vector graphics language.
@end direntry

@titlepage
@title Asymptote
@subtitle For version @value{VERSION}
@image{logo}
     
@page
@vskip 0pt plus 1filll
@insertcopying
     
@end titlepage
     
@c So the toc is printed at the start.
@contents
     
@ifnottex
@node Top
@top Asymptote
     
@insertcopying
@end ifnottex

@menu
* Description::                 What is @code{Asymptote}?
* Installation::                Downloading and installing
* Examples::                    Getting started
* Programming::                 The @code{Asymptote} vector graphics language
* Drawing commands::            Four primitive graphics commands
* LaTeX usage::                 Embedding @code{Asymptote} commands within @code{LaTeX}
* Options::                     Command line options
* Interactive mode::            Typing @code{Asymptote} commands interactively
* GUI::                         Graphical user interface
* Help::                        Where to get help and submit bug reports
* Credits::                     Contributions and acknowledgments
* Index::                       General index

@detailmenu
 --- The Detailed Node Listing ---

Programming

* Data types::                  void, bool, int, real, pair, string
* Guides and paths::            Specifying lines and curves
* Pens::                        Colors, line types, line widths, font sizes
* Transforms::                  Affine transforms
* Frames and pictures::         Canvases for immediate and deferred drawing
* Files::                       Reading and writing your data
* Structures::                  Organize your data
* Arithmetic & logical::        Standard binary operators
* Self & prefix operators::     Self operators, increment, and decrement
* Implicit scaling::            Avoiding those ugly *s
* Functions::                   Traditional and high-order functions
* Arrays::                      Dynamic vector class
* Casts::                       Implicit and explicit casts
* Import::                      Importing external @code{Asymptote} packages
* Static::                      Where to allocate your variable?

Functions

* Default arguments::           Default values can appear anyway
* Mathematical functions::      Standard libm functions


Import

* plain::                       Default @code{Asymptote} base file
* simplex::                     Linear programming: simplex method
* graph::                       2D linear & logarithmic graphs
* graph3d::                     Preliminary 3D projection routines
* featpost3D::                  Preliminary port of @code{featpost3d}
* math::                        Extend @code{Asymptote}'s math capabilities
* stats::                       Statistics routines and histograms
* tree::                        Dynamic binary search tree
* feynman::                     Feynman diagrams
* metapost::                    @code{MetaPost} compatibility routines
* unicode::                     Accept @code{unicode} (UTF-8) characters
* latin1::                      Accept @code{ISO 8859-1} characters
* babel::                       Implement @code{LaTeX} @code{babel} package

@end detailmenu
@end menu

@node Description
@chapter Description
@cindex description

@code{Asymptote} is a powerful script-based vector graphics language that
provides a natural coordinate-based framework for technical drawings.
Labels and equations are typeset with @code{LaTeX}, for overall document
consistency, yielding the same high-quality level of typesetting that
@code{LaTeX} provides for scientific text. By default it produces
@code{PostScript} output, but it can also generate any format that the
@code{ImageMagick} package can produce.
     
A major advantage of @code{Asymptote} over other graphics packages is
that it is a high-level programming language, as opposed to just a graphics
program: it can therefore exploit the best features of the script
(command-driven) and graphical-user-interface (GUI) methods for
producing figures. The rudimentary GUI @code{xasy} included with the
package allows one to move script-generated objects
around. To make @code{Asymptote} accessible to the average user, this GUI is
currently being developed into a full-fledged interface that can
generate objects directly. However, the script portion of the language
is now ready for general use by users who are willing to learn a few
simple @code{Asymptote} graphics commands @ref{Drawing commands}.

@code{Asymptote} is mathematically oriented (e.g. at the lowest levels, one can
use multiplication by complex numbers to rotate a vector) and uses
@code{LaTeX} to do the 
typesetting of labels. This is an important feature for scientific
applications. It was inspired by an earlier drawing program (with a much weaker
syntax & capabilities) called @code{MetaPost}.

Many of the features of @code{Asymptote} are written in the
@code{Asymptote} language itself. While the stock version of
@code{Asymptote} is designed for mathematics typesetting needs, one can
write @code{Asymptote} modules that tailor it to specific
applications. A scientific graphing module has already been written
(@pxref{graph}).

Examples of @code{Asymptote} code and output are available at
@verbatim
http://asymptote.sourceforge.net/gallery/
@end verbatim

Features of the @code{Asymptote} graphics language include:

@itemize @bullet
@item provides a natural coordinate-based framework for technical drawings,
inspired by @code{MetaPost}, with a much cleaner, powerful C++-like programming
syntax;

@item @code{LaTeX} typesetting of labels, for overall document consistency

@item compiles figures into pseudo-machine code for speed without
sacrificing portability;

@item the power of a script-based language coupled to the convenience of a GUI;

@item can be customized using its own C++-like graphics programming language 

@item sensible defaults for graphical features, with the ability to override

@item provides a high-level mathematically oriented interface to the
@code{PostScript} language for vector graphics, complete with affine transforms
and complex variables

@item functions can create new (anonymous) functions

@item uses simplex method and deferred drawing to solve overall size
constraint issues between fixed-sized objects (labels and arrowheads) and
objects that should scale with figure size;

@item designed to become the de-facto standard for typesetting mathematical
figures, just as @TeX{}/@code{LaTeX} has become the standard for typesetting
equations;

@end itemize

@node Installation
@chapter Installation
@cindex installation

A binary distribution of @code{Asymptote} version @code{x.xx} for a
specific platform @code{ARCH} can be installed in @code{/usr/local} with
the commands:
@verbatim
cd /
tar -zxf asymptote-x.xx.ARCH.tar.gz
texhash
install-info --infodir=/usr/local/info /usr/local/info/asymptote.info 
@end verbatim

To uninstall:
@verbatim
install-info --delete --infodir=/usr/local/info \
  /usr/local/info/asymptote.info
tar -zxvf asymptote-x.xx.ARCH.tar.gz | xargs rm
texhash
@end verbatim

To compile and install @code{Asymptote} from a source release
@code{x.xx}, execute the commands:
@verbatim
tar -zxf asymptote-x.xx.tar.gz
cd asymptote-x.xx
./configure
make all
make install
@end verbatim

For a (default) system-wide installation, the last command should be
done as root.

In order to compile @code{Asymptote} you will need the @code{boost}
headers from @code{http://boost.org} (included in Fedora Linux distributions).
Installation of the complete boost library may require the following (or
later):
@verbatim
http://dl.sourceforge.net/sourceforge/boost/boost-jam-3.1.10-1.i386.rpm
http://dl.sourceforge.net/sourceforge/boost/boost_1_32_0.tar.bz2
@end verbatim

However, @code{Asymptote} currently only uses the @code{boost} header files,
so it is sufficient to copy the @code{boost} subdirectory from the
@code{boost} source distribution to @code{/usr/include} or even just
make a link in the top level directory of the @code{Asymptote} source code:

@verbatim
tar -jxf boost_1_32_0.tar.bz2  
tar -jxf asymptote-x.xx.tar.gz 
cd asymptote-x.xx 
ln -s ../boost_1_32_0/boost .
./configure 
make all
make install 
@end verbatim

@cindex Debian
On machines running Debian Linux, the boost library can be installed with
@verbatim
apt-get install libboost-dev libboost-graph-dev
@end verbatim

Alternatively, Debian users can install Hubert Chan's @code{Asymptote}
package:
@verbatim
http://www.uhoreg.ca/programming/debian.text
@end verbatim

@cindex readline
If you are compiling with @code{gcc}, you will need a relatively recent version
(e.g. 3.3.3 or later). If you get errors compiling @code{interact.cc},
try installing an up-to-date version of the GNU @code{readline} library
or else uncomment @code{HAVE_LIBREADLINE} in @code{config.h}.

The FFTW library is only required if you want @code{Asymptote} to be able to
take Fourier transforms of data (say, to compute an audio power spectrum).

If you don't want to install @code{Asymptote} system wide, just make
sure the compiled binary @code{asy} and GUI script @code{xasy} are in
your path and set the environment variable @code{ASYMPTOTE_DIR} to point
to the directory @code{base} (in the top level directory of the
@code{Asymptote} source code). In looking for @code{Asymptote} system
files, @code{asy} will search the following paths, in the order listed:

@anchor{search paths}
@enumerate
@item
current directory
@item
@cindex @code{ASYMPTOTE_DIR}
@code{$ASYMPTOTE_DIR}
@item
system-wide directory (default: @code{/usr/local/share/asymptote})
@end enumerate

@cindex @code{-V}
@cindex @code{ASYMPTOTE_PSVIEWER}
@cindex @code{ASYMPTOTE_PDFVIEWER}
In interactive mode, or when given the @code{-V} option,
@code{Asymptote} will attempt to open up a @code{PostScript} viewer
by first trying to execute the program specified by the optional
environment variable @code{ASYMPTOTE_PSVIEWER}, then @code{gv},
@code{ggv}, @code{ghostview}, and finally @code{gsview}. To support interactive
mode, the @code{PostScript} viewer must be able to redraw a file whenever
it changes. The default @code{PostScript} viewer @code{gv}
supports this automatically (via @code{SIGHUP}); users of @code{ggv} will need
to enable @code{Watch file} under @code{Edit/Postscript Viewer Preferences}.
For viewing PDF format output, there is an @code{ASYMPTOTE_PDFVIEWER}
environment variable and a PDF viewer list @code{gv}, @code{acroread}, and
@code{xpdf}.

@cindex @code{emacs}
@cindex @code{asy-mode}
Users of @code{emacs} can edit @code{Asymptote} code with the mode
@code{asy-mode}, after enabling it by putting these two lines in the
@code{~/.emacs} initialization file, replacing @code{ASYDIR} with the
location of the Asymptote example files (by default,
@code{/usr/local/share/doc/asymptote}):
@verbatim
(autoload 'asy-mode "ASYDIR/asy-mode.el" "Asymptote major mode." t)
(setq auto-mode-alist (cons (cons "\\.asy$" 'asy-mode) auto-mode-alist))

@end verbatim

@cindex @code{vim}
@cindex @code{asy.vim}
Fans of @code{vim} can
@verbatim 
cp /usr/local/share/doc/asymptote/asy.vim ~/.vim/syntax/asy.vim
@end verbatim 

and add the following to their @code{~/.vimrc} file: 
@verbatim
augroup filetypedetect
au BufNewFile,BufRead *.asy     setf asy
augroup END
filetype plugin on
@end verbatim

If any of these directories or files don't exist, just create them.
To set @code{vim} up to run the current asymptote script using @code{:make}
just add to @code{~/.vim/ftplugin/asy.vim}:
@verbatim
setlocal makeprg=asy\ %
setlocal errorformat=%f:\ %l.%c:\ %m

@end verbatim

To uninstall all @code{Asymptote} files, type:
@verbatim
make uninstall
@end verbatim

The following commands are needed to install the latest development version of
@code{Asymptote} from cvs (when prompted for the CVS password, type enter): 
@verbatim
cvs -d:pserver:anonymous@cvs.sourceforge.net:/cvsroot/asymptote login
 
cvs -d:pserver:anonymous@cvs.sourceforge.net:/cvsroot/asymptote co asymptote
cd asymptote-x.xx
./autogen.sh
./configure
make all
make install
@end verbatim

To compile without optimization, use the command @code{make OPT=-g}.

@node Examples
@chapter Examples
@cindex examples
To draw a line from coordinate (0,0) to coordinate (100,100) using
@code{Asymptote}'s interactive mode, type:
@verbatim
asy
draw((0,0)--(100,100));
@end verbatim
@image{diagonal}

@cindex @code{bp}
The units here are @code{PostScript} "big points" 
(1 @code{bp} = 1/72 @code{inch}); @code{--} means join with a linear segment.

At this point you can type in further draw commands, which will be added
to the displayed figure, or type @code{quit} to exit interactive mode.
Further commands specific to interactive mode are described in
@ref{Interactive mode}.

You can use the arrow keys in interactive mode to edit previous lines
(assuming that you have support for the GNU readline library enabled).
Because interactive mode is emulated, it is currently intended only for
short demonstration files (@pxref{Interactive mode}). For more
complicated graphs we recommend using batch mode.

Let's repeat the previous example in batch mode. Simply type in the
commands 
@verbatim
draw((0,0)--(100,100));
shipout();
@end verbatim

into a file, say test.asy. Then execute this file by typing
@verbatim
asy -V test
@end verbatim

The shipout command converts the current picture into @code{PostScript}. A
shipout command is added implicitly in interactive mode, but is
explicitly required in batch mode. 

@cindex @code{-V}
The @code{-V} option opens up a @code{PostScript}
viewer window so you can immediately view the encapsulated
@code{PostScript} output. By default the output will be written to the
file @code{test.eps}; the prefix of the output file may be changed with
the @code{-o} command line option.



@cindex @code{cycle}
One can draw a line with more than two points and create a cyclic path
like this square:
@verbatim
draw((0,0)--(100,0)--(100,100)--(0,100)--cycle);
shipout();
@end verbatim
@image{square}

It is often inconvenient to work directly with @code{PostScript} coordinates.
The next example draws a unit square scaled to width 100bp and height 100bp.
The output is identical to that of the previous example. (If you are using
interactive mode ignore the two messages "warning: scaling in picture
unbounded;" see @ref{Interactive mode} for details).
@verbatim
size(100,100);
draw((0,0)--(1,0)--(1,1)--(0,1)--cycle);
shipout();
@end verbatim

@cindex @code{inches}
@cindex @code{cm}
@cindex @code{mm}
@cindex @code{pt}
One can also specify the size in @code{pt} (1 @code{pt} = 1/72.27 @code{inch}),
@code{cm}, @code{mm}, or @code{inches}. 
If 0 is given as a size argument, no restriction is made in that direction;
the overall scaling will be determined by the other direction:
@xref{size}.
@verbatim
size(0,5cm);
draw((0,0)--(1,0)--(1,1)--(0,1)--cycle);
shipout();
@end verbatim
@image{bigsquare}

See section @ref{graph} for examples of two-dimensional scientific graphs.

@node Programming
@chapter Programming
@cindex programming

Here is a short introductory example to the @code{Asymptote} programming
language that highlights it's similarity with the control structures of
C and C++.
@cindex declaration
@cindex assignment
@cindex conditional
@cindex loop
@cindex @code{if}
@cindex @code{else}
@cindex @code{for}
@verbatim
// This is a comment.

// Declaration: Declare x to be a real variable;
real x;

// Assignment: Assign the real variable x the value 1.
x=1.0;

// Conditional: Test if x equals 1 or not.
if(x == 1.0) {
  write("x equals 1.0");
} else {
  write("x is not equal to 1.0");
}

// Loop: iterate 10 times
for(int i=0; i < 10; ++i) {
  write(i);
}
@end verbatim

@cindex @code{gifmerge}
@cindex @code{merge}
@cindex @code{convert}
@cindex animation
@cindex @code{ImageMagick}
Another example of a loop, together with user-defined functions, is
provided in the file @code{wheelanimation.asy} in the examples
directory (by default @code{/usr/local/share/doc/asymptote}).
This example uses the
@code{gifmerge} command to @code{merge} multiple images
into a gif animation, using the @code{ImageMagick} @code{convert} program. 

@cindex @code{while}
@cindex @code{do}
@cindex @code{break}
@cindex @code{continue}
@code{Asymptote} also supports @code{while}, @code{do}, @code{break}, and
@code{continue} statements just as in C/C++. In addition, it supports
many features beyond the ones found in those languages.

@menu
* Data types::                  void, bool, int, real, pair, string
* Guides and paths::            Specifying lines and curves
* Pens::                        Colors, line types, line widths, font sizes
* Transforms::                  Affine transforms
* Frames and pictures::         Canvases for immediate and deferred drawing
* Files::                       Reading and writing your data
* Structures::                  Organize your data
* Arithmetic & logical::        Standard binary operators
* Self & prefix operators::     Self operators, increment, and decrement
* Implicit scaling::            Avoiding those ugly *s
* Functions::                   Traditional and high-order functions
* Arrays::                      Dynamic vector class
* Casts::                       Implicit and explicit casts
* Import::                      Importing external @code{Asymptote} packages
* Static::                      Where to allocate your variable?
@end menu

@node Data types
@section Data types
@cindex data types
@code{Asymptote} supports the following data types (in addition to any
user-defined types):

@table @code

@item void
@cindex @code{void}
The void type is used only by functions that take or return no arguments.

@item bool
@cindex @code{bool}
a boolean type that can only take on the values @code{true} and
@code{false}. For example:
@verbatim
bool b=true;
@end verbatim

defines a boolean variable @code{b} and initializes it to the value
@code{true}. If no initializer is given:
@verbatim
bool b;
@end verbatim

the value @code{false} is assumed.

@item int
@cindex @code{int}
an integer type; if no initializer is given, the implicit value @code{0}
is assumed.

@item real
@cindex @code{real}
a real number; this should be set to the highest-precision native
floating-point type on the architecture. The implicit initializer for
type real is @code{0.0}.

@item pair
@cindex @code{pair}
complex number, that is, an ordered pair of real components @code{(x,y)}.
The real and imaginary parts of a pair @code{z} can read as @code{z.x}
and @code{z.y}. We say that @code{x} and @code{y} are virtual members of
the data element pair; they cannot be directly modified, however.
The implicit initializer for type pair is @code{(0.0,0.0)}.

There are a number of ways to take the complex conjugate of a pair:
@example
pair z=(3.0,4.0);
z=(z.x,-z.y);
z=z.x-I*z.y;
z=conj(z);
@end example

A number of built-in functions are defined for pairs:

@table @code
@item pair conj(pair z)
@cindex @code{conj}
returns the conjugate of @code{z};

@item real length(pair z)
@cindex @code{length}
@cindex @code{abs}
return the complex modulus @code{|z|} of its argument @code{z}. 
For example,
@example
pair z=(3.0,4.0);
write(length(z));
@end example
produces the result 5. A synonym for @code{length(pair)} is @code{abs(pair)};

@item real angle(pair z)
@cindex @code{angle}
returns the angle of @code{z} in radians;

@item real Angle(pair z)
@cindex @code{Angle}
returns the angle of @code{z} in degrees in the interval [0,360);

@item pair unit(pair z)
@cindex @code{unit}
returns a unit vector in the direction of the pair @code{z};

@item pair expi(real angle)
@cindex @code{expi}
returns a unit vector in the direction @code{angle} measured in radians;

@item pair dir(real angle)
@cindex @code{dir}
returns a unit vector in the direction @code{angle} measured in degrees;

@item real xpart(pair z)
@cindex @code{xpart}
returns @code{z.x};

@item real ypart(pair z)
@cindex @code{ypart}
returns @code{z.y};

@item real Dot(pair a,pair b)
@cindex @code{dir}
returns the dot product @code{a.x*b.x+a.y*b.y}.

@end table


@item string
@cindex @code{string}
@cindex @TeX{} string
a character string, implemented using the STL @code{string} class.

Strings delimited by double quotes (@code{"}) are subject to the
following mapping to allow the use of double quotes in @TeX{} (e.g. for
using the @code{babel} package, @pxref{babel}):

@itemize @bullet 
@item \" maps to "
@end itemize

@cindex @code{C} string
Strings delimited by single quotes (@code{'}) have the same mappings as
character strings in ANSI @code{C}:

@itemize @bullet 
@item \' maps to '
@item \" maps to "
@item \? maps to ?
@item \\ maps to backslash
@item \a maps to alert
@item \b maps to backspace
@item \f maps to form feed
@item \n maps to newline
@item \r maps to carriage return
@item \t maps to tab
@item \v maps to vertical tab
@item \1-\377 map to corresponding octal byte
@item \x1-\xFF map to corresponding hexadecimal byte
@end itemize

The implicit initializer for type string is the empty string @code{""}.
In the following string functions, position 0 denotes the start of the string.

@table @code

@cindex @code{find}
@item int find(string s, string t)
returns the position of the first occurrence of string @code{t} in string
@code{s}, or -1 if  @code{t} is not a substring of @code{s}; 

@cindex @code{rfind}
@item int rfind(string s, string t)
returns the position of the last occurrence of string @code{t} in string
@code{s}, or -1 if  @code{t} is not a substring of @code{s};

@cindex @code{insert}
@item string insert(string s, int pos, string t)
return the string formed by inserting string @code{t} at position
@code{pos} in @code{s};

@cindex @code{erase}
@item string erase(string s, int pos, int n)
returns the string formed by erasing the string of length @code{n} at
position @code{pos} in @code{s};

@cindex @code{substr}
@item string substr(string s, int pos, int n)
returns the substring of @code{s} starting at position @code{pos}
and of length @code{n};

@cindex @code{reverse}
@item string reverse(string s)
return the string formed by reversing string @code{s};

@item string replace(string s, string from, string to) 
@cindex @code{replace}
returns a string with all occurrences of the string @code{from} in the
string @code{s} changed to the string @code{to};

@item string replace(string s, string[][] table)
returns a string constructed by translating in string @code{s} all
occurrences of the string @code{from} in an array @code{table} of string pairs
@{@code{from},@code{to}@} to the corresponding string @code{to};

@anchor{format}
@item string format(string s, int n) 
@cindex @code{format}
returns a string containing @code{n} formatted according to the C-style
format string @code{s};

@item string format(string s, real x)
returns a string containing @code{x} formatted according to the C-style format
string @code{s}, using @TeX{} to typeset scientific notation;

@item string time(string s)
@cindex @code{time}
returns the current time formatted by the ANSI C routine strftime
according to the string @code{s}. For example,
@verbatim
write(time("%a %b %d %H:%M:%S %Z %Y"));
@end verbatim

outputs the time in the default format of the UNIX @code{date} command.

@end table

@cindex @code{typedef}
As in C/C++, complicated types may be abbreviated with @code{typedef}
(see the example in @ref{Functions}).

@end table

@node Guides and paths
@section Guides and paths

@table @code
@item guide
@cindex @code{guide}
an unresolved cubic spline (list of cubic-spline nodes and control points).

This is like a path except the computation of the cubic spline is
deferred until drawing time (when it is resolved into a path); this allows
two guides with free endpoint conditions to be joined together smoothly.

@item path
@cindex @code{path}
a cubic spline resolved into a fixed path.

A path is specified by as a list of pairs or paths interconnected with
@cindex @code{cycle}
@cindex @code{--}
@cindex @code{..}
@code{--}, which denotes a straight line segment, or @code{..}, which
denotes a cubic spline.
@anchor{unitcircle}
@cindex @code{unitcircle}
Specifying a final node @code{cycle} creates a cyclic path that connects back
to the initial node, as in this approximation (accurate to within 0.06%)
of a unit circle:
@verbatim
guide unitcircle=E..N..W..S..cycle;
@end verbatim

The above example uses the standard compass directions @code{E=(1,0)},
@code{N=(0,1)}, @code{NE=unit(N+E)}, and @code{ENE=unit(E+NE)}, etc.,
which along with the directions @code{up}, @code{down}, @code{right},
and @code{left} are defined as pairs in the default @code{Asymptote} base file
@code{plain.asy}.
@cindex @code{circle}
A useful routine in @code{plain.asy} constructs a circle of radius
@code{r} centered on @code{c} by transforming unitcircle:
@verbatim
guide circle(pair c, real r)
{
  return shift(c)*scale(r)*unitcircle;
}
@end verbatim

@anchor{Bezier}
Each interior node of a cubic spline may be given a
direction prefix or suffix @code{@{dir@}}: the direction of the pair
@code{dir} specifies the direction of the incoming or outgoing tangent,
respectively, to the curve at that node. Exterior nodes may be
given direction specifiers only on their interior side. Cubic splines between
a node @code{z}, with postcontrol point @code{Z}, and a node @code{w},
with precontrol point @code{W}, are computed as the Bezier curve

@image{bezier,,,(1-t)^3*z+3t(1-t)^2*Z+3t^2(1-t)*W+t^3*w for 0 <=t <= 1.}

This example draws an approximate quarter circle:
@verbatim
draw((100,0){up}..{left}(0,100));
shipout();
@end verbatim
@image{quartercircle}

@cindex @code{control}
Instead of specifying the tangent directions before and after a node,
one can also specify directly the control points directly:
@verbatim
path p=(100,0)..control(100,100)..(0,100);
@end verbatim

@cindex @code{tension}
@cindex @code{and}
@cindex @code{at least}
One can also change the spline tension from its default value of 1.0 to any
value greater than or equal to 0.75:
@verbatim
path p=(100,0)..tension 2.0..(100,100)..(0,100);
path p=(100,0)..tension 2.0 and 1.0..(100,100)..(0,100);
path p=(100,0)..tension atleast 1.0..(100,100)..(0,100);
@end verbatim

@cindex @code{MetaPost ...}
@cindex @code{MetaPost ---}
The @code{MetaPost ...} joiner, which selects an inflection-free
path where possible, is not explicitly implemented in Asymptote since it is
just a macro for @code{..tension atleast 1.0..} (likewise, the
@code{MetaPost ---} joiner is a macro for @code{..tension atleast
infinity..}). For example,
@verbatim
path p=(0,0){up}..tension atleast 1.0..(1,0.25){right}..
tension atleast 1.0..(2,0){down};
@end verbatim

@cindex @code{curl}
The curl parameter specifies the curvature at the endpoints of a path
(0.0 means straight; the default value of 1.0 means approximately circular):
@verbatim
path p=(100,0){curl 0.0}..(100,100)..{curl 0.0}(0,100);
@end verbatim

The implicit initializer for paths and guides is @code{nullpath},
which is useful for building up a path within a loop.
For completeness, we document here the action of direction modifiers
on @code{nullpath}. If a single direction specifier is given to
@code{nullpath}, it modifies the pair on the other side. 
In the case of a two specifiers (one on each side of @code{nullpath}), the
first one is ignored. For example, these paths
@verbatim
a..{up}nullpath..b;
z..nullpath{up}..w;
u..{up}nullpath{down}..v;
@end verbatim

are respectively equivalent to
@verbatim
a..nullpath..{up}b;
z{up}..nullpath..w;
u{down}..nullpath..v;
@end verbatim

Here are some useful functions for paths:

@table @code

@cindex @code{length}
@item int length(path)
This is the number of (linear or cubic) segments in the path.
If the path is cyclic, this is the same as the number of nodes in the path.

@cindex @code{size}
@item int size(path)
This is the number of nodes in the path.
If the path is cyclic, this is the same as the path length.

@cindex @code{point}
@item pair point(path p, int n)
If @code{p} is cyclic, return the coordinates of node @code{n} mod
@code{length(p)}. Otherwise, return the coordinates of node @code{n},
unless @code{n} < 0 (in which case @code{point(0)} is returned) or
@code{n} > @code{length(p)} (in which case @code{point(length(p))}
is returned).

@item pair point(path p, real x)
This returns the coordinates of the point between node @code{floor(x)}
and @code{floor(x)+1} corresponding to the cubic spline parameter
t=@code{x-floor(x)} (@pxref{Bezier}). If @code{x} lies outside the range
[0,@code{length(p)}], it is first reduced modulo @code{length(p)}
in the case where @code{p} is cyclic or else converted to the corresponding
endpoint of @code{p}.

@cindex @code{dir}
@item pair dir(path, int n)
This returns the direction of the tangent to the path at node @code{n}.

@item pair dir(path, real x)
This returns the direction of the tangent to the path at the point
between node @code{floor(x)} and @code{floor(x)+1} corresponding to the
cubic spline parameter t=@code{x-floor(x)} (@pxref{Bezier}).

@cindex @code{precontrol}
@item pair precontrol(path, int n)
This returns the precontrol point of node @code{n}.

@cindex @code{postcontrol}
@item pair postcontrol(path, int n)
This returns the postcontrol point of node @code{n}.

@cindex @code{arclength}
@item real arclength(path)
This returns the length of the piecewise linear or cubic curve that the path
represents.

@cindex @code{arctime}
@item real arctime(path, real L)
This returns the path "time", a real number between 0 and the length of
the path in the sense of @code{point(path, real)}, at which the
cumulative arclength (measured from the beginning of the path) equals @code{L}.

@cindex @code{dirtime}
@item real dirtime(path, pair z)
This returns the first "time", a real number between 0 and the length of
the path in the sense of @code{point(path, real)}, at which the tangent
to the path has direction @code{z}, or -1 if the path never achieves
direction @code{z}.

@cindex @code{reverse}
@item path reverse(path p)
returns a path running backwards along p.

@cindex @code{subpath}
@item path subpath(path p, int n, int m)
returns the subpath running from node @code{n} to node @code{m}.
If @code{n} < @code{m}, the direction of the subpath is reversed.

@item path subpath(path p, real a, real b)
returns the subpath running from path time @code{a} to path time @code{b},
in the sense of @code{point(path, real)}. If @code{a} < @code{b}, the
direction of the subpath is reversed.

@cindex @code{intersect}
@item pair intersect(path p, path q)
If @code{p} and @code{q} have at least one intersection point, return a
pair of times (s,t) representing the respective path times along
@code{p} and @code{q}, in the sense of @code{point(path, real)}, for
one such intersection point. If the paths do not intersect, return the
pair (-1,-1).

@cindex @code{firstcut}
@cindex @code{slice}
@item slice firstcut(path p, path q)
Return the portions of path @code{p} before and after the first intersection
of @code{p} with path @code{q} as a structure @code{slice} (if no such
intersection exists, the entire path is considered to be `before' the
intersection):
@verbatim
struct slice {
  public path before,after;
}
@end verbatim

@cindex @code{MetaPost cutbefore}
Note that @code{firstcut.after} plays the role of the @code{MetaPost}
@code{cutbefore} command.

@cindex @code{lastcut}
@item slice lastcut(path p, path q)
Return the portions of path @code{p} before and after the last intersection
of @code{p} with path @code{q} as a @code{slice} (if no such
intersection exists, the entire path is considered to be `after' the
intersection).

@cindex @code{MetaPost cutafter}
Note that @code{lastcut.before} plays the role of the @code{MetaPost}
@code{cutafter} command.

@cindex @code{max}
@item pair max(path)
returns the pair(right,top) for the path bounding box.

@cindex @code{min}
@item pair min(path)
returns the pair(left,bottom) for the path bounding box.

@cindex @code{cyclic}
@item bool cyclic(path)
returns @code{true} iff path is cyclic

@cindex @code{straight}
@item bool straight(path, int i)
returns @code{true} iff the segment between node @code{i} and node @code{i+1}
is straight.

@end table

@end table

@node Pens
@section Pens

@cindex @code{pen}
@cindex @code{currentpen}
@cindex @code{MetaPost pickup}
@code{Asymptote} uses pens to specify the following drawing attributes:
color, line type, line width, font size, and calligraphic transforms on
the pen nib. The default pen used by the drawing routines is called
@code{currentpen}. This provides the same functionality as the
@code{MetaPost} command @code{pickup}.

@itemize @bullet

@item Colors are specified using one of the following colorspaces:
@cindex color
@table @code
@item pen gray(real g) 
@cindex @code{gray}
@cindex grayscale
This produces a grayscale color, where the intensity @code{g} lies in the
interval [0,1], with 0.0 denoting black and 1.0 denoting white.

@item pen rgb(real r, real g, real b) 
@cindex @code{rgb}
This produces an rgb color, where each of the red, green, and blue intensities
@code{r}, @code{g}, @code{b}, lies in the interval [0,1].

@item pen cmyk(real c, real m, real y, real k) 
@cindex @code{cmyk}
This produces a cmyk color, where each of the cyan, magenta,
yellow, and black intensities @code{c}, @code{m}, @code{y}, @code{k},
lies in the interval [0,1].

@item pen invisible()
@cindex @code{invisible}
This special pen writes in invisible ink! It is analogous to the
@code{\phantom} command in @TeX{}.

@end table

@cindex @code{defaultpen}
The default color is @code{black}; this may be changed with the routine
@code{defaultpen(pen)}. A number of named rgb colors are defined near
the top of the default base file @code{plain.asy}:
@verbatim
black,gray,white,red,green,blue,yellow,magenta,cyan,brown,darkgreen,
darkblue,orange,purple,chartreuse,fuchsia,salmon,lightblue,lavender,pink,
@end verbatim

along with the primitive cmyk colors:
@verbatim
Cyan,Magenta,Yellow,Black.
@end verbatim

@cindex @code{colors}
The function @code{real[] colors(pen)} returns the color components of a pen.

@item Line types are specified with the function @code{pen linetype(string s)},
@cindex @code{solid}
@cindex @code{dashed}
@cindex @code{dotted}
@cindex @code{longdashed}
@cindex @code{dashdotted}
@cindex @code{longdashdotted}
where @code{s} is a string of integer or real numbers separated by spaces.
The first number specifies how far (in @code{PostScript} coordinates) to draw
with the pen on, the second number specifies how far to draw with the pen off,
and so on (these spacings are automatically adjusted by @code{Asymptote}
to fit the arclength of the path). Here are the predefined line types:
@verbatim
pen solid=linetype("");
pen dotted=linetype("0 4");
pen dashed=linetype("8 8");
pen longdashed=linetype("24 8");
pen dashdotted=linetype("8 8 0 8");
pen longdashdotted=linetype("24 8 0 8");
@end verbatim
@image{linetype}

@cindex @code{defaultpen}
The default linetype is @code{solid}; this may be changed with
@code{defaultpen(pen)}.

@cindex @code{linewidth}
@cindex @code{defaultpen}
@item The pen line width is specified in @code{PostScript} units with
@code{pen linewidth(real)}. The default line width is 0.5 bp; this value
may be changed with @code{defaultpen(pen)}. 
Note that @code{real} (but not @code{int}) values are implicitly cast to
pens of the specified line width: 
@verbatim
pen double=1bp;
pen equivalent=1.0;
@end verbatim

@cindex @code{linecap}
@cindex @code{Square}
@cindex @code{Round}
@cindex @code{Extended}
@cindex @code{defaultpen}
@item A pen with a specific @code{PostScript} line cap style is returned
on calling @code{linecap} with one of the arguments @code{Square},
@code{Round}, or @code{Extended}. The default line cap style is @code{Round};
this may be changed with @code{defaultpen(pen)}. 

@cindex @code{linejoin}
@cindex @code{Square}
@cindex @code{Round}
@cindex @code{Extended}
@item A pen with a specific @code{PostScript} join style is returned on
calling @code{linejoin} with one of the arguments @code{Miter},
@code{Round}, or @code{Bevel}. The default join style is @code{Round};
this may be changed with @code{defaultpen(pen)}. 

@cindex @code{fontsize}
@cindex @code{defaultpen}
@item The font size is specified in @TeX{} points (1 pt = 1/72.27 inches) with
the function @code{pen fontsize(real)}. The default font size is 12pt;
this value may be changed with @code{defaultpen(pen)}.

@cindex patterns
@cindex tilings
@item @code{PostScript} commands within a @code{picture} may be used
to create a tiling pattern, identified by the string @code{name}, for
@code{fill} and @code{draw} operations by adding it to the default
@code{PostScript} preamble frame @code{patterns}:
@verbatim
void add(frame preamble=patterns, string name, picture pic, pair lb=0,
	 pair rt=0)
@end verbatim

To @code{fill} or @code{draw} using pattern @code{name}, use
the pen @code{pattern("name")}. For example, a hatch pattern can be produced
as follows:

@verbatim
size(100,0);

picture tiling=new picture;
draw(tiling,scale(4mm)*unitsquare,linecap(Square)+linejoin(Miter));
add("hatch",tiling,min(currentpen),max(currentpen));

fill(unitsquare,pattern("hatch"));
shipout();
@end verbatim
@image{hatch}

The tiled pattern can even incorporate shading (@pxref{gradient shading}):

@verbatim
size(0,100);
real d=4mm;

picture tiling=new picture;
guide square=scale(d)*unitsquare;
fill(tiling,square,white,(0,0),black,(d,d));
fill(tiling,shift(d,d)*square,blue);
add("checked",tiling);

fill(unitcircle,pattern("checked"));
shipout();
@end verbatim
@image{shadedtiling}

@anchor{overwrite}
@cindex @code{overwrite}
@item One can prevent labels from overwriting one another by using
the pen attribute @code{overwrite}, which takes a single argument:

@table @code
@cindex @code{Allow}
@cindex @code{defaultpen}
@item Allow
Allow labels to overwrite one another. This is the default behaviour (unless
overridden with @code{defaultpen(pen)}.

@cindex @code{Suppress}
@item Suppress
Suppress, with a warning, each label that would overwrite another label.

@cindex @code{SuppressQuiet}
@item SuppressQuiet
Suppress, without warning, each label that would overwrite another label.

@cindex @code{Move}
@item Move
Move a label that would overwrite another out of the way and issue a warning.
As this adjustment is during the final output phase (in @code{PostScript}
coordinates) it could result in a larger figure than requested.

@cindex @code{MoveQuiet}
@item MoveQuiet
Move a label that would overwrite another out of the way, without warning.
As this adjustment is during the final output phase (in @code{PostScript}
coordinates) it could result in a larger figure than requested.

@end table

@end itemize

@cindex @code{+}
@cindex @code{*}
Pens may be added together with the binary operator @code{+}.
This will mix the colors of the two pens.
Other non-default attributes of the right most pen will
override those of the left most pen. Thus, one can obtain a yellow
dashed pen by saying @code{dashed+red+green} or @code{red+green+dashed}
or @code{red+dashed+green}. The binary operator @code{*}
can be used to scale the color of a pen by a real number, until it
saturates with one or more color components equal to 1.

@cindex @code{defaultpen}
Calling the routine @code{defaultpen()} without arguments resets all
pen default attributes to their initial values.

@node Transforms
@section Transforms

@cindex @code{transform}
@code{Asymptote} makes extensive use of affine transforms of the form
@code{a+Bx}, where @code{a} is a pair and @code{B} is a 2x2
matrix. Transforms can be applied to pairs, guides, paths, pens,
transforms, frames, and pictures by multiplication on the left (see
@pxref{unitcircle} for an example).

Possible transforms are:

@table @code
@item identity()
@cindex @code{identity}
the identity transform;
@item shift(pair z)
@cindex @code{shift}
translates by pair @code{z};
@item xscale(real x)
@cindex @code{xscale}
scales in the x-direction by @code{x};
@item yscale(real y)
@cindex @code{yscale}
scales in the y-direction by @code{y};
@item scale(pair z)
@cindex @code{scale}
equivalent to multiplication by @code{z};
@item slant(real s)
@cindex @code{slant}
maps @code{(x,y)} --> @code{(x+s*y,y)};
@item rotate(real a)
@cindex @code{rotate}
rotates by angle @code{a} about origin;
@item rotate(real a, pair z)
rotates by angle @code{a} about @code{z};
@item reflect(pair z, pair w)
@cindex @code{reflect}
reflect about line @code{z--w}.
@end table

Transforms can be composed with one another and inverted with the
function @code{inverse(transform)}.
The implicit initializer for transforms is @code{identity()}.

@node Frames and pictures
@section Frames and pictures

@table @code

@item frame
@cindex @code{frame}
@cindex @code{nullframe}
Frames are canvases for drawing in @code{PostScript} coordinates. While working
with frames directly is occasionally necessary for constructing deferred
drawing routines, pictures are usually more convenient to work with.
The implicit initializer for frames is @code{nullframe}.

@item picture
@cindex @code{picture}
Pictures are high-level structures (@pxref{Structures}) defined in
@code{plain.asy} that provide canvases for drawing in user coordinates. 
The default picture is called @code{currentpicture}. Since structures
have no default initialization, this should be done explicitly
whenever a new picture is declared:
@verbatim
picture pic=new picture;
@end verbatim

A picture is fit to a frame upon calling the function @code{shipout},
using the default or given size specification: 

@anchor{shipout}
@cindex @code{shipout}
@verbatim
void shipout(string prefix=defaultfilename,
             picture pic=currentpicture, frame preamble=patterns,
             real xsize=pic.xsize, real ysize=pic.ysize,
             keepAspect keepAspect=
             pic.keepAspect ? Aspect : IgnoreAspect,
             orientation orientation=Portrait,
             string format="", wait wait=NoWait);
@end verbatim

In reality, @code{shipout} is implemented using several functions,
because of the way default arguments are implemented. Also, an
explicit picture argument is required in order to specify a
@code{PostScript} preamble.

Rather than specifying the size information explicitly to @code{shipout},
one can alternatively use the @code{size} function:

@anchor{size}
@cindex @code{size}
@verbatim
void size(picture pic=currentpicture,
          real xsize, real ysize, keepAspect keepAspect=Aspect);
@end verbatim

If @code{xsize} and @code{ysize} are both 0, user coordinates will be
interpreted as @code{PostScript} coordinates. In this case, the transform
mapping @code{pic} to the final output frame is @code{identity}.

If exactly one of @code{xsize} or @code{ysize} is 0, no size restriction
is imposed in that direction; it will be scaled the same as the other 
direction.

If @code{keepAspect} is set to @code{Aspect}, the picture will be scaled
with its aspect ratio preserved such that the final width is no more
than @code{xsize} and the final height is no more than @code{ysize}. 

If @code{keepAspect} is set to @code{IgnoreAspect}, the picture will be
scaled in both directions so that the final width is @code{xsize} and
the height is @code{ysize}. 

@cindex portrait mode
@cindex landscape mode
@cindex seascape mode
The default page orientation is @code{Portrait}. To output in landscape
mode, simply replace the call to @code{shipout} with:
@verbatim
shipout(Landscape);
@end verbatim

To rotate in the other direction, replace @code{Landscape} with
@code{Seascape}.

@cindex @code{bbox}
To draw a bounding box with a 0.25cm margin around a picture, fit the
picture into a frame using the @code{bbox} function (defined in
@code{plain.asy}):
@verbatim
shipout(bbox(0.25cm));
@end verbatim

Sometimes it is useful to draw objects on separate pictures and add one
picture to another using the @code{add} function:
@cindex @code{add}
@verbatim
void add(picture src);
void add(picture dest, picture src);
@end verbatim

The first example adds @code{src} to @code{currentpicture}; the second
one adds @code{src} to @code{dest}. 

There are also corresponding routines to add a picture @code{src} specified in
postscript coordinates to another picture about the point @code{origin}:
@cindex @code{addabout}
@verbatim
void addabout(pair origin, picture dest, picture src);
void addabout(pair origin, picture src);
@end verbatim


@cindex @code{erase}
To erase the contents of a picture (but not the size specification), use
the function
@verbatim
void erase(picture pic=currentpicture);
@end verbatim

Many further examples of picture and frame operations are provided in
the base file @code{plain.asy}.

@cindex verbatim
@cindex @code{postscript}
It is possible to insert verbatim @code{PostScript} commands in a picture with
the routine
@verbatim
void postscript(picture pic=currentpicture, string s);
@end verbatim

@anchor{tex}
@cindex @code{tex}
Verbatim @TeX{} commands can be inserted in the output with the function
@verbatim
void tex(picture pic=currentpicture, string s);
@end verbatim

@cindex @code{include}
@cindex @acronym{EPS}
For example, the @code{tex} function is used in the default base file
@code{plain.asy} to implement an @code{include} command that
includes an encapsulated @code{PostScript} (@acronym{EPS}) file into a
picture: 
@verbatim
void include(picture pic=currentpicture, string name, 
             string options="");
@end verbatim

Here, @code{name} is the name of the file to include and
@code{options} is a string containing a comma-separated list of
optional bounding box (@code{llx lly urx ury}), width (@code{width=value}), 
height (@code{height=value}), rotation (@code{angle=value}),
scaling (@code{scale=factor}), clipping (@code{clip=bool}),
and draft mode (@code{draft=bool}) parameters. Note that @code{include}
does not change a picture's bounding box.

To issue a global @TeX{} command in the @TeX{} preamble (valid for the entire
file) use:
@cindex @code{texpreamble}
@verbatim
void texpreamble(string s);
@end verbatim

@end table

@node Files
@section Files

@cindex @code{file}
@code{Asymptote} can read and write text files (including comma-separated
value) files and portable XDR (External Data Representation) binary files.

An input file must first be opened with @code{input(string)}; reading is then
done by assignment: 
@cindex open
@cindex @code{input}
@cindex reading
@verbatim
file fin=input("test.txt");
real a=fin;
@end verbatim

@cindex @code{getc}
When reading pairs, the enclosing parenthesis are optional.
Strings are also read by assignment, by reading characters up to but not
including a newline. In addition, @code{Asymptote} provides the function
@code{string getc(file)} to read the next character only, returning it
as a string.

@cindex @code{output}
@cindex @code{write}
Writing is implemented as a function call:
@verbatim
real a=1, b=2, c=3;
file fout=output("test.txt");
write(fout,a);
@end verbatim

@cindex @code{stdin}
@cindex @code{stdout}
There are two special files: @code{stdin}, which reads from the keyboard,
and @code{stdout}, which writes to the terminal.

@cindex @code{endl}
@cindex @code{tab}
A final optional @code{endl} argument to @code{write} causes a newline
to be written after writing the data. Alternatively, a final @code{tab}
argument writes a tab instead. The file argument to @code{write} is also
optional; when omitted the write is done to @code{stdout} and terminated
by a newline. In this case, the write may include up to 3 data
arguments, which will be output to @code{stdout}, separated by tabs. That is, 
@verbatim
write();
write(a);
write(a,b);
write(a,b,c);
@end verbatim

is equivalent to 
@verbatim
write(stdout,endl);
write(stdout,a,endl);
write(stdout,a,tab); write(stdout,b,endl);
write(stdout,a,tab); write(stdout,b,tab); write(stdout,c,endl);
@end verbatim

Files may also be opened with @code{xinput} or @code{xoutput} instead of
@code{input} or @code{output}, in which case the reading or writing will
be done using Sun Microsystem's XDR (External Data Representation)
portable binary format (available on all UNIX platforms).
The default initializer for file is @code{stdout}.

@cindex @code{eof}
@cindex @code{eol}
@cindex @code{error}
@cindex @code{flush}
@cindex @code{clear}
@cindex @code{precision}
One can test a file for end-of-file with the boolean function @code{eof(file)},
end-of-line with @code{eol(file)}, and for I/O errors with @code{error(file)}.
One can flush the output buffers with @code{flush(file)}, clear a
previous I/O error with @code{clear(file)}, and close the file with
@code{close(file)}. To set the number of digits of output precision, use
@code{precision(file,int)}.

@node Structures
@section Structures
@cindex @code{struct}
@cindex structures
@cindex @code{public}
@cindex @code{private}
@cindex @code{this}
@cindex @code{new}

Users may also define their own data types as structures, along with
user-defined operators, much as in C++. By default, structure
members are read-only when referenced outside the structure, but may be
optionally declared @code{public} (read-write) or @code{private} (read
and write allowed only inside the structure). The virtual structure @code{this}
refers to the enclosing structure. Structures currently have no default
initialization, so this must be done explicitly, using the keyword @code{new}:
@cindex @code{operator}
@verbatim
struct S {
  public real a=1;
  real f(real a) {return a+this.a;}
}

S s=new S;

write(s.f(2));                  // Outputs 3

S operator + (S s1, S s2)
{
  S result=new S;
  result.a=s1.a+s2.a;
  return result;
}

write((s+s).f(0));              // Outputs 2

@end verbatim

For a more complicated example of a structure, see the structure
@code{picture} in the default @code{Asymptote} base file @code{plain.asy}.

@node Arithmetic & logical
@section Arithmetic & logical operators
@cindex arithmetic operators
@cindex binary operators
@cindex boolean operators
@cindex logical operators

@code{Asymptote} uses the standard binary arithmetic operators. Both operands
are promoted to the same type, which will also be the type of the result: 
@table @code
@cindex @code{+}
@item +
addition
@cindex @code{-}
@item -
subtraction
@cindex @code{*}
@item *
multiplication
@cindex @code{/}
@item /
division
@cindex @code{%}
@item %
modulo; the result always has the same sign as the divisor. 
@cindex @code{^}
@item ^
power; if the exponent (second argument) is an int, recursive
multiplication is used; otherwise, logarithms and exponentials are used.

@end table

The usual boolean operators are also defined:
@table @code
@cindex @code{==}
@item ==
equals
@cindex @code{!=}
@item !=
not equals
@cindex @code{<}
@item <
less than
@cindex @code{<=}
@item <=
less than or equals
@cindex @code{>=}
@item >=
greater than or equals
@cindex @code{>}
@item >
greater than
@cindex @code{&&}
@item &&
and
@cindex @code{||}
@item ||
or
@cindex @code{^}
@item ^
xor
@cindex @code{!}
@item !
not
@end table

@code{Asymptote} also supports the C-like conditional syntax:
@verbatim
bool positive=(pi >= 0) ? true : false;
@end verbatim

@node Self & prefix operators
@section self & prefix operators
@cindex self operators
@cindex prefix operators
@cindex @code{+=}
@cindex @code{-=}
@cindex @code{*=}
@cindex @code{/=}
@cindex @code{%=}
@cindex @code{^=}
@cindex @code{++}
@cindex @code{--}

As in C, each of the arithmetic operators @code{+}, @code{-}, @code{*},
@code{/}, @code{%}, and @code{^} can be used as a self-operator. 
The prefix operators @code{++} (increment by one) and @code{--} (decrement
by one) are also defined.
For example,
@verbatim
int i=1;
i += 2;
int j=++i;
@end verbatim

is equivalent to the code
@verbatim
int i=1;
i=i+2;
int j=i=i+1;
@end verbatim

@cindex postfix operators
However, postfix operators like @code{i++} and @code{i--} are not defined
(because of the inherent ambiguities that would arise with the @code{--}
path-joining operator). In the rare instances where @code{i++} 
and @code{i--} are really needed, one can substitute the expressions
@code{(++i-1)} and @code{(--i+1)}, respectively.

@cindex side effects
Keep in mind that these self- and prefix operators can cause side effects 
due to multiple evaluations, as in the following example (which writes
"hi!" twice rather than just once):
@verbatim
struct T {
  public int x=0;
}

T sayhi() {
  write("hi!");
  return new T;
}

sayhi().x += 1;
@end verbatim

@node Implicit scaling
@section Implicit scaling
@cindex implicit scaling

If a numeric literal is in front of certain types of expressions, then the two 
are multiplied:
@verbatim
int x=2;
real y=2.0;
real cm=72/2.540005;

write(3x);
write(2.5x);
write(3y);
write(-1.602e-19 y);
write(0.5(x,y));
write(2x^2);
write(3x+2y);
write(3(x+2y));
write(3sin(x));
write(3(sin(x))^2);
write(10cm);
@end verbatim

This produces the output
@verbatim
6
5
6
-3.204e-19
(1,1)
16
10
18
2.72789228047704
7.44139629388625
283.464008929116
@end verbatim

@node Functions
@section Functions
@cindex functions

@code{Asymptote} functions are treated as variables with a signature 
(non-function variables have null signatures). Variables with the 
same name are allowed, so long as they have distinct signatures. 

Functions arguments are passed by value. To pass an argument by
reference, simply enclose it in a structure (@pxref{Structures}).

Here are some examples of @code{Asymptote} functions:

@enumerate
@item Two distinct variables:
@verbatim
int x, x();           
x=5;
x=new int() {return 17;};
x=x();              // calls x() and puts the result, 17, in the scalar x
@end verbatim

@item Traditional function definitions are allowed:
@verbatim
int sqr(int x)  
{
  return x*x;
}
sqr=null;           // but the function is still just a variable.
@end verbatim

@item
@verbatim
int a, a(), b, b(); // Valid: creates four variables.
a=b;                // Invalid: assignment is ambiguous.
a=(int) b;          // Valid: resolves ambiguity.
(int) (a=b);        // Valid: resolves ambiguity.
(int) a=b;          // Invalid: cast expressions can't be used as values.

int c();
c=a;                // Valid: only one possible assignment.
@end verbatim

@item Anonymous (so-called "high-order") functions are also allowed:
@cindex @code{typedef}
@verbatim
typedef int intop(int);
intop adder(int m)
{
  return new int(int n) {return m+n;};
}
intop addby7=adder(7);
write(addby7(1));   // Writes 8.
@end verbatim
@end enumerate

@code{Asymptote} is the only language we know of that treats functions
as variables but still allows overloading.

@cindex @code{libsigsegv}
@anchor{stack overflow}
@cindex recursion
@cindex stack overflow
Functions are allowed to recursively call themselves. As in C++, infinite
nested recursion will generate a stack overflow (reported as a
segmentation fault, unless the GNU library @code{libsigsegv} is
installed at configuration time). 

@menu
* Default arguments::           Default values can appear anyway
* Mathematical functions::      Standard libm functions

@end menu

@node Default arguments
@subsection Default arguments
@cindex default arguments

@code{Asymptote} supports a more flexible mechanism for default function
arguments than C++: they may appear anywhere in the function prototype.
Because certain data types are implicitly cast to more 
sophisticated types (see @ref{Casts}) one can often avoid ambiguities by
ordering function arguments from the simplest to the most complicated.
For example, given
@verbatim
real f(int a=1, real b=0) {return a+b;}
@end verbatim

then @code{f(1)} returns 1.0, but @code{f(1.0)} returns 2.0.

The value of a default argument is determined simply by evaluating the
given @code{Asymptote} expression (effectively substituted by a "cut and paste"
operation).

@node Mathematical functions
@subsection Mathematical functions
@cindex mathematical functions
@cindex functions
@cindex @code{libm} routines

@cindex @code{sin}
@cindex @code{cos}
@cindex @code{tan}
@cindex @code{asin}
@cindex @code{acos}
@cindex @code{atan}
@cindex @code{exp}
@cindex @code{log}
@cindex @code{log10}
@cindex @code{sinh}
@cindex @code{cosh}
@cindex @code{tanh}
@cindex @code{asinh}
@cindex @code{acosh}
@cindex @code{atanh}
@cindex @code{sqrt}
@cindex @code{cbrt}
@cindex @code{fabs}
@cindex @code{pow10}
@code{Asymptote} has built-in versions of the standard @code{libm} mathematical
real(real) functions @code{sin}, @code{cos}, @code{tan}, @code{asin},
@code{acos}, @code{atan}, @code{exp}, @code{log}, @code{pow10},
@code{log10}, @code{sinh}, @code{cosh}, @code{tanh}, @code{asinh},
@code{acosh}, @code{atanh}, @code{sqrt}, @code{cbrt}, @code{fabs}, as
well as the identity function @code{identity}.

@cindex @code{atan2}
@cindex @code{hypot}
@cindex @code{fmod}
@cindex @code{drem}
The standard real(real, real) functions @code{atan2}, @code{hypot},
@code{fmod}, @code{drem} are also included.

@cindex @code{ceil}
@cindex @code{floor}
@cindex @code{round}
@cindex @code{sgn}
The functions @code{ceil}, @code{floor}, and @code{round} differ from
their usual definitions in that they all return an @code{int} value rather than
a real (since that is normally what one wants). We also define a
function @code{sgn}, which returns the sign of its real argument as an
integer (-1, 0, or 1).

@cindex @code{abs}
There is an @code{abs(int)} function, as well as an @code{abs(real)} function
(equivalent to @code{fabs(real)}) and an @code{abs(pair)} function
(equivalent to @code{length(pair)}).

@cindex @code{rand}
@cindex @code{srand}
@cindex @code{randMax}
@cindex @code{Gaussrand}
@cindex @code{histogram}
Random numbers can be seeded with @code{srand(int)} and generated with
the @code{int rand()} function, which returns a random integer between 0
and the integer @code{randMax()}. A Gaussian random number generator
@code{Gaussrand} and a collection of statistics routines, including
@code{histogram}, are provided in the base file @code{stats.asy}.


@node Arrays
@section Arrays
@cindex arrays

Appending @code{[]} to any type (either built-in or user defined)
produces an array (technically a vector) indexed by integers in the
interval [0,@code{length}-1], where @code{length} represents the array length.
For convenience, integer indices in [-@code{length},-1] are mapped to
[0,@code{length}-1]. Reading an array element with an index outside of these
bounds generates an error. Assigning an array element with an 
index less than -@code{length} generates an error; however, if the index
is non-negative, the array is resized, as required, to accommodate the
new element. One can also index an array @code{A} with an integer array
@code{B}, to obtain the array formed by indexing array @code{A} with
successive elements of array @code{B}.

The declaration
@verbatim
real[] A;
@end verbatim

initializes @code{A} to be a empty (zero-length) array. Empty arrays should be
distinguished from null arrays. If we say
@verbatim
real[] A=null;
@end verbatim

then @code{A} cannot be dereferenced at all (null arrays have no length
and cannot be read from or assigned to).

Arrays can be explicitly initialized like this:
@verbatim
real[] A={0,1,2};
@end verbatim

Array assignment in @code{Asymptote} does a shallow copy: only
the pointer is copied (if one copy if modified, the other will be too). 
The @code{copy} function listed below provides a deep copy of an array.

Every array @code{A} has two virtual members, @code{length} and @code{push}.
@code{A.length} evaluates to the length of the array @code{A}, while
@code{A.push()} is a function that pushes its argument onto the the end
of the array. Like all functions in @code{Asymptote}, @code{push} can be
"pulled off" of the array and used on its own:
@verbatim
int[] A={1,2,3};
void f(int)=A.push; // A now contains {1,2,3,7}.
f(7);
@end verbatim

In the following list of built-in array functions, @code{T} represents a
generic type.

@table @code

@cindex @code{new}
@item new T[]
returns a new empty array of type @code{T[]};

@cindex @code{new}
@item new T[] @{list@}
returns a new array of type @code{T[]} initialized with @code{list} (a comma
delimited list of elements).

@item new T[n]
returns a new array of @code{n} elements of type @code{T[]}. 
Unless they are arrays themselves, these @code{n} array elements are
not initialized.

@cindex @code{sequence}
@item int[] sequence(int n)
if @code{n >= 1} returns the array @code{@{0,1,...,n-1@}} (otherwise returns
a null array);

@item int[] sequence(int n, int m)
if @code{m >= n} returns an array @code{@{n,n+1,...,m@}} (otherwise
returns a null array);

@item int[] sequence(T f(int),n)
if @code{n >= 1} returns the sequence @code{@{f_i :i=0,1,...n-1@}} given a
function @code{T f(int)} and integer @code{int n} (otherwise returns a
null array);

@cindex @code{reverse}
@item int[] reverse(int n)
if @code{n >= 1} returns the array @code{@{n-1,n-2,...,0@}} (otherwise
returns a null array);

@cindex @code{find}
@item int find(bool[], int n=1)
returns the index of the @code{n}th @code{true} value or -1 if not found.
If @code{n} is negative, search backwards from the end of the array for the
@code{-n}th value; 

@cindex @code{copy}
@item T[] copy(T[] A)
returns a deep copy of array @code{A};

@cindex @code{alias}
@item bool alias(T[] A, T[] B)
returns @code{true} if the arrays @code{A} and @code{B} are identical.

@cindex @code{sort}
@item T[] sort(T[] A)
For ordered types @code{T}, returns a copy of @code{A} sorted in
ascending order.

@item T[][] sort(T[][] A)
For ordered types @code{T}, returns a copy of @code{A} with the rows
sorted by the first column, breaking ties with successively higher
columns. For example:
@verbatim
string[][] a={{"bob","9"},{"alice","5"},{"pete","7"},
              {"alice","4"}};
write("Row sort (by column 0, using column 1 to break ties):");
write(stdout,sort(a));
@end verbatim

produces
@verbatim
alice   4
alice   5
bob     9
pete    7
@end verbatim

@cindex @code{transpose}
@item T[][] transpose(T[][] A)
returns the transpose of @code{A}.

@cindex @code{sum}
@item T sum(T[] A)
For arithmetic types @code{T}, returns the sum of @code{A}.

@cindex @code{min}
@item T min(T[] A)
For ordered types @code{T}, returns the minimum element of @code{A}.

@cindex @code{max}
@item T max(T[] A)
For ordered types @code{T}, returns the maximum element of @code{A}.

@cindex @code{eval}
@item eval(f(T), T[] A)
returns the array obtained by applying the function @code{f} to each
element of the array @code{A}.

@cindex @code{min}
@item T[] min(T[] A, T[] B)
For ordered types @code{T}, and arrays @code{A} and @code{B} of the same
length, returns an array composed of the minimum of the corresponding
elements of @code{A} and @code{B}.

@cindex @code{max}
@item T[] max(T[] A, T[] B)
For ordered types @code{T}, and arrays @code{A} and @code{B} of the same
length, returns an array composed of the maximum of the corresponding elements
of @code{A} and @code{B}.

@cindex @code{fft}
@item pair[] fft(pair[] A, int sign)
returns the Fast Fourier Transform of @code{A} (if the optional FFTW package is
installed), using the given @code{sign}. Here is a simple example:
@verbatim
int n=4;
pair[] f=sequence(n);
write(f);
pair[] g=fft(f,-1);
write();
write(g);
f=fft(g,1);
write();
write(f/n);
@end verbatim

@end table

@code{Asymptote} includes a full set of vectorized array instructions for
arithmetic (including self) and logical operations. These
element-by-element instructions are implemented in C++ code for speed. Given
@verbatim
real[] a={1,2};
real[] b={3,2};
@end verbatim

then @code{a == b} and @code{a >= 2} both evaluate to the vector
@code{@{false, true@}}. 
To test whether all components of @code{a} and @code{b} agree,
use the boolean function @code{all(a == b)}. One can also use conditionals like
@code{(a >= 2) ? a : b}, which returns the array @code{@{3,2@}}, or
@code{write((a >= 2) ? a : null}, which returns the array @code{@{2@}}.

All of the standard built-in @code{libm} functions of signature
real(real) also take a real array as an argument, effectively like an
implicit call to @code{eval}.

As with other built-in types, arrays can be read in by assignment. In this
example, the code
@verbatim
file fin=input("test.txt");
real[] A=fin;
@end verbatim

@cindex @code{eof}
@cindex @code{eol}
@cindex @code{line}
@cindex line mode
reads real values into @code{A} until the end of file is reached (or an
I/O error occurs). If line mode is set with @code{line(file)}, then
reading will stop once the end of the line is reached instead:
@verbatim
file fin=input("test.txt");
real[] A=line(fin);
@end verbatim

@cindex csv
@cindex comma-separated-value
Another useful mode is comma-separated-value mode, set with @code{csv(file)},
which skips over any comma delimiters:
@verbatim
file fin=input("test.txt");
real[] A=csv(fin);
@end verbatim

@cindex @code{dimension}
To restrict the number of values read, use the @code{dimension(file,int)}
function: 
@verbatim
file fin=input("test.txt");
real[] A=dimension(fin,10);
@end verbatim

This reads 10 values into A, unless end-of-file (or end-of-line in line mode)
occurs first. Attempting to read beyond the end of the file will produce a
runtime error message. Specifying a value of 0 for the integer limit is
equivalent to the previous example of reading until end-of-file (or
end-of-line in line mode) is encountered.

Two- and three-dimensional arrays can be read in like this:
@verbatim
file fin=input("test.txt");
real[][] A=dimension(fin,2,3);
real[][][] B=dimension(fin,2,3,4);
@end verbatim

Again, an integer limit of zero means no restriction.

@cindex @code{read1}
@cindex @code{read2}
@cindex @code{read3}
Sometimes the array dimensions are stored with the data as integer
fields at the beginning of an array. Such arrays can be read in with the
functions @code{read1}, @code{read2}, and @code{read3}, respectively:
@verbatim
file fin=input("test.txt");
real[] A=read1(fin);
real[][] B=read2(fin);
real[][][] C=read3(fin);
@end verbatim

@node Casts
@section Casts
@cindex casts
@cindex implicit casts
@cindex @code{explicit}
 
@code{Asymptote} implicitly casts @code{int} to @code{real}, @code{int} to
@code{pair}, @code{real} to @code{pair}, @code{pair} to @code{path},
@code{pair} to @code{guide}, @code{path} to @code{guide}, @code{guide}
to @code{path}, and @code{real} to @code{pen}. Implicit casts are
also automatically attempted when trying to match function calls with
possible function signatures. Implicit casting can be inhibited
by declaring individual arguments @code{explicit} in the function
signature, say to avoid an ambiguous function call in the following
example, which outputs 0:

@verbatim
int f(pair a) {return 0;}
int f(explicit real x) {return 1;}

write(f(0));
@end verbatim




@cindex explicit casts
Other conversions, say @code{real} to @code{int} or 
@code{real} to @code{string}, require an explicit cast:
@verbatim
int a=(int) 2.5;
string s=(string) 2.5;
@end verbatim

@node Import
@section Import
@cindex @code{import}
One can import other @code{Asymptote} files with the @code{import} command:
@verbatim
import graph;
@end verbatim
@cindex modules
Such @code{Asymptote} files are often called modules. 

@code{Asymptote} searches the locations listed in @ref{search paths} for the
matching file. If the file name contains nonalphanumeric characters,
enclose it with quotation marks:
@verbatim
import "/usr/local/share/asymptote/graph.asy";
@end verbatim

A variable @code{var} from a module named @code{module} can be
distinguished from a local variable of the same name by prefixing it
with the module name and a period: @code{module.var}. 

Imports within an imported module are not seen outside of that module:
even though @code{plain} imports @code{simplex}, the @code{simplex}
module will not be accessible to the file-level module, unless it is
explicitly imported. An error will be issued if one attempts to import
a module multiple times.

@cindex @code{libsigsegv}
@cindex stack overflow
Modules are allowed to recursively import themselves. Infinite
nested importing will generate a stack overflow (reported as a
segmentation fault, unless the GNU library @code{libsigsegv} is
installed at configuration time). 

Currently, the module name to be imported must be known at compile time.
However, you can execute an @code{Asymptote} file determined at runtime in an
independent process with the function
@cindex execute
@verbatim
void execute(string file);
@end verbatim

@code{Asymptote} currently ships with the following base modules:

@menu
* plain::                       Default @code{Asymptote} base file
* simplex::                     Linear programming: simplex method
* graph::                       2D linear & logarithmic graphs
* graph3d::                     Preliminary 3D projection routines
* featpost3D::                  Preliminary port of @code{featpost3d}
* math::                        Extend @code{Asymptote}'s math capabilities
* stats::                       Statistics routines and histograms
* tree::                        Dynamic binary search tree
* feynman::                     Feynman diagrams
* metapost::                    @code{MetaPost} compatibility routines
* unicode::                     Accept @code{unicode} (UTF-8) characters
* latin1::                      Accept @code{ISO 8859-1} characters
* babel::                       Implement @code{LaTeX} @code{babel} package
@end menu

@node plain
@subsection @code{plain}
@cindex @code{plain}

This is the default @code{Asymptote} base file, which defines key parts of the
drawing language (such as the @code{picture} structure).

By default, the top-level module automatically imports @code{plain};
use the @code{-noplain} command-line option to disable this feature.
In any case, no error message will be issued if one tries to explicitly
@code{import plain} (if other imported packages depend implicitly
on the presence of @code{plain}, it may be necessary to allocate it in a higher
enclosing scope by declaring the import @code{static}; @pxref{Static}).

@node simplex
@subsection @code{simplex}
@cindex @code{simplex}

This package solves the two-variable linear programming problem using the
simplex method. It is used by @code{plain} for automatic sizing of pictures.

@node graph
@subsection @code{graph}
@cindex @code{graph}
@cindex 2D graphs
This package implements two-dimensional linear and logarithmic graphs,
including automatic scale and tick selection (with the ability to
manually override). A graph is a @code{guide} (that can be drawn with
the draw command, with an optional legend) constructed with one of
the following routines: 

@itemize
@item
@verbatim
guide graph(picture pic=currentpicture, guide g=nullpath,
            real f(real), real a, real b, int n=ngraph,
            interpolate interpolatetype=LinearInterp);
@end verbatim

Returns a graph using the scaling information for picture @code{pic}
(@pxref{automatic scaling}) of the function @code{f} on the interval
[@code{a},@code{b}], sampling at @code{n} evenly spaced points, with
one of the interpolation types:
@itemize @bullet 

@cindex @code{LinearInterp}
@item @code{LinearInterp} (linear interpolation)

@cindex @code{Spline} 
@item @code{Spline} (piecewise Bezier cubic spline interpolation)

@end itemize

@item
@verbatim
guide graph(picture pic=currentpicture, guide g=nullpath,
            real x(real), real y(real), real a, real b,
            int n=ngraph, interpolate interpolatetype=LinearInterp)
@end verbatim

Returns a graph using the scaling information for picture @code{pic}
of the parametrized function
(@code{x}(@math{t}),@code{y}(@math{t})) for @math{t} in
[@code{a},@code{b}], sampling at @code{n} evenly spaced points, with
the given interpolation type.

@item
@verbatim
guide graph(picture pic=currentpicture, guide g=nullpath,
            pair z(real), real a, real b,
            int n=ngraph, interpolate interpolatetype=LinearInterp)
@end verbatim

Returns a graph using the scaling information for picture @code{pic}
of the parametrized function
@code{z}(@math{t}) for @math{t} in [@code{a},@code{b}], sampling at
@code{n} evenly spaced points, with the given interpolation type.

@item
@verbatim
guide graph(picture pic=currentpicture, guide g=nullpath,
            pair z[], bool cond[]={},
            interpolate interpolatetype=LinearInterp)
@end verbatim

Returns a graph using the scaling information for picture @code{pic}
of those elements of the array
@code{z} for which the corresponding elements of the boolean array
@code{cond} are @code{true}, with the given interpolation type.

@item
@verbatim
guide graph(picture pic=currentpicture, guide g=nullpath,
            real x[], real y[], bool cond[]={},
            interpolate interpolatetype=LinearInterp)
@end verbatim

Returns a graph using the scaling information for picture @code{pic}
of those elements of the arrays
(@code{x},@code{y}) for which the corresponding elements of the boolean array
@code{cond} are @code{true}, with the given interpolation type.

@item
@verbatim
guide graph(guide g=nullpath, real f(real), real a, real b, int n=ngraph,
            real T(real), interpolate interpolatetype=LinearInterp)
@end verbatim

Returns a graph using the scaling information for picture @code{pic}
of the function @code{f} on the interval
[@code{T}(@code{a}),@code{T}(@code{b})], sampling at @code{n} points evenly
spaced in [@code{a},@code{b}], with the given interpolation type.

@item
@verbatim
guide polargraph(guide g=nullpath, real f(real), real a, real b,
                 int n=ngraph, interpolate interpolatetype=LinearInterp)
@end verbatim

Returns a polar-coordinate graph using the scaling information for
picture @code{pic} of the function @code{f} on the interval 
[@code{a},@code{b}], sampling at @code{n} evenly spaced points, with
the given interpolation type.

@end itemize

@verbatim


@end verbatim

An axis can be drawn on a picture with one of the following commands:

@itemize

@item
@verbatim
void xaxis(picture pic=currentpicture, real xmin=-infinity,
           real xmax=infinity, pen p=currentpen, string s="",
           real position=infinity, real angle=0, pair align=0,
           pair shift=0, pair side=0, pen plabel=currentpen,
           axis axis=YZero, ticks ticks=NoTicks)
@end verbatim

Draw an @math{x} axis on picture @code{pic} from @math{x}=@code{xmin} to
@math{x}=@code{xmax} using pen @code{p}, optionally labelling it with
string @code{s} at relative location @code{position} (a real number from
[0,1]) using angle @code{angle}, alignment @code{align} (user coordinates),
true shift @code{shift} (postscript coordinates), and pen @code{plabel}.
An infinite value of @code{xmin} or @code{xmax} specifies
that the corresponding axis limit will be automatically determined from the
picture limits. The axis placement is determined by one of the
following @code{axis} types:

@table @code

@cindex @code{YZero}
@item YZero(bool extend=true)
Request an @math{x} axis at @math{y}=0 extending to the full dimensions
of the picture, unless @code{extend}=false.

@cindex @code{YEquals}
@item YEquals(real Y, bool extend=true)
Request an @math{x} axis at @math{Y}=@code{Y} extending to the full
dimensions of the picture, unless @code{extend}=false.

@cindex @code{Bottom}
@item Bottom(bool extend=false)
Request a bottom axis.

@cindex @code{Top}
@item Top(bool extend=false)
Request a top axis.

@cindex @code{BottomTop}
@item BottomTop(bool extend=false)
Request a bottom and top axis.

@end table

@cindex @code{ticks}
@cindex @code{NoTicks}
The default tick option is @code{NoTicks}. 
The option @code{LeftTicks} (@code{RightTicks}) can be used to draw
ticks on the left (right) of the path, relative to the direction in which
the path is drawn. The tick routines accept a number of optional arguments:
@verbatim
ticks LeftTicks(bool begin=true, int N=0, int n=0, real Step=0,
                real step=0, real Size=Ticksize, real size=ticksize,
                string F, bool end=true);
@end verbatim

If any of these parameters are omitted (or 0), reasonable defaults will
be chosen:
@table @code
@item begin
requests a big tick at the beginning of the axis;
@item N
when automatic scaling is enabled (the default; see @pxref{automatic scaling}),
divide the arclength evenly into this many intervals, separated by big ticks;
@item n
divide each arclength interval into this many subintervals, separated by
small ticks;
@item Step
represents the spacing (in user arclength coordinates) between big ticks
(if @code{N==0});
@item step
represents the spacing  (in user arclength coordinates) between small
ticks (if @code{n==0});
@item F
is a string used for formatting the tick values (@pxref{format});
@item end
requests a big tick at the end of the axis.
@end table

@item
@verbatim
void yaxis(picture pic=currentpicture, real ymin=-infinity,
           real ymax=infinity, pen p=currentpen, string s="",
           real position=infinity, real angle=infinity, pair align=0,
           pair shift=0, pair side=0, pen plabel=currentpen,
           axis axis=XZero, ticks ticks=NoTicks);
@end verbatim

Draw a @math{y} axis on picture @code{pic} from @math{y}=@code{ymin} to
@math{y}=@code{ymax} using pen @code{p}, optionally labelling it with
string @code{s} at relative location @code{position} (a real number from
[0,1]) using angle @code{angle}, alignment @code{align}, true shift
@code{shift}, and pen @code{plabel}.
The tick type is specified by @code{ticks} and the axis
placement is determined by one of the following @code{axis} types:

@table @code

@cindex @code{XZero}
@item XZero(bool extend=true)
Request a @math{y} axis at @math{x}=0 extending to the full dimensions
of the picture, unless @code{extend}=false.

@cindex @code{XEquals}
@item XEquals(real X, bool extend=true)
Request a @math{y} axis at @math{x}=@code{X} extending to the full
dimensions of the picture, unless @code{extend}=false.

@cindex @code{Left}
@item Left(bool extend=false)
Request a left axis.

@cindex @code{Right}
@item Right(bool extend=false) 
Request a right axis.

@cindex @code{LeftRight}
@item LeftRight(bool extend=false) 
Request a left and right axis.

@end table

@item
@verbatim
void xequals(picture pic=currentpicture, real X,
             real ymin=-infinity, real ymax=infinity, 
             real tickmin=-infinity, real tickmax=infinity,
             pen p=currentpen, string s="", real position=1,
             real angle=0, pair align=W, pair shift=0, pair side=right,
             pen plabel=currentpen, ticks ticks=NoTicks,
             int[] divisor=new int[], bool opposite=false);
@end verbatim

Draw the line @math{x}=@code{X} on picture @code{pic} from
@math{y}=@code{ymin} to @math{y}=@code{ymax}, with optional tick minimum
and maximum values @code{tickmin} and @code{tickmax}, using pen
@code{p}, optionally labelling it with string @code{s} at relative
location @code{position} (a real number from [0,1]) using angle
@code{angle}, alignment @code{align}, true shift @code{shift} on side
@code{side} of the axis, and pen @code{plabel}. The tick type is
specified by @code{ticks} and the integer array @code{divisor} specifies
what tick divisors to try for producing uncrowded tick labels. A
@code{true} value for the flag @code{opposite} identifies an unlabelled
secondary axis (typically drawn opposite to a primary axis).

@item
@verbatim
void yequals(picture pic=currentpicture, real Y,
             real xmin=-infinity, real xmax=infinity,
             real tickmin=-infinity, real tickmax=infinity,
             pen p=currentpen, string s="", real position=1,
             real angle=0, pair align=S, pair shift=0, pair side=left,
             pen plabel=currentpen, ticks ticks=NoTicks,
             int[] divisor=new int[], bool opposite=false);
@end verbatim

Like @code{xequals}, but draw the line @math{y}=@code{Y} on picture
@code{pic} from @math{x}=@code{xmin} to @math{x}=@code{xmax}.

@item
@verbatim
void axis(picture pic=currentpicture, guide g, real tickmin=-infinity,
          real tickmax=infinity, pen p=currentpen, string s="",
          real position=1, real angle=0, pair align=S, pair side=right,
          pen plabel=currentpen, ticks ticks=NoTicks,
          int[] divisor=new int[], bool logarithmic=false,
          scaleT scale=Linear, part part, bool opposite=false);
@end verbatim

This routine can be used to draw a general axis based on an arbitrary
path @code{g}, with ticks evenly spaced along its arclength.

@item These routines are useful for putting ticks and labels on axes:
@verbatim
void xtick(picture pic=currentpicture, real x, pair align=N,
	   real size=Ticksize, pen p=currentpen);
void ytick(picture pic=currentpicture, real y, pair align=E,
	   real size=Ticksize, pen p=currentpen);
void labelx(picture pic=currentpicture, string s, real x, pair align=S,
	    pair shift=infinity, pen p=currentpen);
void labely(picture pic=currentpicture, string s, real y, pair align=W,
	    pair shift=infinity, pen p=currentpen);
@end verbatim

@end itemize

Here are some simple examples of two-dimensional graphs:

@enumerate

@cindex textbook graph
@item This example draws a textbook-style graph of
@math{y=} exp@math{(x)}, with the @math{y} axis starting at @math{y=0}:
@verbatim
import graph;
size(150,0);

real f(real x) {return exp(x);}

xaxis("$x$");
yaxis(0,"$y$");

draw(graph(f,-4,2,Spline));

labely(1,E);
label("$e^x$",(1,exp(1)),SE);

shipout();
@end verbatim
@image{exp}


@item The next example draws a scientific-style graph with a legend.

@cindex scientific graph
@cindex @code{LeftTicks}
@cindex @code{RightTicks}
@verbatim
import graph;

size(300,200,IgnoreAspect);

real Sin(real t) {return sin(2pi*t);}
real Cos(real t) {return cos(2pi*t);}

draw(graph(Sin,0.01,1),red,"$\sin(2\pi x)$");
draw(graph(Cos,0.01,1),blue,"$\cos(2\pi x)$");

xaxis("$x$",BottomTop,LeftTicks);
yaxis("$y$",LeftRight,RightTicks);

shipout();

@end verbatim
@image{lineargraph}


@cindex @code{dot}
@item This example draws a graph of an array of coordinate pairs,
using the routine @code{dot} to place a dot at each node of the resulting path.
@verbatim
import graph;

size(400,200,IgnoreAspect);

pair f[]={(1,1),(50,20),(100,100)};

guide g=graph(f);
draw(g);
dot(g);

xaxis("$x$",BottomTop,LeftTicks);
yaxis("$y$",LeftRight,RightTicks);

xaxis(Dotted,YEquals(20.0,false));
yaxis(Dotted,XEquals(50.0,false));

shipout();
@end verbatim
@image{datagraph}

@item This example draws a graph of a parametrized curve. 
@cindex parametrized curve
@cindex @code{crop}
@cindex @code{limits}
@cindex @code{xlimits}
@cindex @code{ylimits}

The calls to @code{xlimits(picture pic, real min, real max)} 
and @code{ylimits(picture, real min, real max)} can be uncommented
to restrict the respective axes limits for picture @code{pic} to the
specified @code{min} and @code{max} values (alternatively, the function
@code{limits(pair, pair)} can be uncommented to limit the axes to the
box having opposite vertices at the two pairs).  The function
@code{crop(picture pic)} can then optionally be used to crop the data 
in picture @code{pic} to lie within the new axis limits.
@verbatim
import graph;

size(0,200);

real f(real t) {return cos(2pi*t);}
real g(real t) {return sin(2pi*t);}

draw(graph(f,g,0,1,LinearInterp));

//xlimits(0,1);
//ylimits(-1,0);
//crop();

xaxis("$x$",BottomTop,LeftTicks);
yaxis("$y$",LeftRight,RightTicks);

shipout();

@end verbatim
@image{parametricgraph}

@anchor{automatic scaling}
@cindex @code{scale}
@cindex @code{Linear}
@cindex @code{Log}
@cindex automatic scaling
Axis scaling can be requested and/or automatic selection of the
axis limits can be inhibited with the @code{scale} routine:
@verbatim
void scale(picture pic=currentpicture, scaleT x, scaleT y);
@end verbatim

This sets the scalings for picture @code{pic}. The @code{graph} routines
accept an optional @code{picture} argument for determining the appropriate
scalings to use; if none is given, it uses those set for @code{currentpicture}.
All path coordinates (and any call to @code{limits}, etc.)
refer to scaled data. Two frequently used scaling routines
@code{Linear} and @code{Log} are predefined in @code{graph}.

Scaling routines can be given two optional boolean arguments:
@code{automin} and @code{automax}. These default to @code{true}, but can
be set to @code{false} to disable automatic selection of "nice" axis
minimum and maximum values. @code{Linear} can also take as an optional
final argument a multiplicative scaling factor (e.g. for a depth axis,
@code{Linear(-1)} requests axis reversal). 

@cindex logarithmic graph
@cindex log-log graph
For example, to draw a log graph of a function, use @code{scale(Log,Log)}:
@verbatim
import graph;

size(200,200,IgnoreAspect);

real f(real t) {return 1/t;}

scale(Log,Log);

draw(graph(f,0.1,10));

//xlimits(0,1);
//ylimits(-1,0);
//crop();

xaxis("$x$",BottomTop,LeftTicks);
yaxis("$y$",LeftRight,RightTicks);

shipout();
@end verbatim
@image{loggraph}

@item @code{Asymptote} also provides a means for drawing a secondary
linear axis:
@cindex secondary axis
@cindex @code{secondaryX}
@cindex @code{secondaryY}
@verbatim
import graph;

size(9cm,6cm,IgnoreAspect);
string data="secondaryaxis.csv";

file in=line(csv(input(data)));

string[] titlelabel=in;
string[] columnlabel=in;

real[][] a=dimension(in,0,0);
a=transpose(a);
real[] t=a[0], susceptible=a[1], infectious=a[2], dead=a[3], larvae=a[4];
real[] susceptibleM=a[5], exposed=a[6],infectiousM=a[7];

draw(graph(t,susceptible,t <= 20),solid);
draw(graph(t,dead,t <= 20),dashed);

xaxis("Time ($\tau$)",BottomTop,LeftTicks(5.0));
yaxis(Left,RightTicks);

picture secondary=secondaryY(new void(picture pic) {
  draw(pic,graph(pic,t,infectious,t <= 20),red+solid);
});
			     
yaxis(secondary,black,red,Right,LeftTicks(2));
add(secondary);

label("Proportion of crows",point(NW),E,5mm*N);

shipout();
@end verbatim
@image{secondaryaxis}

@item Here is an example that illustrates the general @code{axis} routine.
@cindex @code{axis}
@verbatim
import graph;
size(0,100);

guide g=ellipse((0,0),100,200);
axis(g,0,0.5*arclength(g),RightTicks(8,"%.0f"),Angle);
shipout();
@end verbatim
@image{generalaxis}

@item The following scientific graphs, which illustrate many features of
@code{Asymptote}'s graphics routines, were generated from
@code{diatom.asy} and @code{westnile.asy} (in the @code{doc}
directory), using the comma-separated data in @code{diatom.csv}
and @code{westnile.csv}.

@image{diatom}
@image{westnile,,7.5cm}

@end enumerate

@node graph3d
@subsection @code{graph3d}
@cindex @code{graph3d}
@cindex 3D graphs
@cindex hidden surface removal
This module will be developed into a full three-dimensional graphics package
in a future release. The file @code{planes.asy} in the examples
directory illustrates how clipping can be used to implement hidden
surface removal in 3d vector graphics. Perspective has not yet been
added (but can be easily implemented using similar triangles). 
@xref{featpost3D}.

@node featpost3D
@subsection @code{featpost3D}
@cindex @code{featpost3D}
Until a complete 3d graphics package (@pxref{graph3d}) is written, a
preliminary port of the the @code{MetaPost} 3d package @code{featpost3D} 
of L. Nobre G., C. Barbarosie and J. Schwaiger to @code{Asymptote}
makes some 3d functionality already available, as illustrated by the
examples @code{nearearth} and @code{conicurv}.

@node math
@subsection @code{math}
@cindex @code{math}
This package extends @code{Asymptote}'s mathematical capabilities with
radian/degree conversion routines, point-in-polygon and intersection
algorithms, 3D vectors, and matrices.

@cindex @code{implicit linear solver}
@cindex @code{MetaPost whatever}
@cindex @code{extension}
Unlike @code{MetaPost}, @code{Asymptote} does not solve linear equations
implicitly and does not have the notion of a @code{whatever} unknown.
The following routine provides a useful replacement for a common use of
these facilities: finding intersection points of the extensions of the
sides of a triangle:

@table @code

@item pair extension(pair P, pair Q, pair p, pair q);
Return the intersection point of the extensions of the line segments 
@code{PQ} and @code{pq}.

@end table

Here are some additional routines provided in the @code{math} package:

@table @code

@cindex @code{straight}
@item bool straight(path p)
returns @code{true} iff the path @code{p} is straight.

@cindex @code{intersection}
@item real intersection(vector P, vector Q, vector n, vector Z);
Return the intersection time of the extension of the line segment @code{PQ}
with the plane perpendicular to vector @code{n} and passing through @code{Z}.

@cindex @code{intersection}
@item vector intersectionpoint(vector n0, vector P0, vector n1, vector P1);
Return any point on the intersection of the two planes with normals
@code{n0} and @code{n1} passing through points @code{P0} and @code{P1},
respectively. If the planes are parallel, return
@code{vector(infinity,infinity,infinity)}.

@end table

@node stats
@subsection @code{stats}
@cindex @code{stats}
This package implements a Gaussian random number generator
and a collection of statistics routines, including @code{histogram}.

@node tree
@subsection @code{tree}
@cindex @code{tree}
This package implements a dynamic binary search tree.

@node feynman
@subsection @code{feynman}
@cindex @code{feynman}
This package, contributed by Martin Wiebusch, is useful for drawing
Feynman diagrams, as illustrated by the examples @code{eetomumu.asy}
and @code{fermi.asy}.

@node metapost
@subsection @code{metapost}
@cindex @code{metapost}
This package provides some useful routines to help @code{MetaPost} users
migrate old @code{MetaPost} code to @code{Asymptote}.

@node unicode
@subsection @code{unicode}
@cindex @code{unicode}
Import this package at the beginning of the file to instruct
@code{LaTeX} to accept @code{unicode} (UTF-8) standardized international
characters. You will also need to set up @code{LaTeX} support for
@code{unicode} by unpacking in your @code{LaTeX} source directory
(e.g. @code{/usr/share/texmf/tex/latex}) the file
@verbatim
http://www.unruh.de/DniQ/latex/unicode/unicode.tgz
@end verbatim

and then running the command 
@verbatim
texhash
@end verbatim

@node latin1
@subsection @code{latin1}
@cindex @code{latin1}
If you don't have @code{LaTeX} support for @code{unicode} installed,
you can enable support for Western European languages (ISO 8859-1) by
importing the module @code{latin1}. This module can be used as a
template for providing support for other ISO 8859 alphabets.

@node babel
@subsection @code{babel}
@cindex @code{babel}
This module implements the @code{LaTeX} @code{babel} package in
@code{Asymptote}. For example:
@verbatim
import babel;
babel("german");
@end verbatim

@node Static
@section Static
@cindex @code{static}

Static qualifiers allocate the memory address of a variable in a higher 
enclosing scope.

For a function body, the variable is allocated in the block where the
function is defined; so in the code
@verbatim
struct s {
  int count() {
    static int c=0;
    ++c;
    return c;
  }
}
@end verbatim

there is one instance of the variable @code{c} for each object @code{s}
(as opposed for each call of @code{count}). 

Similarly, in
@verbatim
int factorial(int n) {
  int helper(int k) {
    static int x=1;
    x *= k;
    return k == 1 ? x : helper(k-1);
  }
  return helper(n);
}
@end verbatim

there is one instance of @code{x} for every call to @code{factorial} (and not
for every call to @code{helper}), so this is a correct, but ugly,
implementation of factorial.

Similarly, a static variable declared within a structure is allocated in
the block where the structure is defined. Thus,
@verbatim
struct A {
  struct B {
    static pair z;
  }
}
@end verbatim

creates one object @code{z} for each object of type @code{A} created.

In this example,
@verbatim
int pow(int n, int k) {
  struct A {
    static int x=1;
    void helper() {
      x *= n;
    }
  }
  for (int i=0; i < k; ++i) {
    A a=new A;
    a.helper();
  }
  return A.x;
}
@end verbatim

there is one instance of @code{x} for each call to @code{pow}, so this
is an ugly implementation of exponentiation.

A file-level module is really just a structure, so a file @code{stuff.asy}
containing
@verbatim
import other;
public int x=5;
int y=x*4;
int sqr(int x) {return x*x;}
@end verbatim

is in some way equivalent to
@verbatim
struct stuff {
  import other;
  public int x=5;
  int y=x*4;
  int sqr(int x) { return x*x; }
}
@end verbatim

@cindex @code{import}
When you @code{import} a module, it is like creating a new instance of
the struct. That is,
@verbatim
int cube(int x) {
  import stuff;
  return x*sqr(x);
}
@end verbatim

is essentially equivalent to
@verbatim
int cube(int x) {
  stuff s=new stuff;
  return x*s.sqr(x);
}
@end verbatim

If you use static functions and variables from a module, then every
import is referring to the same data. But every import of a module gets
a different instance of its dynamic variables.

Declarations are dynamic by default. Suppose @code{X.asy} contains
@verbatim
public int x=0;
@end verbatim

and @code{inc.asy} contains
@verbatim
import X;
void inc() {++x;}
@end verbatim

Then the file @code{test.asy}:
@verbatim
import X;
import inc;
write(x);
inc();
write(x);
@end verbatim

should write 0 twice, because the variable @code{x} imported in
@code{inc.asy} is distinct from the variable @code{x} imported directly
from @code{X.asy}.

If @code{inc.asy} were to contain only
@verbatim
void inc() {++x;}
@end verbatim

then, in order for it to be able to access the variable @code{x} in
@code{X.asy}, one needs to allocate @code{X.asy} in a higher
enclosing block by making its import @code{static} in @code{test.asy}:
@verbatim
static import x;
import inc;
write(x);
inc();
write(x);
@end verbatim

This writes first 0 and then 1.

@node Drawing commands
@chapter Drawing commands
@cindex drawing commands
@cindex @code{layer}

All of @code{Asymptote}'s graphical capabilities are based on four primitive
commands. The three @code{PostScript} drawing commands @code{draw},
@code{fill}, and @code{clip} add objects to a picture in the order in
which they are executed, with the most recently drawn object appearing on top.
The @code{LaTeX} labeling command @code{label} adds text labels, which will
appear on top of the @code{PostScript} objects (since this is normally what one
wants), but again in the relative order in which they were executed.
After drawing objects on a picture, the picture needs to be output with
the @code{shipout} function (@pxref{shipout}).

If you wish to draw @code{PostScript} objects on top of labels (or verbatim
@code{tex} commands; see @pxref{tex}), the @code{layer} command may be
used to start a
new @code{PostScript/LaTeX} layer:
@verbatim
void layer(picture pic=currentpicture);
@end verbatim

The @code{layer} function gives one full control over the order in which
objects are drawn. Layers are drawn sequentially, with the most recent
layer appearing on top. Within each layer, labels and verbatim @code{tex}
commands are always drawn after the @code{PostScript} objects in that layer.

While some of these drawing commands take many options, they all have sensible
default values (for example, the picture argument defaults to
currentpicture):

@enumerate
@cindex legend
@cindex @code{draw}
@item
@verbatim 
void draw(picture pic=currentpicture, string s="", real angle=0,
          path g, real position=0.5*length(g), pair align=0,
          pair shift=0, side side=RightSide, pen p=currentpen,
          arrowbar arrow=None, arrowbar bar=None, string legend="");
@end verbatim

Draw the path @code{g} on the picture @code{pic}, optionally labeled by
string @code{s} writing at angle @code{angle} (in degrees) at position
@code{position} and aligned using the pair @code{align} (or, if zero,
aligned on side @code{side}) and true shift @code{shift}, using pen
@code{p} and other optional drawing attributes (arrows, bars, legend). Only one
parameter, the path, is required. For convenience, the arguments
@code{arrow} and @code{bar} may be specified in either order. The final
argument, @code{legend}, is a string to use in constructing an optional
legend entry.

@cindex @code{LeftSide}
@cindex @code{Center}
@cindex @code{RightSide}
The possible values of @code{side} are @code{LeftSide}, @code{Center}, and
@code{RightSide}. This parameter specifies the location of the path
label relative to the direction in which the path is drawn. The value of
@code{side} is ignored if @code{align} is nonzero or if @code{position}
corresponds to an endpoint of the path @code{g}.

@cindex @code{None}
@cindex @code{BeginBar}
@cindex @code{EndBar}
@cindex @code{Bar}
@cindex @code{Bars}
The possible values of @code{bar} are @code{None}, @code{BeginBar},
@code{EndBar} (or equivalently @code{Bar}), and @code{Bars} 
(which draws a bar at both ends of the path). These are useful for
indicating dimensions. Each of these bar specifiers take a single
optional real argument that denotes the length of the bar in @code{PostScript}
coordinates. 

@cindex @code{None}
@cindex @code{BeginArrow}
@cindex @code{EndArrow}
@cindex @code{Arrow}
@cindex @code{Arrows}
@cindex @code{Fill}
@cindex @code{NoFill}
@cindex @code{BeginArcArrow}
@cindex @code{EndArcArrow}
@cindex @code{ArcArrow}
@cindex @code{ArcArrows}
The possible values of @code{arrow} are @code{None}, @code{BeginArrow},
@code{EndArrow} (or equivalently @code{Arrow}), and @code{Arrows} 
(which draws an arrow at both ends of the path).
Each of these arrow specifiers may be given the optional arguments real
@code{size} (in @code{PostScript} coordinates), real @code{angle} (in degrees),
@code{Fill} or @code{NoFill}, and a relative real position along the
path from 0 to 1 where the tip of the arrow should be placed. There are
also arrow versions with slightly modified default values of @code{size} and
@code{angle} suitable for curved arrows: @code{BeginArcArrow},
@code{EndArcArrow} (or equivalently @code{ArcArrow}), and @code{ArcArrows}.

Two examples illustrating the use of arrows and bars are
@code{Pythagoras.asy} and @code{triads.asy} in the examples
(by default @code{/usr/local/share/doc/asymptote}).

@cindex @code{dot}
To draw a dot, simply draw a path containing a single point.
The @code{dot} command defined in @code{plain.asy} draws a dot with the
diameter given by either the default linewidth magnified by @code{dotfactor}
(6 by default) or an explicit pen linewidth. If no pen argument is given,
@code{currentpen}, with its linewidth magnified by @code{dotfactor}, is used:
@verbatim
void dot(picture pic=currentpicture, pair c);
void dot(picture pic=currentpicture, pair c, pen p);
@end verbatim

To draw a fixed-sized object (in @code{PostScript} coordinates) about the user
coordinate @code{origin}, use the routine

@cindex @code{drawabout}
@verbatim
void drawabout(pair origin, picture pic=currentpicture, string s="",
               real angle=0, path g, real position=0.5*length(g),
               pair align=0, pair shift=0, side side=RightSide,
               pen p=currentpen, arrowbar arrow=None, arrowbar bar=None);
@end verbatim


@item
@cindex @code{fill}
@anchor{gradient shading}
@cindex gradient
@cindex shading
@verbatim
void fill(picture pic=currentpicture, path g,
pen pena=currentpen, pair a=0, real ra=0,
pen penb=currentpen, pair b=0, real rb=0);
@end verbatim

Fill the interior region bounded by the cyclic path @code{g} on the picture
@code{pic}, using the pen @code{pena}. 

Gradient shading requires that @code{pena} and @code{penb} contain
distinct colors (not patterns).  
If @code{a} != @code{b} and @code{ra}=@code{rb}=0, fill with a color
gradient varying smoothly from @code{pena} to @code{penb} in the
direction of the line segment @code{a--b}.  
If @code{ra} != 0 or @code{rb} != 0, fill with a color gradient varying
smoothly from @code{pena} on the circle with center @code{a} and radius
@code{ra} to @code{penb} on the circle with center @code{b} and radius
@code{rb}: 

@verbatim
size(100,0);
fill(unitsquare,yellow,(0,0),0,red,(0,0),1);
shipout();
@end verbatim

@image{shade}

@cindex @code{filldraw}
There is also a convenient @code{filldraw} command, which fills the path
and then draws in the boundary. One can specify separate pens for each
operation:
@verbatim
void filldraw(picture pic=currentpicture, path g, pen pena=currentpen,
              pen drawpen=currentpen, pair a=0, real ra=0,
	      pen penb=currentpen, pair b=0, real rb=0)
@end verbatim

@cindex @code{fillabout}
@cindex @code{filldrawabout}
There are also fixed-size routines analogous to @code{drawabout}:
@code{fillabout} and @code{filldrawabout} allow one to fill a
object described in @code{PostScript} coordinates about a user coordinate.

@cindex unfill
To unfill a region, simply fill it with the background colour (typically
white).

@item
@cindex @code{clip}
@verbatim 
void clip(picture pic=currentpicture, path g);
@end verbatim

Clip picture @code{pic} to the region bounded by the path @code{g}.
For an illustration of picture clipping, see the first example in
@ref{LaTeX usage}.

@item
@cindex @code{label}
@verbatim
void label(picture pic=currentpicture, string s, real angle=0,
           pair position, pair align=0, pair shift=0, pen p=currentpen);
@end verbatim

Draw label @code{s} on @code{pic}, writing at angle @code{angle} (in
degrees), at coordinate @code{position}, aligned with the vector
@code{align} and true shift @code{shift}, with pen @code{p}.

A label with an arrow can be produced with one of the following routines:
@cindex @code{arrow}
@verbatim
void arrow(picture pic=currentpicture, string s="", real angle=0,
           pair b, pair align, real length=arrowlength, pair shift=0,
           pen p=currentpen, real size=arrowsize, real Angle=arrowangle,
           arrowhead arrowhead=Fill);

void arrow(picture pic=currentpicture, string s, real angle=0,
           pair shift=0, path g, pen p=currentpen, real size=arrowsize,
           real Angle=arrowangle, arrowhead arrowhead=Fill);
@end verbatim

@cindex @code{minipage}
The @code{minipage(string s, width=100pt)} routine can be used to format
string @code{s} into a paragraph of width @code{width}, as illustrated
in the following example:

@verbatim
size(9cm,10cm,IgnoreAspect);

pair d=(1,0.25);
real s=1.6d.x;
real y=0.6;
defaultfontsize(8);

picture box(string s, pair z=(0,0)) {
  picture pic=new picture;
  draw(pic,box(-d/2,d/2));
  label(pic,s,(0,0));
  return shift(z)*pic;
}

label("Birds",(0,y));
picture removed=box("Removed ($R_B$)");
picture infectious=box("Infectious ($I_B$)",(0,-1.5));
picture susceptible=box("Susceptible ($S_B$)",(0,-3));

add(removed);
add(infectious);
add(susceptible);

label("Mosquitoes",(s,y));
picture larval=box("Larval ($L_M$)",(s,0));
picture susceptibleM=box("Susceptible ($S_M$)",(s,-1));
picture exposed=box("Exposed ($E_M$)",(s,-2));
picture infectiousM=box("Infectious ($I_M$)",(s,-3));

add(larval);
add(susceptibleM);
add(exposed);
add(infectiousM);

path ls=point(larval,S)--point(susceptibleM,N);
path se=point(susceptibleM,S)--point(exposed,N);
path ei=point(exposed,S)--point(infectiousM,N);
path si=point(susceptible,N)--point(infectious,S);

draw(minipage("\flushright{recovery rate ($g$) \& death rate from virus
($\mu_V$)}",40pt),point(infectious,N)--point(removed,S),LeftSide,Arrow);

draw(si,LeftSide,Arrow);

draw(minipage("\flushright{maturation rate ($m$)}",50pt),ls,RightSide,
Arrow);
draw(minipage("\flushright{viral incubation rate ($k$)}",40pt),ei,
RightSide,Arrow);

path ise=point(infectious,E)--point(se,0.5);
  
draw("$(ac)$",ise,LeftSide,dashed,Arrow);
label(minipage("\flushleft{biting rate $\times$ transmission
probability}",50pt),point(infectious,SE),dir(-60)+S);

path isi=point(infectiousM,W)--point(si,2.0/3);

draw("$(ab)$",isi,LeftSide,dashed,Arrow);
draw(se,LeftSide,Arrow);
      
real t=2.0;
draw("$\beta_M$",
     point(susceptibleM,E){right}..tension t..{left}point(larval,E),
     2*(S+SE),red,Arrow(Fill,0.5));
draw(minipage("\flushleft{birth rate ($\beta_M$)}",20pt),
     point(exposed,E){right}..tension t..{left}point(larval,E),2SW,red,
     Arrow(Fill,0.5));
draw("$\beta_M$",
     point(infectiousM,E){right}..tension t..{left}point(larval,E),2SW,
     red,Arrow(Fill,0.5));

path arrow=(0,0)--0.75cm*dir(35);
drawabout(point(larval,NNE),
	  minipage("\flushleft{larval death rate ($\mu_L$)}",45pt),
	  arrow,1,blue,Arrow);
drawabout(point(susceptibleM,NNE),
          minipage("\flushleft{adult death rate ($\mu_A$)}",20pt),
	  arrow,1,N,blue,Arrow);
drawabout(point(exposed,NNE),"$\mu_A$",arrow,1,blue,Arrow);
drawabout(point(infectiousM,NNE),"$\mu_A$",arrow,1,blue,Arrow);

shipout();
@end verbatim

@image{mosquito}

One can prevent labels from overwriting one another with the
@code{overwrite} pen attribute (@pxref{overwrite}).

@end enumerate

@node LaTeX usage
@chapter @code{LaTeX} usage
@cindex @code{LaTeX} usage
@cindex @code{asymptote.sty}

@code{Asymptote} comes with a convenient @code{LaTeX} style file
@code{asymptote.sty} (in the directory @code{doc} in the
@code{Asymptote} source) that makes @code{LaTeX}
@code{Asymptote}-aware. Entering @code{Asymptote} code
directly into the @code{LaTeX} source file, at the point where it is
needed, keeps figures organized and avoids the need to invent new file
names for each figure.

For example, the sample @code{LaTeX} file below, named
@code{latexusage.tex}, can be run as follows:
@verbatim
latex latexusage
asy latexusage
latex latexusage
@end verbatim

Here now is @code{latexusage.tex} (from the @code{doc} directory of
the @code{Asymptote} source):
@verbatim
\documentclass[12pt]{article}
\usepackage{asymptote}
\begin{document}
\begin{asydef}
// Global definitions can be put here.
\end{asydef}

Here is a figure produced with Asymptote, drawn to width 5cm:

\begin{center}
\begin{asy}
size(5cm,0);
pen colour1=red;
pen colour2=green;

pair z0=(0,0);
pair z1=(-1,0);
pair z2=(1,0);
real r=1.5;
guide c1=circle(z1,r);
guide c2=circle(z2,r);
fill(c1,colour1);
fill(c2,colour2);

picture intersection=new picture;
fill(intersection,c1,colour1+colour2);
clip(intersection,c2);

add(intersection);

draw(c1);
draw(c2);

label("$A$",z1);
label("$B$",z2);

pair z=(0,-2);
real e=0.85;
arrow("$A\cap B$",subpath((0,2)--z0,0,e));
arrow("$A\cup B$",subpath(z--z0,0,e));
draw(subpath(z--z1,0,e),Arrow);
draw(subpath(z--z2,0,e),Arrow);
shipout(bbox(0.25cm));
\end{asy}
\end{center}

Each graph is drawn in its own environment. One can specify the width
and height to \LaTeX\ explicitly:

\begin{center}
\begin{asy}[3cm,0]
guide center = (0,1){W}..tension 0.8..(0,0){(1,-.5)}..tension 0.8..{W}(0,-1); 

draw((0,1)..(-1,0)..(0,-1));
filldraw(center{E}..{N}(1,0)..{W}cycle);
fill(circle((0,0.5),0.125),white);
fill(circle((0,-0.5),0.125));
shipout();
\end{asy}
\end{center}

The default width is the full line width:

\begin{center}
\begin{asy}
import graph;
real f(real x) {return sqrt(x);}
pair F(real x) {return (x,f(x));}

real g(real x) {return -sqrt(x);}
pair G(real x) {return (x,g(x));}

guide p=(0,0)--graph(f,0,1,100,Spline)--(1,0);
guide h=p--cycle;
fill(h,lightgray);
draw((0,0)--graph(g,0,1,100,Spline)--(1,0),dotted);

draw(p);

real x=0.5;
pair c=(4,0);
draw(F(x)--c+(0,f(x)),dashed+red);
draw(G(x)--c+(0,g(x)),dashed+red);

arrow("$y=\sqrt{x}$",F(0.7),N);

transform T=xscale(0.5);
drawabout((2.72,0),T*arc(0,0.30cm,20,340),ArcArrow);

labeldot((1,1));

fill(shift(c)*T*circle(0,-f(x)),red+white);
arrow((3,0.5*f(x)),W,1cm,red);
arrow((3,-0.5*f(x)),W,1cm,red);

xaxis(0,c.x,dashed,"$x$");
yaxis("$y$");

draw("$r$",(x,0)--F(x),E,red,Arrows,BeginBar);
draw("$r$",(x,0)--G(x),E,red,Arrows,BeginBar);
draw("$r$",c--c+(0,f(x)),Arrow);
dot(c);
shipout();
\end{asy}
\end{center}

\end{document}

@end verbatim
@page
@image{latexusage,,26cm}

@node Options
@chapter Options
@cindex options
Type @code{asy -h} to see the full list of command line options
supported by @code{Asymptote}:
@verbatim
Usage: asy [options] [file ...]

Options: 

-V, -View        View output file
-x magnification Deconstruct into transparent GIF objects
-c               Clear GUI operations
-i               Ignore GUI operations
-f format        Convert each output file to specified format
-o name          (First) output file name
-h, -help        Show summary of options
-O pair          PostScript offset
-C               Center on page (default)
-B               Align to bottom-left corner of page
-T               Align to top-left corner of page
-Z               Position origin at (0,0) (implies -L)
-v, -verbose     Increase verbosity level
-k               Keep intermediate files
-L               Disable LaTeX label postprocessing
-p               Parse test
-s               Translate test
-m               Mask fpu exceptions (on supported architectures)
-nomask          Don't mask fpu exceptions (default)
-cmyk            Convert rgb colors to cmyk
-rgb             Convert cmyk colors to rgb
-safe            Disable system call (default)
-unsafe          Enable system call
-noplain         Disable automatic importing of plain
@end verbatim

If no arguments are given, @code{Asymptote} runs in interactive mode
(@pxref{Interactive mode}).

If @code{-} is given as the file argument, @code{Asymptote} reads from
standard input. 

If multiple files are specified, they are treated as separate
@code{Asymptote} runs.

An alternative output format may be produced by using the @code{-f format}
option. This supports any format supported by the @code{ImageMagick}
@code{convert} program (a relatively recent version of which must be
installed). @code{ImageMagick} should be configured with @code{--enable-lzw} to
produce @acronym{LZW}-compressed @acronym{GIF}s (the @acronym{Unisys LZW}
patent expired on June 20, 2003).

If the option @code{-unsafe} is given, @code{Asymptote} runs
in unsafe mode. This enables the @code{int system(string)} call, allowing one
to execute arbitrary shell commands. The default mode, @code{-safe},
disables this call. 

@cindex @code{ASYMPTOTE_PAPERTYPE}
By default, @code{Asymptote} attempts to center the figure on the
page, assuming that the paper type is @code{letter}. The default paper
type may be changed to @code{a4} with the environment variable
@code{ASYMPTOTE_PAPERTYPE}. Currently only these two paper types are
supported. Note that adding a new type, say @code{poster}, will also
require defining @code{posterSize} in the dvips configuration file.

@cindex offset
A @code{PostScript} offset may be specified as a pair (in bp units) with the
-O option:
@verbatim
asy -O 0,0 file
@end verbatim

The default offset is zero. The offset is adjusted if it would result in
a negative vertical bounding box coordinate.

Additional debugging output is produced with each additional @code{-v} option:
@table @code
@item -v
Display top-level module and final output file names.
@item -vv
Also display imported module names and final @code{LaTeX} and
@code{dvips} processing information.
@item -vvv
Also output @code{LaTeX} bidirectional pipe diagnostics.
@item -vvvv
Also output knot solver diagnostics.
@item -vvvvv
Also output Asymptote traceback diagnostics.
@end table

@node Interactive mode
@chapter Interactive mode
@cindex interactive mode
Because @code{Asymptote} as currently designed does not natively support
a line-at-a-time mode, interactive mode is currently simulated by
rerunning all previous commands in a new module as each line is entered.
This emulation will eventually become unnecessary, once
@code{Asymptote}'s module handling is redesigned to support
incremental input.

In interactive mode, it is not necessary to type a semicolon at the end
of each line; one will automatically be appended. It is
also not necessary to end your commands with @code{shipout()}, as a
@code{shipout()} command is automatically appended as each line is
entered. If you type in a command like @code{size(100,100)} on the first line,
you will get two innocuous warning messages "warning: scaling in picture
unbounded" since the current picture, being still empty, cannot be
scaled to achieve the requested size.

The following special commands are supported only in interactive mode:

@table @code
@item quit
exits interactive mode
@item redraw
refreshes the screen
@item reset
resets @code{Asymptote} to its initial state on entry, before any
commands were typed.
@item input FILE
directly inputs code from an existing file @code{FILE} into @code{Asymptote},
after first doing an interactive @code{reset}. 
@end table

@node GUI
@chapter Graphical User Interface
@cindex graphical user interface
@cindex GUI
@cindex mouse
@cindex wheel mouse
@cindex @code{Button-1}
@cindex @code{Button-2}
@cindex @code{xasy}

In the event that adjustments to the final figure are required, the
Graphical User Interface @code{xasy} included with @code{Asymptote}
allows you to move graphical objects around with mouse @code{Button-1}. 
The modified layout can be written to disk with the @code{w} key in a form
readable to @code{Asymptote}.
A wheel mouse is convenient for raising and lowering objects, to expose
the object to be moved. If a wheel mouse is not available, mouse
@code{Button-2} (lower) can be used repeatedly instead. Here are the
currently defined key mappings: 

@table @code
@item z
undo
@item r
redo
@item <Delete>
delete
@item w
write
@item q
quit
@end table

One can also draw connected line segments by holding down the shift key
and pressing mouse @code{Button-1} at each desired node.  Releasing the shift
key ends the definition of the path. More features will be added to
this preliminary GUI soon.

As @code{xasy} is written in the interactive scripting language
Python/TK, it requires that both Python and the @code{tkinter} package be
installed. To use @code{xasy}, one must first deconstruct
@code{Asymptote} pictures into transparent @acronym{GIF} images with the
command @code{asy -xN}, where @code{N} denotes the magnification (say 2). 
The command @code{asy -VxN} automatically invokes @code{xasy} once
deconstruction is complete.

A good example of how deconstruction of compound objects (e.g. arrows) can
be prevented is in the example @code{yingyang.asy}. By default, only
currentpicture does automatic deconstruction of its objects.

@node Help
@chapter Help
@cindex help
@cindex mailing list
Questions on installing and using Asymptote should be posted to the
@code{Asymptote} mailing list:
@verbatim
https://lists.sourceforge.net/lists/listinfo/asymptote-discuss
@end verbatim

@cindex bug reports
If you find a bug in Asymptote, please check (if possible) whether the bug
is still present in the latest CVS version before submitting a bug report.
New bugs can be submitted using the Bug Tracking System at
@verbatim
http://sourceforge.net/projects/asymptote
@end verbatim

@cindex stack overflow
@cindex segmentation fault
@cindex @code{libsigsegv}
@code{Asymptote} can be configured with the optional GNU library
@code{libsigsegv}, available from
@code{http://libsigsegv.sourceforge.net}, which allows one to distinguish
user-generated @code{Asymptote} stack overflows (@pxref{stack overflow})
from true segmentation faults (due to internal C++ programming errors;
please submit the @code{Asymptote} code that generates such segmentation
faults along with your bug report). 

@node Credits
@chapter Acknowledgments
@cindex acknowledgments

Financial support for the development of @code{Asymptote} was generously
provided by the Natural Sciences and Engineering Research Council of
Canada, the Pacific Institute for Mathematical Sciences, and the 
University of Alberta Faculty of Science.
     
We also would like to acknowledge the previous work of John D. Hobby, 
author of the program @code{MetaPost} that inspired the development of
@code{Asymptote}, and Donald E. Knuth, author of @TeX{} and
@code{MetaFont} (on which @code{MetaPost} is based).

The authors of @code{Asymptote} are Andy Hammerlindl, John Bowman, and
Tom Prince. Sean Healy designed the @code{Asymptote} logo.

@node Index
@unnumbered Index
     
@printindex cp
     
@bye

@c  LocalWords:  randMax Gaussrand asy cindex indices resized LaTeX TK latin au
@c  LocalWords:  latexusage tex bbox PostScript subdirectory gcc emacs ASYDIR
@c  LocalWords:  documentclass usepackage asydef colour subpath shipout sqrt xN
@c  LocalWords:  xscale labeldot xaxis yaxis BeginBar GIF postprocessing fpu de
@c  LocalWords:  nomask noplain ImageMagick defaultfontsize defaultlinewidth cd
@c  LocalWords:  startup natively xasy tkinter VxN yingyang currentpicture toc
@c  LocalWords:  MetaPost MetaFont Hammerlindl Healy texinfo autoload setq setf
@c  LocalWords:  printindex setfilename settitle dircategory direntry titlepage
@c  LocalWords:  vskip filll insertcopying ifnottex detailmenu alist augroup PQ
@c  LocalWords:  bool behaviour facto zxf cvs login Debian dev filetypedetect
@c  LocalWords:  libboost FFTW bp readline gv eps gifmerge wheelanimation args
@c  LocalWords:  boolean initializer expi dir xpart ypart STL substring rfind
@c  LocalWords:  pos substr strftime typedef pxref unitcircle yscale Bezier iff
@c  LocalWords:  postcontrol precontrol atleast nullpath arclength arctime rgb
@c  LocalWords:  dirtime currentpen colorspaces grayscale cmyk defaultpen xsize
@c  LocalWords:  linetype longdashed dashdotted longdashdotted linewidth ysize
@c  LocalWords:  fontsize defaultfilename keepAspect IgnoreAspect ise flushleft
@c  LocalWords:  NoWait src dest XDR txt getc fout stdin stdout endl xinput eof
@c  LocalWords:  xoutput Microsystem's eol struct exponentials postfix sayhi th
@c  LocalWords:  sqr intop addby libm asin acos atan sinh tanh asinh acosh cbrt
@c  LocalWords:  atanh fabs hypot fmod drem ceil srand dereferenced alice pete
@c  LocalWords:  eval fft csv runtime nonalphanumeric labely LeftTicks NoTicks
@c  LocalWords:  RightTicks BottomTop LeftRight Ticksize UTF BufNewFile BufRead
@c  LocalWords:  ticksize subintervals xlimits filetype plugin setlocal makeprg
@c  LocalWords:  ylimits uncommented LinearInterp automin automax cp uninstall
@c  LocalWords:  scaleT Xautomin Xautomax Yautomin Yautomax unicode RightSide
@c  LocalWords:  arrowbar LeftSide EndBar BeginArrow lly featpost feynman isi
@c  LocalWords:  EndArrow BeginArcArrow EndArcArrow ArcArrow ArcArrows NoFill
@c  LocalWords:  filldraw fillpen drawpen errorformat bigsquare bezier darkblue
@c  LocalWords:  quartercircle darkgreen lightblue urx ury texpreamble sgn texi
@c  LocalWords:  lineargraph datagraph vertices parametricgraph uncomment ggv
@c  LocalWords:  loggraph generalaxis texhash arrowsize arrowangle arrowlength
@c  LocalWords:  SuppressQuiet MoveQuiet LIBREADLINE config PSVIEWER PDFVIEWER
@c  LocalWords:  ghostview gsview SIGHUP PDF acroread xpdf nullframe cutbefore
@c  LocalWords:  libsigsegv intersectionpoint dotfactor lzw GIFS vv firstcut pq
@c  LocalWords:  Unisys dvips vvv vvvv vvvvv traceback lastcut cutafter infodir
@c  LocalWords:  zxvf xargs cond polargraph xmin xmax plabel YZero labelling ln
@c  LocalWords:  ymin ymax XZero xequals tickmin tickmax unlabelled se pq pena
@c  LocalWords:  yequals Nobre Barbarosie Schwaiger nearearth conicurv Wiebusch
@c  LocalWords:  unfill PAPERTYPE posterSize ngraph interpolatetype drawabout
@c  LocalWords:  NNE jxf linecap linejoin unitsquare shadedtiling addabout ei
@c  LocalWords:  westnile fillabout filldrawabout minipage infectiousM ra penb
@c  LocalWords:  susceptibleM si flushright secondaryX secondaryY secondaryaxis
@c  LocalWords:  titlelabel columnlabel rb xtick ytick labelx
