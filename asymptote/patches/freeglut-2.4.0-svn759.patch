diff -ruN freeglut-2.4.0/ChangeLog freeglut-2.4.0-svn759/ChangeLog
--- freeglut-2.4.0/ChangeLog	2005-06-09 19:05:08.000000000 -0600
+++ freeglut-2.4.0-svn759/ChangeLog	2008-11-09 23:05:14.000000000 -0700
@@ -1047,3 +1047,170 @@
 **************************************************************************
 * 9 Jun 2005 -- 2.4.0 Released
 **************************************************************************
+
+**************************************************************************
+* Changes in late June 2005
+**************************************************************************
+
+(271) Added an RPM spec file based on the one shipped with SuSE 9.3.
+
+(272) Implemented Joe Krahn's "Input Devices" code--at the moment, a dial
+box.
+
+(273) Fixed a bug in the Sierpinski sponge code that caused the application
+to crash if it called the code with a negative number of levels
+
+(274) Added separate static and DLL versions of all the demonstration
+programs under Windows.
+
+(275) Added --enable-debug configure flag. Currently it only turns on X11
+event tracing, but in the future we could add more.
+
+(276) Cleaned up CreateNotify/ConfigureNotify handling.
+
+(277) When a window is iconified, only an UnmapNotify is sent, not a
+VisibilityNotify, so we have to handle the window status callback in the
+former case, too. This fixes bug #763442 (Call the visibility callback when
+minimizing a window).
+
+**************************************************************************
+* Changes on July 1, 2005.
+**************************************************************************
+
+(278) Removed redundant files from EXTRA_DIST.
+
+(279) MinGW is lacking a prototype for ChangeDisplaySettingsEx, so
+supply one in this case. Note that this should better be handled via
+autoconf than via cpp.
+
+(280) Silenced a signed/unsigned mismatched via a cast.
+
+(281) Some steps toward compilation under MinGW. Note that there are still
+linking troubles for the examples.
+
+(282) Remove wrong "execute" bits when creating a distribution. This
+fixes bug #961938 (Executable bit set on non exe files).
+
+(283) Partial fixes for bug #1218900 (freeglut-2.4.0 on FreeBSD).
+
+(284) Handle modifiers in MotionNotify events, too. This fixes bug
+#1227920 (glutGetModifiers not set/allowed in mouse callbacks). In
+addition, some related cleanup has been done.
+
+(285) X11 only: Free XVisualInfo structures when they are not needed
+anymore, fixing a space leak. Not perfect for menus yet...
+
+(286) X11 only: Destroy the global menu rendering context when
+deinitializing. The visual/context handling for menus is still rather
+obscure, though...
+
+(287) Removed redundant code.
+
+(288) We only have pending redisplay callbacks when the window wants to be
+redisplayed *and* it is visible. Otherwise we won't redraw, anyway, and
+immediately discover that there's still something to do, etc. etc., leading
+to 100% CPU load.
+
+(289) Made a few global arrays "static", avoiding namespace pollution. The
+only externally visible symbols should either be from the GLUT API
+("glutXXX") or internal freeglut entities ("fgYYY"). Reformatted things a
+bit on the way.
+
+(290) Made all the "glutJoystickXXX" functions part of the freeglut
+extensions.
+
+(291) Solaris doesn't have cfmakeraw, but it is only a convenience function
+for some bit-fiddling, anyway.
+
+(292) Avoid gcc warnings for some joystick code (e.g. on Solaris).
+
+(293) Improve autoconf magic: To detect headers like GL/gl.h, it might be
+necessary to temporarily use the X11 flags found by AC_PATH_XTRA.
+
+(294) Fixed the GLUT_CURSOR_INHERIT logic once again...
+
+(295) Synched the DLL definitions with reality.
+
+**************************************************************************
+* Changes on August 31, 2005.
+**************************************************************************
+
+(296) Added support for Open Watcom
+
+**************************************************************************
+* Changes on September 4, 2005.
+**************************************************************************
+
+(297) Silenced autogen.sh. *nix commands are silent by default.
+
+(298) Use -Wall for automake to catch some buglets, deprecated
+stuff, etc.
+
+(299) Use target-specific *_CPPFLAGS, not the deprecated INCLUDES.
+
+**************************************************************************
+* Changes on October 6, 2005.
+**************************************************************************
+
+(300) Implemented Stereo in Windows.
+
+(301) Allowed compilation of Windows version by removing DLL decorations
+from deprecated joystick interface extensions.
+
+**************************************************************************
+* Changes on October 12, 2005.
+**************************************************************************
+
+(302) Simply use autoreconf in autogen.sh, it is much simpler and the
+recommended way in the autotools documentation. Removed INSTALL,
+install-sh and mkinstalldirs, they are either unused or automatically
+generated by autogen.sh.
+
+(303) Moved GLUT_INIT_STATE to <GL/freeglut_ext.h>, it is not part of the
+original GLUT.
+
+**************************************************************************
+* Changes on August 05, 2006.
+**************************************************************************
+
+(304) Updated build requirements for SuSE 10.1.
+
+(305) Check fgets for return value to avoid warnings.
+
+**************************************************************************
+* Changes on September 20, 2006
+**************************************************************************
+
+(306)  Changed "fgStructure.GameMode" to "fgStructure.GameModeWindow" to
+reflect better what it is
+
+**************************************************************************
+* Changes on September 21, 2006
+**************************************************************************
+
+(307)  Added an end-of-line character to a warning message about an unknown
+X event type
+
+(308)  Fixing a problem in which "glutGetWindow" would return a menu's window
+instead of the menu's parent window
+
+(309)  Added some handy comments, spacing, fixed a typo in a comment
+
+(310)  Changed "TARGET_HOST_UNIX_X11" to "TARGET_HOST_POSIX_X11" to avoid
+trademark issues, per Joe Krahn; also rationalized the other "TARGET_HOST"
+definitions
+
+(311)  Added futher callback functionality to the CallbackMaker demo program.
+Also added a prompt for user input to highlight a difference betwen GLUT
+and "freeglut"
+
+(312)  Added multisampling support for *nix and Windows; some other pixel
+format changes for Windows
+
+(313)  Added Markus Henschel's change (e-mail to developers' list, June 28,
+2006) to have the "glutInitDisplayString" ignore numerical assignments to
+tokens as a temporary fix.
+
+(314)  Fixed buy #1398196 in the bug tracker to the effect that passing the
+wrong argument in "fghSleepForEvents" can cause odd delays
+
diff -ruN freeglut-2.4.0/Makefile.am freeglut-2.4.0-svn759/Makefile.am
--- freeglut-2.4.0/Makefile.am	2005-05-08 19:30:41.000000000 -0600
+++ freeglut-2.4.0-svn759/Makefile.am	2008-11-09 23:05:14.000000000 -0700
@@ -4,7 +4,6 @@
 AUTOMAKE_OPTIONS = gnu
 
 EXTRA_DIST = \
-	AUTHORS COPYING ChangeLog INSTALL NEWS README TODO \
 	README.win32 LISEZ_MOI \
 	freeglut.lsm autogen.sh \
 	freeglut.kdevprj freeglut.kdevelop \
@@ -12,5 +11,20 @@
 	freeglut_static.dsp \
 	freeglut_evc4.vcp freeglut_evc4.vcw
 
+# Thanks to WinDoze, some files in CVS have the "execute" bit set when they
+# shoudn't. We could fix this if we had direct access to the CVS repository,
+# but we are not that lucky. Instead we fix this at distribution creation time.
+dist-hook:
+	find $(distdir) -type f \( \
+	    -name "*.c" -o \
+	    -name "*.dsp" -o \
+	    -name "*.dsw" -o \
+	    -name "*.h" -o \
+	    -name "*.html" -o \
+	    -name "*.png" -o \
+	    -name "LISEZ_MOI" -o \
+	    -name "README*" \
+	    \) -exec chmod -x {} \;
+
 libtool: $(LIBTOOL_DEPS)
 	$(SHELL) ./config.status --recheck
diff -ruN freeglut-2.4.0/README.win32 freeglut-2.4.0-svn759/README.win32
--- freeglut-2.4.0/README.win32	2005-04-28 13:47:20.000000000 -0600
+++ freeglut-2.4.0-svn759/README.win32	2008-11-09 23:05:14.000000000 -0700
@@ -1,60 +1,92 @@
-Windows 32 / MSVC Notes
-=======================
-
-The "freeglut" library installation package comes with MSVC 6.0 workspace and
-project files.  The workspace has two projects:  "freeglut.dsp", which creates
-a DLL file, and "freeglut_static.dsp", which creates a static library.
-
-
-Building the Libraries
-======================
-
-To build the "freeglut" libraries, open MSVC and load the "freeglut" workspace.
-This will load the two projects.  Selecting "Build" - "Batch Build" from the
-menu will build both the debug and the release versions of both libraries.
-
-The libraries will be found in the following places and will have the following
-names:
-- DLL, debug version:  freeglut\freeglut\Debug\freeglut.lib
-- DLL, release version:  freeglut\freeglut\Release\freeglut.lib
-- Static, debug version:  freeglut\freeglut\DebugStatic\freeglut_static.lib
-- Static, release version:  freeglut\freeglut\ReleaseStatic\freeglut_static.lib
-
-Unlike the *nix release, the library names are NOT automatic replacements for
-the GLUT library names.  You may rename them manually if you wish.
-
-
-Installing the Libraries
-========================
-
-To install "freeglut" on your system so that your other projects will see it,
-you will need to copy various files to various locations.
-
-    - The header files "freeglut.h", "freeglut_ext.h", "freeglut_std.h", and
-      "glut.h" (distributed in the directory "freeglut\freeglut\include\GL")
-      need to be copied to a "GL" directory under the MSVC include directory.
-      The MSVC include directory generally has a path similar to
-              "C:\Program Files\Microsoft Visual Studio\VC98\Include"
-      The "GL" subdirectory under that will probably already have the header
-      files "gl.h", "glaux.h", and "glu.h".
-    - The library file "freeglut.lib" or "freeglut_static.lib" (from the
-      corresponding debug or release directory) needs to be copied into the
-      MSVC library directory.  This usually has a path similar to
-              "C:\Program Files\Microsoft Visual Studio\VC98\Lib"
-      Note that there is no "GL" subdirectory here.  This directory should
-      already have the files "opengl32.lib", "glu32.lib", and "glaux.lib".
-    - If you are using the DLL version of "freeglut", the file "freeglut.dll"
-      needs to be copied from the Debug or the Release directory into the
-      DLL directory.  This usually has a path similar to
-              "C:\Windows\System32"
-      and will probably already have the files "opengl32.dll" and "glu32.dll".
-
-
-If you don't have MSVC
-======================
-
-The "freeglut" developers' community discussed the possibility of distributing
-binaries and decided against it.  If you need Windows library files, please
-contact John F. Fay at <john.fay@eglin.af.mil> or put a request on the
-"freeglut" developers' mailing list <freeglut-developer@lists.sourceforge.net>.
-
+Windows 32 Notes
+================
+
+The "freeglut" library installation package comes with MSVC 6.0 workspace and
+project files.  The workspace "freeglut.dsw" has two projects:
+"freeglut.dsp", which creates a DLL file, and "freeglut_static.dsp", which
+creates a static library.
+
+The "freeglut" library also comes with an Open Watcom compiler project file
+"freeglut.wpj" and two target files "freeglut.tgt" and "freeglut_static.tgt".
+The two target files build DLL and static libraries.  The Open Watcom also
+includes "freeglut.rc", which is a resource compiler script to add a "Version"
+tab to the DLL property sheet.
+
+
+Building the Libraries with MSVC
+================================
+
+To build the "freeglut" libraries, open MSVC and load the "freeglut" workspace.
+This will load the two projects.  Selecting "Build" - "Batch Build" from the
+menu will build both the debug and the release versions of both libraries.
+
+The libraries will be found in the following places and will have the
+following names:
+- DLL, debug version: freeglut\freeglut\Debug\freeglut.lib
+- DLL, release version: freeglut\freeglut\Release\freeglut.lib
+- Static, debug version: freeglut\freeglut\DebugStatic\freeglut_static.lib
+- Static, release version: freeglut\freeglut\ReleaseStatic\freeglut_static.lib
+
+Unlike the *nix release, the library names are NOT automatic replacements for
+the GLUT library names.  You may rename them manually if you wish, but this is
+not necessary as the header file includes a pragma telling the compiler which
+library file to look for.
+
+
+Installing the Libraries with MSVC
+==================================
+
+To install "freeglut" on your system so that your other projects will see it,
+you will need to copy various files to various locations.
+
+    - The header files "freeglut.h", "freeglut_ext.h", "freeglut_std.h", and
+      "glut.h" (distributed in the directory "freeglut\freeglut\include\GL")
+      need to be copied to a "GL" directory under the MSVC include directory.
+      The MSVC include directory generally has a path similar to
+              "C:\Program Files\Microsoft Visual Studio\VC98\Include"
+      The "GL" subdirectory under that will probably already have the header
+      files "gl.h", "glaux.h", and "glu.h".
+    - The library file "freeglut.lib" or "freeglut_static.lib" (from the
+      corresponding debug or release directory) needs to be copied into the
+      MSVC library directory.  This usually has a path similar to
+              "C:\Program Files\Microsoft Visual Studio\VC98\Lib"
+      Note that there is no "GL" subdirectory here.  This directory should
+      already have the files "opengl32.lib", "glu32.lib", and "glaux.lib".
+    - If you are using the DLL version of "freeglut", the file "freeglut.dll"
+      needs to be copied from the Debug or the Release directory into the
+      DLL directory.  This usually has a path similar to
+              "C:\Windows\System32"
+      and will probably already have the files "opengl32.dll" and "glu32.dll".
+
+
+Building and Installing the Libraries with Open Watcom
+======================================================
+
+To build the "freeglut" libraries, open Watcom and load the "freeglut.wpj"
+file.  This will load the two target files.  Clicking on the "Make All
+Targets" button will build both the debug and the release versions of both
+libraries.
+
+The "make" script will copy the library files to the Open Watcom library
+folder and will copy "freeglut.dll" to the correct "System32" folder.  The
+library files are named "freeglut.lib" for the DLL version and
+"freeglut_static.lib"for the static library.
+
+You will need to copy the "freeglut" include files from their installed
+location ("freeglut\freeglut\include\GL") to the Open Watcom include directory
+("%WATCOM%\h\nt\GL").
+
+Unlike the *nix release, the library names are NOT automatic replacements for
+the GLUT library names.  You may rename them manually if you wish, but this is
+not necessary as the header file includes a pragma telling the compiler which
+library file to look for.
+
+
+If you don't have MSVC or Open Watcom
+=====================================
+
+The "freeglut" developers' community discussed the possibility of distributing
+binaries and decided against it.  If you need Windows library files, please
+contact John F. Fay at <john.fay@eglin.af.mil> or put a request on the
+"freeglut" developers' mailing list <freeglut-developer@lists.sourceforge.net>.
+
diff -ruN freeglut-2.4.0/autogen.sh freeglut-2.4.0-svn759/autogen.sh
--- freeglut-2.4.0/autogen.sh	2003-06-24 12:12:40.000000000 -0600
+++ freeglut-2.4.0-svn759/autogen.sh	2008-11-09 23:05:14.000000000 -0700
@@ -1,12 +1,2 @@
-#!/bin/sh
-#
-echo "Generating build information using aclocal, automake and autoconf"
-echo "This may take a while ..."
-
-aclocal
-autoheader
-libtoolize  --copy  --force
-automake  --add-missing
-autoconf
-
-echo "Now you are ready to run ./configure"
+#! /bin/sh
+autoreconf --install --force --warnings=all
diff -ruN freeglut-2.4.0/configure.ac freeglut-2.4.0-svn759/configure.ac
--- freeglut-2.4.0/configure.ac	2005-06-09 19:05:33.000000000 -0600
+++ freeglut-2.4.0-svn759/configure.ac	2008-11-09 23:05:14.000000000 -0700
@@ -1,6 +1,6 @@
 # Process this file with autoconf to produce a configure script.
 
-AC_INIT([freeglut library], [2.4.0], [freeglut-bugs@lists.sourceforge.net], [freeglut])
+AC_INIT([freeglut library], [2.6.0], [freeglut-bugs@lists.sourceforge.net], [freeglut])
 AM_INIT_AUTOMAKE
 AC_PREREQ([2.56])
 AC_CONFIG_SRCDIR([AUTHORS])
@@ -11,6 +11,7 @@
 
 # Checks for programs.
 AC_PROG_CC
+AM_PROG_CC_C_O
 AC_C_CONST
 AC_EXEEXT
 AC_LIBTOOL_DLOPEN
@@ -19,26 +20,44 @@
 
 # Checks for libraries.
 AC_PATH_XTRA
-AC_CHECK_LIB([Xxf86vm], [XF86VidModeSwitchToMode],
-	     [LIBXXF86VM=-lXxf86vm], [LIBXXF86VM=],
-             [$X_LIBS -lXext -lX11])
+
+if test x"$no_x" = xyes; then
+  GL_LIBS="-lopengl32 -lglu32 -lgdi32 -lwinmm"
+  LIBXXF86VM=
+  LIBXI=
+  VERSION_INFO=
+  EXPORT_FLAGS="-DFREEGLUT_EXPORTS"
+else
+  GL_LIBS="-lGL -lGLU -lXext -lX11"
+  AC_CHECK_LIB([Xxf86vm], [XF86VidModeSwitchToMode],
+               [LIBXXF86VM=-lXxf86vm], [LIBXXF86VM=],
+               [$X_LIBS -lXext -lX11])
+  LIBXI=-lXi
+  VERSION_INFO="-version-info 11:0:8"
+  EXPORT_FLAGS=
+fi
+AC_SUBST([GL_LIBS])
 AC_SUBST([LIBXXF86VM])
+AC_SUBST([LIBXI])
+AC_SUBST([VERSION_INFO])
+AC_SUBST([EXPORT_FLAGS])
 
 # Checks for header files.
 AC_HEADER_STDC
+save_CPPFLAGS="$CPPFLAGS"
+CPPFLAGS="$CPPFLAGS $X_CFLAGS"
 AC_CHECK_HEADERS([GL/gl.h GL/glu.h GL/glx.h fcntl.h limits.h sys/ioctl.h sys/param.h sys/time.h])
 AC_HEADER_TIME
-
-save_CFLAGS="$CFLAGS"
-CFLAGS="$CFLAGS $X_CFLAGS"
 AC_CHECK_HEADERS([X11/extensions/xf86vmode.h], [], [], [#include <X11/Xlib.h>])
-CFLAGS="$save_CFLAGS"
+AC_CHECK_HEADERS([X11/extensions/XI.h X11/extensions/XInput.h])
+CPPFLAGS="$save_CPPFLAGS"
 
 # Checks for library functions.
 AC_PROG_GCC_TRADITIONAL
 AC_FUNC_VPRINTF
 AC_CHECK_LIBM
 AC_SUBST([LIBM])
+AC_CHECK_FUNCS([gettimeofday])
 
 # Build time configuration.
 AC_ARG_ENABLE([replace-glut],
@@ -58,7 +77,21 @@
 [AS_HELP_STRING([--enable-warnings],
                 [use all gcc compiler warnings @<:@default=yes@:>@])])
 if test "x$enable_warnings" != xno -a "x$GCC" = xyes; then
-  CFLAGS="$CFLAGS -Wall -pedantic -Werror"
+  CFLAGS="$CFLAGS -Wall -pedantic"
+fi
+
+AC_ARG_ENABLE([warnings-as-errors],
+[AS_HELP_STRING([--enable-warnings-as-errors],
+                [make all warnings into errors @<:@default=no@:>@])])
+if test "x$enable_warnings_as_errors" = xyes -a "x$GCC" = xyes; then
+  CFLAGS="$CFLAGS -Werror"
+fi
+
+AC_ARG_ENABLE([debug],
+[AS_HELP_STRING([--enable-debug],
+                [enable debugging code (for developers) @<:@default=no@:>@])])
+if test "x$enable_debug" = xyes; then
+  AC_DEFINE([_DEBUG], [1], [Define to 1 if you want to include debugging code.])
 fi
 
 # Generate output.
diff -ruN freeglut-2.4.0/doc/freeglut_user_interface.html freeglut-2.4.0-svn759/doc/freeglut_user_interface.html
--- freeglut-2.4.0/doc/freeglut_user_interface.html	2003-07-01 14:19:02.000000000 -0600
+++ freeglut-2.4.0-svn759/doc/freeglut_user_interface.html	2008-11-09 23:05:14.000000000 -0700
@@ -339,11 +339,10 @@
 to Silicon Graphics hardware have not been implemented.&nbsp; Most or all 
 of the new callbacks are listed in the GLUT Version 4 "glut.h" header file 
 but did not make it into the documentation.&nbsp; The new callbacks consist 
-of regular and special key release callbacks, a joystick callback, a menu 
-state callback (with one argument, distinct from the menu status callback 
-which has three arguments), and a window status callback <br>
- (also with one argument).&nbsp; Unsupported callbacks are the three Spaceball 
-callbacks, the ButtonBox callback, the Dials callback, and the two Tablet 
+of regular and special key release callbacks, a joystick callback, a window 
+status callback, window closure callbacks, a menu closure callback, and a
+mouse wheel callback.&nbsp; Unsupported callbacks are the three Spaceball 
+callbacks, the ButtonBox callback, and the two Tablet 
 callbacks.&nbsp; If the user has a need for an unsupported callback he should 
 contact the <i>freeglut</i> development team.<br>
                                    
@@ -356,8 +355,8 @@
                                    
                                   <h3>3.4.5&nbsp; Geometry Rendering<br>
                                    </h3>
- Two functions have been added to render a wireframe and a solid rhombic
-dodecahedron.                                    
+ Functions have been added to render a wireframe and a solid rhombic
+dodecahedron, a cylinder, and a Sierpinski sponge.                                    
                                   <h3> 3.4.5&nbsp; Extension Function Queries</h3>
  glutGetProcAddress is a wrapper for the glXGetProcAddressARB and wglGetProcAddress
 functions. 
diff -ruN freeglut-2.4.0/freeglut.dsp freeglut-2.4.0-svn759/freeglut.dsp
--- freeglut-2.4.0/freeglut.dsp	2004-05-12 20:11:26.000000000 -0600
+++ freeglut-2.4.0-svn759/freeglut.dsp	2008-11-09 23:05:14.000000000 -0700
@@ -1,214 +1,218 @@
-# Microsoft Developer Studio Project File - Name="freeglut" - Package Owner=<4>
-# Microsoft Developer Studio Generated Build File, Format Version 6.00
-# ** DO NOT EDIT **
-
-# TARGTYPE "Win32 (x86) Dynamic-Link Library" 0x0102
-
-CFG=freeglut - Win32 Debug
-!MESSAGE This is not a valid makefile. To build this project using NMAKE,
-!MESSAGE use the Export Makefile command and run
-!MESSAGE 
-!MESSAGE NMAKE /f "freeglut.mak".
-!MESSAGE 
-!MESSAGE You can specify a configuration when running NMAKE
-!MESSAGE by defining the macro CFG on the command line. For example:
-!MESSAGE 
-!MESSAGE NMAKE /f "freeglut.mak" CFG="freeglut - Win32 Debug"
-!MESSAGE 
-!MESSAGE Possible choices for configuration are:
-!MESSAGE 
-!MESSAGE "freeglut - Win32 Release" (based on "Win32 (x86) Dynamic-Link Library")
-!MESSAGE "freeglut - Win32 Debug" (based on "Win32 (x86) Dynamic-Link Library")
-!MESSAGE 
-
-# Begin Project
-# PROP AllowPerConfigDependencies 0
-# PROP Scc_ProjName ""
-# PROP Scc_LocalPath ""
-CPP=cl.exe
-MTL=midl.exe
-RSC=rc.exe
-
-!IF  "$(CFG)" == "freeglut - Win32 Release"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 0
-# PROP BASE Output_Dir "Release"
-# PROP BASE Intermediate_Dir "Release"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 0
-# PROP Output_Dir "Release"
-# PROP Intermediate_Dir "Release"
-# PROP Target_Dir ""
-# ADD BASE CPP /nologo /MT /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "FREEGLUT_EXPORTS" /YX /FD /c
-# ADD CPP /nologo /MT /W3 /GX /O2 /I "include" /D "NDEBUG" /D "WIN32" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "FREEGLUT_EXPORTS" /YX /FD /c
-# ADD BASE MTL /nologo /D "NDEBUG" /mktyplib203 /win32
-# ADD MTL /nologo /D "NDEBUG" /mktyplib203 /win32
-# ADD BASE RSC /l 0x409 /d "NDEBUG"
-# ADD RSC /l 0x409 /d "NDEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /machine:I386
-# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /machine:I386
-
-!ELSEIF  "$(CFG)" == "freeglut - Win32 Debug"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 1
-# PROP BASE Output_Dir "Debug"
-# PROP BASE Intermediate_Dir "Debug"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 1
-# PROP Output_Dir "Debug"
-# PROP Intermediate_Dir "Debug"
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir ""
-# ADD BASE CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "FREEGLUT_EXPORTS" /YX /FD /GZ /c
-# ADD CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /I "include" /D "_DEBUG" /D "WIN32" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "FREEGLUT_EXPORTS" /FR /YX /FD /GZ /c
-# ADD BASE MTL /nologo /D "_DEBUG" /mktyplib203 /win32
-# ADD MTL /nologo /D "_DEBUG" /mktyplib203 /win32
-# ADD BASE RSC /l 0x409 /d "_DEBUG"
-# ADD RSC /l 0x409 /d "_DEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /debug /machine:I386 /pdbtype:sept
-# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /debug /machine:I386 /pdbtype:sept
-
-!ENDIF 
-
-# Begin Target
-
-# Name "freeglut - Win32 Release"
-# Name "freeglut - Win32 Debug"
-# Begin Group "Source Files"
-
-# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
-# Begin Source File
-
-SOURCE=.\src\freeglut_callbacks.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\src\freeglut_cursor.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\src\freeglut_display.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\src\freeglut_ext.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\src\freeglut_font.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\src\freeglut_font_data.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\src\freeglut_gamemode.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\src\freeglut_geometry.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\src\freeglut_glutfont_definitions.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\src\freeglut_init.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\src\freeglut_joystick.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\src\freeglut_main.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\src\freeglut_menu.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\src\freeglut_misc.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\src\freeglut_overlay.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\src\freeglut_state.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\src\freeglut_stroke_mono_roman.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\src\freeglut_stroke_roman.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\src\freeglut_structure.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\src\freeglut_teapot.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\src\freeglut_videoresize.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\src\freeglut_window.c
-# End Source File
-# End Group
-# Begin Group "Header Files"
-
-# PROP Default_Filter "h;hpp;hxx;hm;inl"
-# Begin Source File
-
-SOURCE=.\include\GL\freeglut.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\include\GL\freeglut_ext.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\src\freeglut_internal.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\include\GL\freeglut_std.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\src\freeglut_teapot_data.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\include\GL\glut.h
-# End Source File
-# End Group
-# Begin Group "Resource Files"
-
-# PROP Default_Filter "ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
-# End Group
-# End Target
-# End Project
+# Microsoft Developer Studio Project File - Name="freeglut" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Dynamic-Link Library" 0x0102
+
+CFG=freeglut - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "freeglut.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "freeglut.mak" CFG="freeglut - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "freeglut - Win32 Release" (based on "Win32 (x86) Dynamic-Link Library")
+!MESSAGE "freeglut - Win32 Debug" (based on "Win32 (x86) Dynamic-Link Library")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+MTL=midl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "freeglut - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /MT /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "FREEGLUT_EXPORTS" /YX /FD /c
+# ADD CPP /nologo /MT /W3 /GX /O2 /I "include" /D "NDEBUG" /D "WIN32" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "FREEGLUT_EXPORTS" /YX /FD /c
+# ADD BASE MTL /nologo /D "NDEBUG" /mktyplib203 /win32
+# ADD MTL /nologo /D "NDEBUG" /mktyplib203 /win32
+# ADD BASE RSC /l 0x409 /d "NDEBUG"
+# ADD RSC /l 0x409 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /machine:I386
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /machine:I386
+
+!ELSEIF  "$(CFG)" == "freeglut - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug"
+# PROP Intermediate_Dir "Debug"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "FREEGLUT_EXPORTS" /YX /FD /GZ /c
+# ADD CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /I "include" /D "_DEBUG" /D "WIN32" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "FREEGLUT_EXPORTS" /FR /YX /FD /GZ /c
+# ADD BASE MTL /nologo /D "_DEBUG" /mktyplib203 /win32
+# ADD MTL /nologo /D "_DEBUG" /mktyplib203 /win32
+# ADD BASE RSC /l 0x409 /d "_DEBUG"
+# ADD RSC /l 0x409 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /debug /machine:I386 /pdbtype:sept
+
+!ENDIF 
+
+# Begin Target
+
+# Name "freeglut - Win32 Release"
+# Name "freeglut - Win32 Debug"
+# Begin Group "Source Files"
+
+# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+# Begin Source File
+
+SOURCE=.\src\freeglut_callbacks.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_cursor.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_display.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_ext.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_font.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_font_data.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_gamemode.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_geometry.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_glutfont_definitions.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_init.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_input_devices.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_joystick.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_main.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_menu.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_misc.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_overlay.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_state.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_stroke_mono_roman.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_stroke_roman.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_structure.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_teapot.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_videoresize.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_window.c
+# End Source File
+# End Group
+# Begin Group "Header Files"
+
+# PROP Default_Filter "h;hpp;hxx;hm;inl"
+# Begin Source File
+
+SOURCE=.\include\GL\freeglut.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\include\GL\freeglut_ext.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_internal.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\include\GL\freeglut_std.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_teapot_data.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\include\GL\glut.h
+# End Source File
+# End Group
+# Begin Group "Resource Files"
+
+# PROP Default_Filter "ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
+# End Group
+# End Target
+# End Project
diff -ruN freeglut-2.4.0/freeglut.dsw freeglut-2.4.0-svn759/freeglut.dsw
--- freeglut-2.4.0/freeglut.dsw	2003-09-13 07:03:30.000000000 -0600
+++ freeglut-2.4.0-svn759/freeglut.dsw	2008-11-09 23:05:14.000000000 -0700
@@ -1,41 +1,41 @@
-Microsoft Developer Studio Workspace File, Format Version 6.00
-# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
-
-###############################################################################
-
-Project: "freeglut"=.\freeglut.dsp - Package Owner=<4>
-
-Package=<5>
-{{{
-}}}
-
-Package=<4>
-{{{
-}}}
-
-###############################################################################
-
-Project: "freeglut_static"=.\freeglut_static.dsp - Package Owner=<4>
-
-Package=<5>
-{{{
-}}}
-
-Package=<4>
-{{{
-}}}
-
-###############################################################################
-
-Global:
-
-Package=<5>
-{{{
-}}}
-
-Package=<3>
-{{{
-}}}
-
-###############################################################################
-
+Microsoft Developer Studio Workspace File, Format Version 6.00
+# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
+
+###############################################################################
+
+Project: "freeglut"=.\freeglut.dsp - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+}}}
+
+###############################################################################
+
+Project: "freeglut_static"=.\freeglut_static.dsp - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+}}}
+
+###############################################################################
+
+Global:
+
+Package=<5>
+{{{
+}}}
+
+Package=<3>
+{{{
+}}}
+
+###############################################################################
+
diff -ruN freeglut-2.4.0/freeglut.lsm freeglut-2.4.0-svn759/freeglut.lsm
--- freeglut-2.4.0/freeglut.lsm	2003-07-22 17:41:33.000000000 -0600
+++ freeglut-2.4.0-svn759/freeglut.lsm	2008-11-09 23:05:14.000000000 -0700
@@ -1,14 +1,14 @@
-Begin3
-Title:          freeglut
-Version:        2.0.0
-Entered-date:   
-Description:    The free OpenGL utility toolkit, alternative to the GLUT library
-Keywords:        
-Author:         Pawel W. Olszta <olszta@users.sourceforge.net> 
-Maintained-by:  Stephen J. Baker <sjbaker@users.sourceforge.net> 
-Primary-site:   http://freeglut.sourceforge.net	        
-Home-page:      http://freeglut.sourceforge.net
-Original-site:  
-Platforms:      Linux and other Unices; Windows
-Copying-policy: X-Consortium style license
-End
+Begin3
+Title:          freeglut
+Version:        2.0.0
+Entered-date:   
+Description:    The free OpenGL utility toolkit, alternative to the GLUT library
+Keywords:        
+Author:         Pawel W. Olszta <olszta@users.sourceforge.net> 
+Maintained-by:  Stephen J. Baker <sjbaker@users.sourceforge.net> 
+Primary-site:   http://freeglut.sourceforge.net	        
+Home-page:      http://freeglut.sourceforge.net
+Original-site:  
+Platforms:      Linux and other Unices; Windows
+Copying-policy: X-Consortium style license
+End
diff -ruN freeglut-2.4.0/freeglut_static.dsp freeglut-2.4.0-svn759/freeglut_static.dsp
--- freeglut-2.4.0/freeglut_static.dsp	2004-05-12 20:11:26.000000000 -0600
+++ freeglut-2.4.0-svn759/freeglut_static.dsp	2008-11-09 23:05:14.000000000 -0700
@@ -1,204 +1,208 @@
-# Microsoft Developer Studio Project File - Name="freeglut_static" - Package Owner=<4>
-# Microsoft Developer Studio Generated Build File, Format Version 6.00
-# ** DO NOT EDIT **
-
-# TARGTYPE "Win32 (x86) Static Library" 0x0104
-
-CFG=freeglut_static - Win32 Debug
-!MESSAGE This is not a valid makefile. To build this project using NMAKE,
-!MESSAGE use the Export Makefile command and run
-!MESSAGE 
-!MESSAGE NMAKE /f "freeglut_static.mak".
-!MESSAGE 
-!MESSAGE You can specify a configuration when running NMAKE
-!MESSAGE by defining the macro CFG on the command line. For example:
-!MESSAGE 
-!MESSAGE NMAKE /f "freeglut_static.mak" CFG="freeglut_static - Win32 Debug"
-!MESSAGE 
-!MESSAGE Possible choices for configuration are:
-!MESSAGE 
-!MESSAGE "freeglut_static - Win32 Release" (based on "Win32 (x86) Static Library")
-!MESSAGE "freeglut_static - Win32 Debug" (based on "Win32 (x86) Static Library")
-!MESSAGE 
-
-# Begin Project
-# PROP AllowPerConfigDependencies 0
-# PROP Scc_ProjName ""
-# PROP Scc_LocalPath ""
-CPP=cl.exe
-RSC=rc.exe
-
-!IF  "$(CFG)" == "freeglut_static - Win32 Release"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 0
-# PROP BASE Output_Dir "freeglut_static___Win32_Release"
-# PROP BASE Intermediate_Dir "freeglut_static___Win32_Release"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 0
-# PROP Output_Dir "ReleaseStatic"
-# PROP Intermediate_Dir "ReleaseStatic"
-# PROP Target_Dir ""
-# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /YX /FD /c
-# ADD CPP /nologo /W3 /GX /O2 /I "include" /D "NDEBUG" /D "FREEGLUT_STATIC" /D "WIN32" /D "_MBCS" /D "_LIB" /YX /FD /c
-# ADD BASE RSC /l 0x409 /d "NDEBUG"
-# ADD RSC /l 0x409 /d "NDEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LIB32=link.exe -lib
-# ADD BASE LIB32 /nologo
-# ADD LIB32 /nologo
-
-!ELSEIF  "$(CFG)" == "freeglut_static - Win32 Debug"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 1
-# PROP BASE Output_Dir "freeglut_static___Win32_Debug"
-# PROP BASE Intermediate_Dir "freeglut_static___Win32_Debug"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 1
-# PROP Output_Dir "DebugStatic"
-# PROP Intermediate_Dir "DebugStatic"
-# PROP Target_Dir ""
-# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /YX /FD /GZ /c
-# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /I "include" /D "_DEBUG" /D "FREEGLUT_STATIC" /D "WIN32" /D "_MBCS" /D "_LIB" /FR /YX /FD /GZ /c
-# ADD BASE RSC /l 0x409 /d "_DEBUG"
-# ADD RSC /l 0x409 /d "_DEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LIB32=link.exe -lib
-# ADD BASE LIB32 /nologo
-# ADD LIB32 /nologo
-
-!ENDIF 
-
-# Begin Target
-
-# Name "freeglut_static - Win32 Release"
-# Name "freeglut_static - Win32 Debug"
-# Begin Group "Source Files"
-
-# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
-# Begin Source File
-
-SOURCE=.\src\freeglut_callbacks.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\src\freeglut_cursor.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\src\freeglut_display.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\src\freeglut_ext.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\src\freeglut_font.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\src\freeglut_font_data.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\src\freeglut_gamemode.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\src\freeglut_geometry.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\src\freeglut_glutfont_definitions.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\src\freeglut_init.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\src\freeglut_joystick.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\src\freeglut_main.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\src\freeglut_menu.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\src\freeglut_misc.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\src\freeglut_overlay.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\src\freeglut_state.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\src\freeglut_stroke_mono_roman.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\src\freeglut_stroke_roman.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\src\freeglut_structure.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\src\freeglut_teapot.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\src\freeglut_videoresize.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\src\freeglut_window.c
-# End Source File
-# End Group
-# Begin Group "Header Files"
-
-# PROP Default_Filter "h;hpp;hxx;hm;inl"
-# Begin Source File
-
-SOURCE=.\include\GL\freeglut.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\include\GL\freeglut_ext.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\src\freeglut_internal.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\include\GL\freeglut_std.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\src\freeglut_teapot_data.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\include\GL\glut.h
-# End Source File
-# End Group
-# End Target
-# End Project
+# Microsoft Developer Studio Project File - Name="freeglut_static" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Static Library" 0x0104
+
+CFG=freeglut_static - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "freeglut_static.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "freeglut_static.mak" CFG="freeglut_static - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "freeglut_static - Win32 Release" (based on "Win32 (x86) Static Library")
+!MESSAGE "freeglut_static - Win32 Debug" (based on "Win32 (x86) Static Library")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "freeglut_static - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "freeglut_static___Win32_Release"
+# PROP BASE Intermediate_Dir "freeglut_static___Win32_Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "ReleaseStatic"
+# PROP Intermediate_Dir "ReleaseStatic"
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /YX /FD /c
+# ADD CPP /nologo /W3 /GX /O2 /I "include" /D "NDEBUG" /D "FREEGLUT_STATIC" /D "WIN32" /D "_MBCS" /D "_LIB" /YX /FD /c
+# ADD BASE RSC /l 0x409 /d "NDEBUG"
+# ADD RSC /l 0x409 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LIB32=link.exe -lib
+# ADD BASE LIB32 /nologo
+# ADD LIB32 /nologo
+
+!ELSEIF  "$(CFG)" == "freeglut_static - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "freeglut_static___Win32_Debug"
+# PROP BASE Intermediate_Dir "freeglut_static___Win32_Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "DebugStatic"
+# PROP Intermediate_Dir "DebugStatic"
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /YX /FD /GZ /c
+# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /I "include" /D "_DEBUG" /D "FREEGLUT_STATIC" /D "WIN32" /D "_MBCS" /D "_LIB" /FR /YX /FD /GZ /c
+# ADD BASE RSC /l 0x409 /d "_DEBUG"
+# ADD RSC /l 0x409 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LIB32=link.exe -lib
+# ADD BASE LIB32 /nologo
+# ADD LIB32 /nologo
+
+!ENDIF 
+
+# Begin Target
+
+# Name "freeglut_static - Win32 Release"
+# Name "freeglut_static - Win32 Debug"
+# Begin Group "Source Files"
+
+# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+# Begin Source File
+
+SOURCE=.\src\freeglut_callbacks.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_cursor.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_display.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_ext.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_font.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_font_data.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_gamemode.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_geometry.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_glutfont_definitions.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_init.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_input_devices.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_joystick.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_main.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_menu.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_misc.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_overlay.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_state.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_stroke_mono_roman.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_stroke_roman.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_structure.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_teapot.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_videoresize.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_window.c
+# End Source File
+# End Group
+# Begin Group "Header Files"
+
+# PROP Default_Filter "h;hpp;hxx;hm;inl"
+# Begin Source File
+
+SOURCE=.\include\GL\freeglut.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\include\GL\freeglut_ext.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_internal.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\include\GL\freeglut_std.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\freeglut_teapot_data.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\include\GL\glut.h
+# End Source File
+# End Group
+# End Target
+# End Project
diff -ruN freeglut-2.4.0/include/GL/freeglut_ext.h freeglut-2.4.0-svn759/include/GL/freeglut_ext.h
--- freeglut-2.4.0/include/GL/freeglut_ext.h	2005-03-23 08:14:32.000000000 -0700
+++ freeglut-2.4.0-svn759/include/GL/freeglut_ext.h	2008-11-09 23:05:14.000000000 -0700
@@ -56,6 +56,8 @@
 /*
  * GLUT API Extension macro definitions -- the glutGet parameters
  */
+#define  GLUT_INIT_STATE                    0x007C
+
 #define  GLUT_ACTION_ON_WINDOW_CLOSE        0x01F9
 
 #define  GLUT_WINDOW_BORDER_WIDTH           0x01FA
@@ -66,21 +68,44 @@
 #define  GLUT_RENDERING_CONTEXT             0x01FD
 #define  GLUT_DIRECT_RENDERING              0x01FE
 
+#define  GLUT_FULL_SCREEN                   0x01FF
+
 /*
  * New tokens for glutInitDisplayMode.
  * Only one GLUT_AUXn bit may be used at a time.
  * Value 0x0400 is defined in OpenGLUT.
  */
+#define  GLUT_AUX                           0x1000
+
 #define  GLUT_AUX1                          0x1000
 #define  GLUT_AUX2                          0x2000
 #define  GLUT_AUX3                          0x4000
 #define  GLUT_AUX4                          0x8000
 
 /*
+ * Context-related flags, see freeglut_state.c
+ */
+#define  GLUT_INIT_MAJOR_VERSION            0x0200
+#define  GLUT_INIT_MINOR_VERSION            0x0201
+#define  GLUT_INIT_FLAGS                    0x0202
+
+/*
+ * Flags for glutInitContextFlags, see freeglut_init.c
+ */
+#define  GLUT_DEBUG                         0x0001
+#define  GLUT_FORWARD_COMPATIBLE            0x0002
+
+/*
  * Process loop function, see freeglut_main.c
  */
 FGAPI void    FGAPIENTRY glutMainLoopEvent( void );
 FGAPI void    FGAPIENTRY glutLeaveMainLoop( void );
+FGAPI void    FGAPIENTRY glutExit         ( void );
+
+/*
+ * Window management functions, see freeglut_window.c
+ */
+FGAPI void    FGAPIENTRY glutFullScreenToggle( void );
 
 /*
  * Window-specific callback functions, see freeglut_callbacks.c
@@ -94,7 +119,8 @@
 /*
  * State setting and retrieval functions, see freeglut_state.c
  */
-FGAPI void    FGAPIENTRY glutSetOption ( GLenum option_flag, int value ) ;
+FGAPI void    FGAPIENTRY glutSetOption ( GLenum option_flag, int value );
+FGAPI int *   FGAPIENTRY glutGetModeValues(GLenum mode, int * size);
 /* A.Donev: User-data manipulation */
 FGAPI void*   FGAPIENTRY glutGetWindowData( void );
 FGAPI void    FGAPIENTRY glutSetWindowData(void* data);
@@ -114,8 +140,8 @@
  */
 FGAPI void    FGAPIENTRY glutWireRhombicDodecahedron( void );
 FGAPI void    FGAPIENTRY glutSolidRhombicDodecahedron( void );
-FGAPI void    FGAPIENTRY glutWireSierpinskiSponge ( int num_levels, GLdouble offset[3], GLdouble scale ) ;
-FGAPI void    FGAPIENTRY glutSolidSierpinskiSponge ( int num_levels, GLdouble offset[3], GLdouble scale ) ;
+FGAPI void    FGAPIENTRY glutWireSierpinskiSponge ( int num_levels, GLdouble offset[3], GLdouble scale );
+FGAPI void    FGAPIENTRY glutSolidSierpinskiSponge ( int num_levels, GLdouble offset[3], GLdouble scale );
 FGAPI void    FGAPIENTRY glutWireCylinder( GLdouble radius, GLdouble height, GLint slices, GLint stacks);
 FGAPI void    FGAPIENTRY glutSolidCylinder( GLdouble radius, GLdouble height, GLint slices, GLint stacks);
 
@@ -125,6 +151,34 @@
 typedef void (*GLUTproc)();
 FGAPI GLUTproc FGAPIENTRY glutGetProcAddress( const char *procName );
 
+/*
+ * Joystick functions, see freeglut_joystick.c
+ */
+/* USE OF THESE FUNCTIONS IS DEPRECATED !!!!! */
+/* If you have a serious need for these functions in your application, please either
+ * contact the "freeglut" developer community at freeglut-developer@lists.sourceforge.net,
+ * switch to the OpenGLUT library, or else port your joystick functionality over to PLIB's
+ * "js" library.
+ */
+int     glutJoystickGetNumAxes( int ident );
+int     glutJoystickGetNumButtons( int ident );
+int     glutJoystickNotWorking( int ident );
+float   glutJoystickGetDeadBand( int ident, int axis );
+void    glutJoystickSetDeadBand( int ident, int axis, float db );
+float   glutJoystickGetSaturation( int ident, int axis );
+void    glutJoystickSetSaturation( int ident, int axis, float st );
+void    glutJoystickSetMinRange( int ident, float *axes );
+void    glutJoystickSetMaxRange( int ident, float *axes );
+void    glutJoystickSetCenter( int ident, float *axes );
+void    glutJoystickGetMinRange( int ident, float *axes );
+void    glutJoystickGetMaxRange( int ident, float *axes );
+void    glutJoystickGetCenter( int ident, float *axes );
+
+/*
+ * Initialization functions, see freeglut_init.c
+ */
+FGAPI void    FGAPIENTRY glutInitContextVersion( int majorVersion, int minorVersion );
+FGAPI void    FGAPIENTRY glutInitContextFlags( int flags );
 
 #ifdef __cplusplus
     }
diff -ruN freeglut-2.4.0/include/GL/freeglut_std.h freeglut-2.4.0-svn759/include/GL/freeglut_std.h
--- freeglut-2.4.0/include/GL/freeglut_std.h	2005-01-01 09:09:38.000000000 -0700
+++ freeglut-2.4.0-svn759/include/GL/freeglut_std.h	2008-11-09 23:05:14.000000000 -0700
@@ -35,61 +35,65 @@
 /*
  * Under windows, we have to differentiate between static and dynamic libraries
  */
-#if defined(_MSC_VER) || defined(__CYGWIN__) || defined(__MINGW32__)
-
+#ifdef _WIN32
 /* #pragma may not be supported by some compilers.
  * Discussion by FreeGLUT developers suggests that
  * Visual C++ specific code involving pragmas may
  * need to move to a separate header.  24th Dec 2003
- */ 
+ */
+
+/* Define FREEGLUT_LIB_PRAGMAS to 1 to include library
+ * pragmas or to 1 to exclude library pragmas.
+ * The default behavior depends on the compiler/platform.
+ */
+#   ifndef FREEGLUT_LIB_PRAGMAS
+#       if ( defined(_MSC_VER) || defined(__WATCOMC__) ) && !defined(_WIN32_WCE)
+#           define FREEGLUT_LIB_PRAGMAS 1
+#       else
+#           define FREEGLUT_LIB_PRAGMAS 0
+#       endif
+#   endif
 
 #   define WIN32_LEAN_AND_MEAN
-#   define NO_MIN_MAX
-#    include <windows.h>
-#   undef min
-#   undef max
+#   define NOMINMAX
+#   include <Windows.h>
 
 /* Windows static library */
 #   ifdef FREEGLUT_STATIC
 
-#    define FGAPI
-#    define FGAPIENTRY
+#       define FGAPI
+#       define FGAPIENTRY
 
         /* Link with Win32 static freeglut lib */
-#       if defined(_MSC_VER)
+#       if FREEGLUT_LIB_PRAGMAS
 #           pragma comment (lib, "freeglut_static.lib")
 #       endif
 
 /* Windows shared library (DLL) */
 #   else
 
-#        if defined(FREEGLUT_EXPORTS)
-#                define FGAPI __declspec(dllexport)
-#        else
-#                define FGAPI __declspec(dllimport)
-
-            /* link with Win32 shared freeglut lib */
-#           if defined(_MSC_VER)
-#               ifndef _WIN32_WCE
-#                   pragma comment (lib, "freeglut.lib")
-#               endif
-#        endif
+#       define FGAPIENTRY __stdcall
+#       if defined(FREEGLUT_EXPORTS)
+#           define FGAPI __declspec(dllexport)
+#       else
+#           define FGAPI __declspec(dllimport)
+
+            /* Link with Win32 shared freeglut lib */
+#           if FREEGLUT_LIB_PRAGMAS
+#               pragma comment (lib, "freeglut.lib")
+#           endif
 
 #       endif
 
-#       define FGAPIENTRY __stdcall
-
 #   endif
 
 /* Drag in other Windows libraries as required by FreeGLUT */
-#   if defined(_MSC_VER)
-#       ifndef _WIN32_WCE
-#           pragma comment (lib, "winmm.lib")    /* link Windows MultiMedia lib */
-#           pragma comment (lib, "user32.lib")   /* link Windows user lib       */
-#           pragma comment (lib, "gdi32.lib")    /* link Windows GDI lib        */
-#           pragma comment (lib, "opengl32.lib") /* link Microsoft OpenGL lib   */
-#           pragma comment (lib, "glu32.lib")    /* link OpenGL Utility lib     */
-#       endif /* _WIN32_WCE */
+#   if FREEGLUT_LIB_PRAGMAS
+#       pragma comment (lib, "glu32.lib")    /* link OpenGL Utility lib     */
+#       pragma comment (lib, "opengl32.lib") /* link Microsoft OpenGL lib   */
+#       pragma comment (lib, "gdi32.lib")    /* link Windows GDI lib        */
+#       pragma comment (lib, "winmm.lib")    /* link Windows MultiMedia lib */
+#       pragma comment (lib, "user32.lib")   /* link Windows user lib       */
 #   endif
 
 #else
@@ -165,6 +169,8 @@
 #define  GLUT_MULTISAMPLE                   0x0080
 #define  GLUT_STEREO                        0x0100
 #define  GLUT_LUMINANCE                     0x0200
+#define  GLUT_CAPTIONLESS                   0x0400
+#define  GLUT_BORDERLESS                    0x0800
 
 /*
  * GLUT API macro definitions -- windows and menu related definitions
@@ -183,7 +189,7 @@
  *
  * Steve Baker suggested to make it binary compatible with GLUT:
  */
-#if defined(_MSC_VER) || defined(__CYGWIN__) || defined(__MINGW32__)
+#if defined(_MSC_VER) || defined(__CYGWIN__) || defined(__MINGW32__) || defined(__WATCOMC__)
 #   define  GLUT_STROKE_ROMAN               ((void *)0x0000)
 #   define  GLUT_STROKE_MONO_ROMAN          ((void *)0x0001)
 #   define  GLUT_BITMAP_9_BY_15             ((void *)0x0002)
@@ -197,16 +203,25 @@
     /*
      * I don't really know if it's a good idea... But here it goes:
      */
-    extern void* glutStrokeRoman;
-    extern void* glutStrokeMonoRoman;
-    extern void* glutBitmap9By15;
-    extern void* glutBitmap8By13;
-    extern void* glutBitmapTimesRoman10;
-    extern void* glutBitmapTimesRoman24;
-    extern void* glutBitmapHelvetica10;
-    extern void* glutBitmapHelvetica12;
-    extern void* glutBitmapHelvetica18;
-
+struct freeglutBitmapFont
+{
+  const char *name ;
+  const int num_chars ;
+  const int first ;
+  const void *ch ;
+};
+
+extern struct freeglutStrokeFont glutStrokeRoman ;
+extern struct freeglutStrokeFont glutStrokeMonoRoman ;
+
+extern struct freeglutBitmapFont glutBitmap9By15 ;
+extern struct freeglutBitmapFont glutBitmap8By13 ;
+extern struct freeglutBitmapFont glutBitmapTimesRoman10 ;
+extern struct freeglutBitmapFont glutBitmapTimesRoman24 ;
+extern struct freeglutBitmapFont glutBitmapHelvetica10 ;
+extern struct freeglutBitmapFont glutBitmapHelvetica12 ;
+extern struct freeglutBitmapFont glutBitmapHelvetica18 ;
+      
     /*
      * Those pointers will be used by following definitions:
      */
@@ -261,7 +276,6 @@
 #define  GLUT_INIT_DISPLAY_MODE             0x01F8
 #define  GLUT_ELAPSED_TIME                  0x02BC
 #define  GLUT_WINDOW_FORMAT_ID              0x007B
-#define  GLUT_INIT_STATE                    0x007C
 
 /*
  * GLUT API macro definitions -- the glutDeviceGet parameters
diff -ruN freeglut-2.4.0/src/Makefile.am freeglut-2.4.0-svn759/src/Makefile.am
--- freeglut-2.4.0/src/Makefile.am	2005-04-26 07:38:27.000000000 -0600
+++ freeglut-2.4.0-svn759/src/Makefile.am	2008-11-09 23:05:14.000000000 -0700
@@ -27,6 +27,7 @@
 			 freeglut_gamemode.c \
 			 freeglut_geometry.c \
 			 freeglut_init.c \
+			 freeglut_input_devices.c \
 			 freeglut_joystick.c \
 			 freeglut_main.c \
 			 freeglut_menu.c \
@@ -41,11 +42,10 @@
 #
 # Additional linker flags
 #	 
-lib@LIBRARY@_la_LIBADD = $(LIBM) $(X_LIBS) -lGL -lGLU -lXext -lX11 $(LIBXXF86VM)
-lib@LIBRARY@_la_LDFLAGS = -version-info 11:0:8
-lib@LIBRARY@_la_CFLAGS = $(X_CFLAGS)
-
-INCLUDES = -I$(top_srcdir)/include
+lib@LIBRARY@_la_LIBADD  = $(LIBM) $(X_LIBS) $(GL_LIBS) $(LIBXXF86VM) $(LIBXI)
+lib@LIBRARY@_la_LDFLAGS = $(VERSION_INFO)
+lib@LIBRARY@_la_CFLAGS  = $(X_CFLAGS) $(EXPORT_FLAGS)
+lib@LIBRARY@_la_CPPFLAGS= -I$(top_srcdir)/include
 
 #
 # End of file
diff -ruN freeglut-2.4.0/src/freeglut_cursor.c freeglut-2.4.0-svn759/src/freeglut_cursor.c
--- freeglut-2.4.0/src/freeglut_cursor.c	2005-04-22 09:23:12.000000000 -0600
+++ freeglut-2.4.0-svn759/src/freeglut_cursor.c	2008-11-09 23:05:14.000000000 -0700
@@ -28,7 +28,7 @@
 #include <GL/freeglut.h>
 #include "freeglut_internal.h"
 
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
   #include <X11/cursorfont.h>
 #endif
 
@@ -43,7 +43,7 @@
 
 /* -- PRIVATE FUNCTIONS --------------------------------------------------- */
 
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
 /*
  * A factory method for an empty cursor
  */
@@ -111,7 +111,7 @@
  */
 void fgSetCursor ( SFG_Window *window, int cursorID )
 {
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
     {
         Cursor cursor;
         /*
@@ -147,19 +147,22 @@
             }
         }
 
-        if ( ( cursorIDToUse != GLUT_CURSOR_NONE ) && ( cursor == None ) ) {
+        if ( cursorIDToUse == GLUT_CURSOR_INHERIT ) {
+            XUndefineCursor( fgDisplay.Display, window->Window.Handle );
+        } else if ( cursor != None ) {
+            XDefineCursor( fgDisplay.Display, window->Window.Handle, cursor );
+        } else if ( cursorIDToUse != GLUT_CURSOR_NONE ) {
             fgError( "Failed to create cursor" );
         }
-        XDefineCursor( fgDisplay.Display,
-                       window->Window.Handle, cursor );
     }
 
-#elif TARGET_HOST_WIN32 || TARGET_HOST_WINCE
+#elif TARGET_HOST_MS_WINDOWS
 
     /*
-     * This is a temporary solution only...
+     * Joe Krahn is re-writing the following code.
      */
     /* Set the cursor AND change it for this window class. */
+#if _MSC_VER <= 1200
 #       define MAP_CURSOR(a,b)                                   \
         case a:                                                  \
             SetCursor( LoadCursor( NULL, b ) );                  \
@@ -167,7 +170,6 @@
                           GCL_HCURSOR,                           \
                           ( LONG )LoadCursor( NULL, b ) );       \
         break;
-
     /* Nuke the cursor AND change it for this window class. */
 #       define ZAP_CURSOR(a,b)                                   \
         case a:                                                  \
@@ -175,6 +177,22 @@
             SetClassLong( window->Window.Handle,                 \
                           GCL_HCURSOR, ( LONG )NULL );           \
         break;
+#else
+#       define MAP_CURSOR(a,b)                                   \
+        case a:                                                  \
+            SetCursor( LoadCursor( NULL, b ) );                  \
+            SetClassLongPtr( window->Window.Handle,              \
+                          GCLP_HCURSOR,                          \
+                          ( LONG )( LONG_PTR )LoadCursor( NULL, b ) );       \
+        break;
+    /* Nuke the cursor AND change it for this window class. */
+#       define ZAP_CURSOR(a,b)                                   \
+        case a:                                                  \
+            SetCursor( NULL );                                   \
+            SetClassLongPtr( window->Window.Handle,              \
+                          GCLP_HCURSOR, ( LONG )( LONG_PTR )NULL );          \
+        break;
+#endif
 
     switch( cursorID )
     {
@@ -232,7 +250,7 @@
     FREEGLUT_EXIT_IF_NOT_INITIALISED ( "glutWarpPointer" );
     FREEGLUT_EXIT_IF_NO_WINDOW ( "glutWarpPointer" );
 
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
 
     XWarpPointer(
         fgDisplay.Display,
@@ -244,7 +262,7 @@
     /* Make the warp visible immediately. */
     XFlush( fgDisplay.Display );
 
-#elif TARGET_HOST_WIN32 || TARGET_HOST_WINCE
+#elif TARGET_HOST_MS_WINDOWS
 
     {
         POINT coords;
diff -ruN freeglut-2.4.0/src/freeglut_display.c freeglut-2.4.0-svn759/src/freeglut_display.c
--- freeglut-2.4.0/src/freeglut_display.c	2005-04-22 08:17:28.000000000 -0600
+++ freeglut-2.4.0-svn759/src/freeglut_display.c	2008-11-09 23:05:14.000000000 -0700
@@ -48,13 +48,17 @@
     FREEGLUT_EXIT_IF_NOT_INITIALISED ( "glutSwapBuffers" );
     FREEGLUT_EXIT_IF_NO_WINDOW ( "glutSwapBuffers" );
 
+    /*
+     * "glXSwapBuffers" already performs an implicit call to "glFlush". What
+     * about "SwapBuffers"?
+     */
     glFlush( );
     if( ! fgStructure.CurrentWindow->Window.DoubleBuffered )
         return;
 
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
     glXSwapBuffers( fgDisplay.Display, fgStructure.CurrentWindow->Window.Handle );
-#elif TARGET_HOST_WIN32 || TARGET_HOST_WINCE
+#elif TARGET_HOST_MS_WINDOWS
     SwapBuffers( fgStructure.CurrentWindow->Window.Device );
 #endif
 
diff -ruN freeglut-2.4.0/src/freeglut_ext.c freeglut-2.4.0-svn759/src/freeglut_ext.c
--- freeglut-2.4.0/src/freeglut_ext.c	2005-05-25 19:14:56.000000000 -0600
+++ freeglut-2.4.0-svn759/src/freeglut_ext.c	2008-11-09 23:05:14.000000000 -0700
@@ -29,7 +29,7 @@
 #include <GL/freeglut.h>
 #include "freeglut_internal.h"
 
-static GLUTproc fghGetProcAddress( const char* procName )
+static GLUTproc fghGetGLUTProcAddress( const char* procName )
 {
     /* optimization: quick initial check */
     if( strncmp( procName, "glut", 4 ) != 0 )
@@ -42,6 +42,7 @@
     CHECK_NAME(glutInitWindowPosition);
     CHECK_NAME(glutInitWindowSize);
     CHECK_NAME(glutMainLoop);
+    CHECK_NAME(glutExit);
     CHECK_NAME(glutCreateWindow);
     CHECK_NAME(glutCreateSubWindow);
     CHECK_NAME(glutDestroyWindow);
@@ -104,9 +105,9 @@
     CHECK_NAME(glutWindowStatusFunc);
     CHECK_NAME(glutKeyboardUpFunc);
     CHECK_NAME(glutSpecialUpFunc);
-#if !TARGET_HOST_WINCE
+#if !defined(_WIN32_WCE)
     CHECK_NAME(glutJoystickFunc);
-#endif /* !TARGET_HOST_WINCE */
+#endif /* !defined(_WIN32_WCE) */
     CHECK_NAME(glutSetColor);
     CHECK_NAME(glutGetColor);
     CHECK_NAME(glutCopyColormap);
@@ -147,20 +148,22 @@
     CHECK_NAME(glutReportErrors);
     CHECK_NAME(glutIgnoreKeyRepeat);
     CHECK_NAME(glutSetKeyRepeat);
-#if !TARGET_HOST_WINCE
+#if !defined(_WIN32_WCE)
     CHECK_NAME(glutForceJoystickFunc);
     CHECK_NAME(glutGameModeString);
     CHECK_NAME(glutEnterGameMode);
     CHECK_NAME(glutLeaveGameMode);
     CHECK_NAME(glutGameModeGet);
-#endif /* !TARGET_HOST_WINCE */
+#endif /* !defined(_WIN32_WCE) */
     /* freeglut extensions */
     CHECK_NAME(glutMainLoopEvent);
     CHECK_NAME(glutLeaveMainLoop);
     CHECK_NAME(glutCloseFunc);
     CHECK_NAME(glutWMCloseFunc);
     CHECK_NAME(glutMenuDestroyFunc);
+    CHECK_NAME(glutFullScreenToggle);
     CHECK_NAME(glutSetOption);
+    CHECK_NAME(glutGetModeValues);
     CHECK_NAME(glutSetWindowData);
     CHECK_NAME(glutGetWindowData);
     CHECK_NAME(glutSetMenuData);
@@ -177,29 +180,46 @@
     CHECK_NAME(glutSolidCylinder);
     CHECK_NAME(glutGetProcAddress);
     CHECK_NAME(glutMouseWheelFunc);
+    CHECK_NAME(glutJoystickGetNumAxes);
+    CHECK_NAME(glutJoystickGetNumButtons);
+    CHECK_NAME(glutJoystickNotWorking);
+    CHECK_NAME(glutJoystickGetDeadBand);
+    CHECK_NAME(glutJoystickSetDeadBand);
+    CHECK_NAME(glutJoystickGetSaturation);
+    CHECK_NAME(glutJoystickSetSaturation);
+    CHECK_NAME(glutJoystickSetMinRange);
+    CHECK_NAME(glutJoystickSetMaxRange);
+    CHECK_NAME(glutJoystickSetCenter);
+    CHECK_NAME(glutJoystickGetMinRange);
+    CHECK_NAME(glutJoystickGetMaxRange);
+    CHECK_NAME(glutJoystickGetCenter);
+    CHECK_NAME(glutInitContextVersion);
+    CHECK_NAME(glutInitContextFlags);
 #undef CHECK_NAME
 
     return NULL;
 }
 
 
+SFG_Proc fghGetProcAddress( const char *procName )
+{
+#if TARGET_HOST_MS_WINDOWS
+    return (SFG_Proc)wglGetProcAddress( ( LPCSTR )procName );
+#elif TARGET_HOST_POSIX_X11 && defined( GLX_ARB_get_proc_address )
+    return (SFG_Proc)glXGetProcAddressARB( ( const GLubyte * )procName );
+#else
+    return NULL;
+#endif
+}
+
+
 GLUTproc FGAPIENTRY
 glutGetProcAddress( const char *procName )
 {
     GLUTproc p;
     FREEGLUT_EXIT_IF_NOT_INITIALISED ( "glutGetProcAddress" );
 
-    /* Try GLUT functions first */
-    p = fghGetProcAddress( procName );
-    if( p != NULL )
-        return p;
-
-    /* Try core GL functions */
-#if TARGET_HOST_WIN32 || TARGET_HOST_WINCE
-    return(GLUTproc)wglGetProcAddress( ( LPCSTR )procName );
-#elif TARGET_HOST_UNIX_X11 && defined( GLX_ARB_get_proc_address )
-    return(GLUTproc)glXGetProcAddressARB( ( const GLubyte * )procName );
-#else
-    return NULL;
-#endif
+    /* Try GLUT functions first, then core GL functions */
+    p = fghGetGLUTProcAddress( procName );
+    return ( p != NULL ) ? p : fghGetProcAddress( procName );
 }
diff -ruN freeglut-2.4.0/src/freeglut_gamemode.c freeglut-2.4.0-svn759/src/freeglut_gamemode.c
--- freeglut-2.4.0/src/freeglut_gamemode.c	2005-05-25 19:14:56.000000000 -0600
+++ freeglut-2.4.0-svn759/src/freeglut_gamemode.c	2008-11-09 23:05:14.000000000 -0700
@@ -46,7 +46,7 @@
  */
 static void fghRememberState( void )
 {
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
 
     /*
      * This highly depends on the XFree86 extensions,
@@ -101,7 +101,7 @@
      */
 #   endif
 
-#elif TARGET_HOST_WIN32 || TARGET_HOST_WINCE
+#elif TARGET_HOST_MS_WINDOWS
 
 /*    DEVMODE devMode; */
 
@@ -125,7 +125,7 @@
  */
 static void fghRestoreState( void )
 {
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
 
 #   ifdef X_XF86VidModeGetAllModeLines
     /* Restore the remembered pointer position: */
@@ -202,7 +202,7 @@
      */
 #   endif
 
-#elif TARGET_HOST_WIN32 || TARGET_HOST_WINCE
+#elif TARGET_HOST_MS_WINDOWS
 
     /* Restore the previously rememebered desktop display settings */
     ChangeDisplaySettings( &fgDisplay.DisplayMode, 0 );
@@ -210,7 +210,7 @@
 #endif
 }
 
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
 #ifdef X_XF86VidModeGetAllModeLines
 
 /*
@@ -257,7 +257,7 @@
 static GLboolean fghChangeDisplayMode( GLboolean haveToTest )
 {
     GLboolean success = GL_FALSE;
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
 
     /*
      * This highly depends on the XFree86 extensions,
@@ -316,7 +316,7 @@
 
 #   endif
 
-#elif TARGET_HOST_WIN32 || TARGET_HOST_WINCE
+#elif TARGET_HOST_MS_WINDOWS
 
     DEVMODE  devMode;
     char *fggmstr = NULL;
@@ -417,8 +417,8 @@
 {
     FREEGLUT_EXIT_IF_NOT_INITIALISED ( "glutEnterGameMode" );
 
-    if( fgStructure.GameMode )
-        fgAddToWindowDestroyList( fgStructure.GameMode );
+    if( fgStructure.GameModeWindow )
+        fgAddToWindowDestroyList( fgStructure.GameModeWindow );
     else
         fghRememberState( );
 
@@ -428,18 +428,17 @@
         return 0;
     }
 
-    fgStructure.GameMode = fgCreateWindow(
-        NULL, "FREEGLUT", 0, 0,
-        fgState.GameModeSize.X, fgState.GameModeSize.Y, GL_TRUE, GL_FALSE
+    fgStructure.GameModeWindow = fgCreateWindow(
+        NULL, "FREEGLUT", GL_TRUE, 0, 0,
+        GL_TRUE, fgState.GameModeSize.X, fgState.GameModeSize.Y,
+        GL_TRUE, GL_FALSE
     );
 
-    fgStructure.GameMode->State.Width  = fgState.GameModeSize.X;
-    fgStructure.GameMode->State.Height = fgState.GameModeSize.Y;
-    fgStructure.GameMode->State.NeedToResize = GL_TRUE;
+    fgStructure.GameModeWindow->State.Width  = fgState.GameModeSize.X;
+    fgStructure.GameModeWindow->State.Height = fgState.GameModeSize.Y;
+    fgStructure.GameModeWindow->State.NeedToResize = GL_TRUE;
 
-    fgStructure.GameMode->State.IsGameMode = GL_TRUE;
-
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
 
     /*
      * Sync needed to avoid a real race, the Xserver must have really created
@@ -457,12 +456,12 @@
      * the application which we have to aviod, so wait until it's viewable:
      */
     while( GrabSuccess != XGrabPointer(
-               fgDisplay.Display, fgStructure.GameMode->Window.Handle,
+               fgDisplay.Display, fgStructure.GameModeWindow->Window.Handle,
                TRUE,
                ButtonPressMask | ButtonReleaseMask | ButtonMotionMask
                | PointerMotionMask,
                GrabModeAsync, GrabModeAsync,
-               fgStructure.GameMode->Window.Handle, None, CurrentTime) )
+               fgStructure.GameModeWindow->Window.Handle, None, CurrentTime) )
         usleep( 100 );
 
     /*
@@ -471,7 +470,7 @@
      */
     XSetInputFocus(
         fgDisplay.Display,
-        fgStructure.GameMode->Window.Handle,
+        fgStructure.GameModeWindow->Window.Handle,
         RevertToNone,
         CurrentTime
     );
@@ -521,7 +520,7 @@
     /* Grab the keyboard, too */
     XGrabKeyboard(
         fgDisplay.Display,
-        fgStructure.GameMode->Window.Handle,
+        fgStructure.GameModeWindow->Window.Handle,
         FALSE,
         GrabModeAsync, GrabModeAsync,
         CurrentTime
@@ -529,7 +528,7 @@
 
 #endif
 
-    return fgStructure.GameMode->ID;
+    return fgStructure.GameModeWindow->ID;
 }
 
 /*
@@ -539,14 +538,12 @@
 {
     FREEGLUT_EXIT_IF_NOT_INITIALISED ( "glutLeaveGameMode" );
 
-    freeglut_return_if_fail( fgStructure.GameMode );
-
-    fgStructure.GameMode->State.IsGameMode = GL_FALSE;
+    freeglut_return_if_fail( fgStructure.GameModeWindow );
 
-    fgAddToWindowDestroyList( fgStructure.GameMode );
-    fgStructure.GameMode = NULL;
+    fgAddToWindowDestroyList( fgStructure.GameModeWindow );
+    fgStructure.GameModeWindow = NULL;
 
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
 
     XUngrabPointer( fgDisplay.Display, CurrentTime );
     XUngrabKeyboard( fgDisplay.Display, CurrentTime );
@@ -566,7 +563,7 @@
     switch( eWhat )
     {
     case GLUT_GAME_MODE_ACTIVE:
-        return !!fgStructure.GameMode;
+        return !!fgStructure.GameModeWindow;
 
     case GLUT_GAME_MODE_POSSIBLE:
         return fghChangeDisplayMode( GL_TRUE );
@@ -587,7 +584,7 @@
         /*
          * This is true if the game mode has been activated successfully..
          */
-        return !!fgStructure.GameMode;
+        return !!fgStructure.GameModeWindow;
     }
 
     fgWarning( "Unknown gamemode get: %d", eWhat );
diff -ruN freeglut-2.4.0/src/freeglut_geometry.c freeglut-2.4.0-svn759/src/freeglut_geometry.c
--- freeglut-2.4.0/src/freeglut_geometry.c	2005-01-03 03:13:26.000000000 -0700
+++ freeglut-2.4.0-svn759/src/freeglut_geometry.c	2008-11-09 23:05:14.000000000 -0700
@@ -960,14 +960,43 @@
 /*
  *
  */
-double icos_r[12][3] = { { 1.0, 0.0, 0.0 },
-  {  0.447213595500,  0.894427191000, 0.0 }, {  0.447213595500,  0.276393202252, 0.850650808354 }, {  0.447213595500, -0.723606797748, 0.525731112119 }, {  0.447213595500, -0.723606797748, -0.525731112119 }, {  0.447213595500,  0.276393202252, -0.850650808354 },
-  { -0.447213595500, -0.894427191000, 0.0 }, { -0.447213595500, -0.276393202252, 0.850650808354 }, { -0.447213595500,  0.723606797748, 0.525731112119 }, { -0.447213595500,  0.723606797748, -0.525731112119 }, { -0.447213595500, -0.276393202252, -0.850650808354 },
-  { -1.0, 0.0, 0.0 } } ;
-int icos_v [20][3] = { { 0, 1, 2 }, { 0, 2, 3 }, { 0, 3, 4 }, { 0, 4, 5 }, { 0, 5, 1 },
-                       { 1, 8, 2 }, { 2, 7, 3 }, { 3, 6, 4 }, { 4, 10, 5 }, { 5, 9, 1 },
-                       { 1, 9, 8 }, { 2, 8, 7 }, { 3, 7, 6 }, { 4, 6, 10 }, { 5, 10, 9 },
-                       { 11, 9, 10 }, { 11, 8, 9 }, { 11, 7, 8 }, { 11, 6, 7 }, { 11, 10, 6 } } ;
+static double icos_r[12][3] = {
+    {  1.0,             0.0,             0.0            },
+    {  0.447213595500,  0.894427191000,  0.0            },
+    {  0.447213595500,  0.276393202252,  0.850650808354 },
+    {  0.447213595500, -0.723606797748,  0.525731112119 },
+    {  0.447213595500, -0.723606797748, -0.525731112119 },
+    {  0.447213595500,  0.276393202252, -0.850650808354 },
+    { -0.447213595500, -0.894427191000,  0.0 },
+    { -0.447213595500, -0.276393202252,  0.850650808354 },
+    { -0.447213595500,  0.723606797748,  0.525731112119 },
+    { -0.447213595500,  0.723606797748, -0.525731112119 },
+    { -0.447213595500, -0.276393202252, -0.850650808354 },
+    { -1.0,             0.0,             0.0            }
+};
+
+static int icos_v [20][3] = {
+    {  0,  1,  2 },
+    {  0,  2,  3 },
+    {  0,  3,  4 },
+    {  0,  4,  5 },
+    {  0,  5,  1 },
+    {  1,  8,  2 },
+    {  2,  7,  3 },
+    {  3,  6,  4 },
+    {  4, 10,  5 },
+    {  5,  9,  1 },
+    {  1,  9,  8 },
+    {  2,  8,  7 },
+    {  3,  7,  6 },
+    {  4,  6, 10 },
+    {  5, 10,  9 },
+    { 11,  9, 10 },
+    { 11,  8,  9 },
+    { 11,  7,  8 },
+    { 11,  6,  7 },
+    { 11, 10,  6 }
+};
 
 void FGAPIENTRY glutWireIcosahedron( void )
 {
@@ -1018,19 +1047,52 @@
 /*
  *
  */
-double rdod_r[14][3] = { { 0.0, 0.0, 1.0 },
-  {  0.707106781187,  0.000000000000,  0.5 }, {  0.000000000000,  0.707106781187,  0.5 }, { -0.707106781187,  0.000000000000,  0.5 }, {  0.000000000000, -0.707106781187,  0.5 },
-  {  0.707106781187,  0.707106781187,  0.0 }, { -0.707106781187,  0.707106781187,  0.0 }, { -0.707106781187, -0.707106781187,  0.0 }, {  0.707106781187, -0.707106781187,  0.0 },
-  {  0.707106781187,  0.000000000000, -0.5 }, {  0.000000000000,  0.707106781187, -0.5 }, { -0.707106781187,  0.000000000000, -0.5 }, {  0.000000000000, -0.707106781187, -0.5 },
-  {  0.0, 0.0, -1.0 } } ;
-int rdod_v [12][4] = { { 0,  1,  5,  2 }, { 0,  2,  6,  3 }, { 0,  3,  7,  4 }, { 0,  4,  8, 1 },
-                       { 5, 10,  6,  2 }, { 6, 11,  7,  3 }, { 7, 12,  8,  4 }, { 8,  9,  5, 1 },
-                       { 5,  9, 13, 10 }, { 6, 10, 13, 11 }, { 7, 11, 13, 12 }, { 8, 12, 13, 9 } } ;
-double rdod_n[12][3] = {
-  {  0.353553390594,  0.353553390594,  0.5 }, { -0.353553390594,  0.353553390594,  0.5 }, { -0.353553390594, -0.353553390594,  0.5 }, {  0.353553390594, -0.353553390594,  0.5 },
-  {  0.000000000000,  1.000000000000,  0.0 }, { -1.000000000000,  0.000000000000,  0.0 }, {  0.000000000000, -1.000000000000,  0.0 }, {  1.000000000000,  0.000000000000,  0.0 },
-  {  0.353553390594,  0.353553390594, -0.5 }, { -0.353553390594,  0.353553390594, -0.5 }, { -0.353553390594, -0.353553390594, -0.5 }, {  0.353553390594, -0.353553390594, -0.5 }
-  } ;
+static double rdod_r[14][3] = {
+    {  0.0,             0.0,             1.0 },
+    {  0.707106781187,  0.000000000000,  0.5 },
+    {  0.000000000000,  0.707106781187,  0.5 },
+    { -0.707106781187,  0.000000000000,  0.5 },
+    {  0.000000000000, -0.707106781187,  0.5 },
+    {  0.707106781187,  0.707106781187,  0.0 },
+    { -0.707106781187,  0.707106781187,  0.0 },
+    { -0.707106781187, -0.707106781187,  0.0 },
+    {  0.707106781187, -0.707106781187,  0.0 },
+    {  0.707106781187,  0.000000000000, -0.5 },
+    {  0.000000000000,  0.707106781187, -0.5 },
+    { -0.707106781187,  0.000000000000, -0.5 },
+    {  0.000000000000, -0.707106781187, -0.5 },
+    {  0.0,             0.0,            -1.0 }
+} ;
+
+static int rdod_v [12][4] = {
+    { 0,  1,  5,  2 },
+    { 0,  2,  6,  3 },
+    { 0,  3,  7,  4 },
+    { 0,  4,  8,  1 },
+    { 5, 10,  6,  2 },
+    { 6, 11,  7,  3 },
+    { 7, 12,  8,  4 },
+    { 8,  9,  5,  1 },
+    { 5,  9, 13, 10 },
+    { 6, 10, 13, 11 },
+    { 7, 11, 13, 12 },
+    { 8, 12, 13,  9 }
+};
+
+static double rdod_n[12][3] = {
+    {  0.353553390594,  0.353553390594,  0.5 },
+    { -0.353553390594,  0.353553390594,  0.5 },
+    { -0.353553390594, -0.353553390594,  0.5 },
+    {  0.353553390594, -0.353553390594,  0.5 },
+    {  0.000000000000,  1.000000000000,  0.0 },
+    { -1.000000000000,  0.000000000000,  0.0 },
+    {  0.000000000000, -1.000000000000,  0.0 },
+    {  1.000000000000,  0.000000000000,  0.0 },
+    {  0.353553390594,  0.353553390594, -0.5 },
+    { -0.353553390594,  0.353553390594, -0.5 },
+    { -0.353553390594, -0.353553390594, -0.5 },
+    {  0.353553390594, -0.353553390594, -0.5 }
+};
 
 void FGAPIENTRY glutWireRhombicDodecahedron( void )
 {
@@ -1096,7 +1158,7 @@
       glEnd () ;
     }
   }
-  else
+  else if ( num_levels > 0 )
   {
     GLdouble local_offset[3] ;  /* Use a local variable to avoid buildup of roundoff errors */
     num_levels -- ;
@@ -1135,7 +1197,7 @@
 
     glEnd () ;
   }
-  else
+  else if ( num_levels > 0 )
   {
     GLdouble local_offset[3] ;  /* Use a local variable to avoid buildup of roundoff errors */
     num_levels -- ;
diff -ruN freeglut-2.4.0/src/freeglut_glutfont_definitions.c freeglut-2.4.0-svn759/src/freeglut_glutfont_definitions.c
--- freeglut-2.4.0/src/freeglut_glutfont_definitions.c	2004-03-13 20:47:46.000000000 -0700
+++ freeglut-2.4.0-svn759/src/freeglut_glutfont_definitions.c	2008-11-09 23:05:14.000000000 -0700
@@ -40,9 +40,10 @@
  * structure to match GLUT.
  */
 
+#include <GL/freeglut.h>
 #include "freeglut_internal.h"
 
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
 
 struct freeglutStrokeFont
 {
@@ -53,15 +54,6 @@
   float bottom ;
 };
 
-struct freeglutBitmapFont
-{
-  const char *name ;
-  const int num_chars ;
-  const int first ;
-  const void *ch ;
-};
-
-
 struct freeglutStrokeFont glutStrokeRoman ;
 struct freeglutStrokeFont glutStrokeMonoRoman ;
 
diff -ruN freeglut-2.4.0/src/freeglut_init.c freeglut-2.4.0-svn759/src/freeglut_init.c
--- freeglut-2.4.0/src/freeglut_init.c	2005-05-04 06:51:53.000000000 -0600
+++ freeglut-2.4.0-svn759/src/freeglut_init.c	2008-11-09 23:05:14.000000000 -0700
@@ -28,6 +28,10 @@
 #include <GL/freeglut.h>
 #include "freeglut_internal.h"
 
+#if TARGET_HOST_POSIX_X11
+#include <limits.h>  /* LONG_MAX */
+#endif
+
 /*
  * TODO BEFORE THE STABLE RELEASE:
  *
@@ -61,15 +65,11 @@
                       GL_FALSE,              /* GLDebugSwitch */
                       GL_FALSE,              /* XSyncSwitch */
                       GLUT_KEY_REPEAT_ON,    /* KeyRepeat */
-                      0xffffffff,            /* Modifiers */
+                      INVALID_MODIFIERS,     /* Modifiers */
                       0,                     /* FPSInterval */
                       0,                     /* SwapCount */
                       0,                     /* SwapTime */
-#if TARGET_HOST_WIN32 || TARGET_HOST_WINCE
-                      { 0, GL_FALSE },       /* Time */
-#else
-                      { { 0, 0 }, GL_FALSE },
-#endif
+                      0,                     /* Time */
                       { NULL, NULL },         /* Timers */
                       { NULL, NULL },         /* FreeTimers */
                       NULL,                   /* IdleCallback */
@@ -82,18 +82,162 @@
                       GLUT_ACTION_EXIT,       /* ActionOnWindowClose */
                       GLUT_EXEC_STATE_INIT,   /* ExecState */
                       NULL,                   /* ProgramName */
-                      GL_FALSE                /* JoysticksInitialised */
+                      GL_FALSE,               /* JoysticksInitialised */
+                      GL_FALSE,               /* InputDevsInitialised */
+                      0,                      /* AuxiliaryBufferNumber */
+                      0,                      /* SampleNumber */
+                      1,                      /* MajorVersion */
+                      0,                      /* MajorVersion */
+                      0                       /* ContextFlags */
 };
 
 
 /* -- PRIVATE FUNCTIONS ---------------------------------------------------- */
 
+#if TARGET_HOST_POSIX_X11
+
+/* Return the atom associated with "name". */
+static Atom fghGetAtom(const char * name)
+{
+  return XInternAtom(fgDisplay.Display, name, False);
+}
+
+/*
+ * Check if "property" is set on "window".  The property's values are returned
+ * through "data".  If the property is set and is of type "type", return the
+ * number of elements in "data".  Return zero otherwise.  In both cases, use
+ * "Xfree()" to free "data".
+ */
+static int fghGetWindowProperty(Window window,
+				Atom property,
+				Atom type,
+				unsigned char ** data)
+{
+  /*
+   * Caller always has to use "Xfree()" to free "data", since
+   * "XGetWindowProperty() always allocates one extra byte in prop_return
+   * [i.e. "data"] (even if the property is zero length) [..]".
+   */
+
+  int status;  /*  Returned by "XGetWindowProperty". */
+
+  Atom          type_returned;
+  int           temp_format;             /*  Not used. */
+  unsigned long number_of_elements;
+  unsigned long temp_bytes_after;        /*  Not used. */
+
+
+  status = XGetWindowProperty(fgDisplay.Display,
+			      window,
+			      property,
+			      0,
+			      LONG_MAX,
+			      False,
+			      type,
+			      &type_returned,
+			      &temp_format,
+			      &number_of_elements,
+			      &temp_bytes_after,
+			      data);
+
+  FREEGLUT_INTERNAL_ERROR_EXIT(status == Success,
+			       "XGetWindowProperty failled",
+			       "fghGetWindowProperty");
+
+  if (type_returned != type)
+    {
+      number_of_elements = 0;
+    }
+
+  return number_of_elements;
+}
+
+/*  Check if the window manager is NET WM compliant. */
+static int fghNetWMSupported(void)
+{
+  Atom wm_check;
+  Window ** window_ptr_1;
+
+  int number_of_windows;
+  int net_wm_supported;
+
+
+  net_wm_supported = 0;
+
+  wm_check = fghGetAtom("_NET_SUPPORTING_WM_CHECK");
+  window_ptr_1 = malloc(sizeof(Window *));
+
+  /*
+   * Check that the window manager has set this property on the root window.
+   * The property must be the ID of a child window.
+   */
+  number_of_windows = fghGetWindowProperty(fgDisplay.RootWindow,
+                                           wm_check,
+                                           XA_WINDOW,
+                                           (unsigned char **) window_ptr_1);
+  if (number_of_windows == 1)
+    {
+      Window ** window_ptr_2;
+
+      window_ptr_2 = malloc(sizeof(Window *));
+
+      /* Check that the window has the same property set to the same value. */
+      number_of_windows = fghGetWindowProperty(**window_ptr_1,
+                                               wm_check,
+                                               XA_WINDOW,
+                                               (unsigned char **) window_ptr_2);
+      if ((number_of_windows == 1) && (**window_ptr_1 == **window_ptr_2))
+      {
+        /* NET WM compliant */
+        net_wm_supported = 1;
+      }
+
+      XFree(*window_ptr_2);
+      free(window_ptr_2);
+    }
+
+        XFree(*window_ptr_1);
+        free(window_ptr_1);
+
+        return net_wm_supported;
+}
+
+/*  Check if "hint" is present in "property" for "window". */
+int fgHintPresent(Window window, Atom property, Atom hint)
+{
+  Atom ** atoms_ptr;
+  int number_of_atoms;
+  int supported;
+  int i;
+
+  supported = 0;
+
+  atoms_ptr = malloc(sizeof(Atom *));
+  number_of_atoms = fghGetWindowProperty(window,
+					 property,
+					 XA_ATOM,
+					 (unsigned char **) atoms_ptr);
+  for (i = 0; i < number_of_atoms; i++)
+    {
+      if ((*atoms_ptr)[i] == hint)
+      {
+          supported = 1;
+          break;
+      }
+    }
+
+  return supported;
+}
+
+#endif /*  TARGET_HOST_POSIX_X11  */
+
+
 /*
  * A call to this function should initialize all the display stuff...
  */
 static void fghInitialize( const char* displayName )
 {
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
     fgDisplay.Display = XOpenDisplay( displayName );
 
     if( fgDisplay.Display == NULL )
@@ -130,13 +274,34 @@
     fgDisplay.Connection = ConnectionNumber( fgDisplay.Display );
 
     /* Create the window deletion atom */
-    fgDisplay.DeleteWindow = XInternAtom(
-        fgDisplay.Display,
-        "WM_DELETE_WINDOW",
-        FALSE
-    );
+    fgDisplay.DeleteWindow = fghGetAtom("WM_DELETE_WINDOW");
+
+    /* Create the state and full screen atoms */
+    fgDisplay.State           = None;
+    fgDisplay.StateFullScreen = None;
+
+    if (fghNetWMSupported())
+    {
+      const Atom supported = fghGetAtom("_NET_SUPPORTED");
+      const Atom state     = fghGetAtom("_NET_WM_STATE");
+      
+      /* Check if the state hint is supported. */
+      if (fgHintPresent(fgDisplay.RootWindow, supported, state))
+      {
+        const Atom full_screen = fghGetAtom("_NET_WM_STATE_FULLSCREEN");
+        
+        fgDisplay.State = state;
+        
+        /* Check if the window manager supports full screen. */
+        /**  Check "_NET_WM_ALLOWED_ACTIONS" on our window instead? **/
+        if (fgHintPresent(fgDisplay.RootWindow, supported, full_screen))
+        {
+          fgDisplay.StateFullScreen = full_screen;
+        }
+      }
+    }
 
-#elif TARGET_HOST_WIN32 || TARGET_HOST_WINCE
+#elif TARGET_HOST_MS_WINDOWS
 
     WNDCLASS wc;
     ATOM atom;
@@ -164,12 +329,12 @@
         wc.hInstance      = fgDisplay.Instance;
         wc.hIcon          = LoadIcon( fgDisplay.Instance, _T("GLUT_ICON") );
 
-#if TARGET_HOST_WIN32
+#if defined(_WIN32_WCE)
+        wc.style          = CS_HREDRAW | CS_VREDRAW;
+#else
         wc.style          = CS_OWNDC | CS_HREDRAW | CS_VREDRAW;
         if (!wc.hIcon)
           wc.hIcon        = LoadIcon( NULL, IDI_WINLOGO );
-#else /* TARGET_HOST_WINCE */
-        wc.style          = CS_HREDRAW | CS_VREDRAW;
 #endif
 
         wc.hCursor        = LoadCursor( NULL, IDC_ARROW );
@@ -202,6 +367,9 @@
 #endif
 
     fgState.Initialised = GL_TRUE;
+
+    /* InputDevice uses GlutTimerFunc(), so fgState.Initialised must be TRUE */
+    fgInitialiseInputDevices();
 }
 
 /*
@@ -221,6 +389,10 @@
     /* If there was a menu created, destroy the rendering context */
     if( fgStructure.MenuContext )
     {
+#if TARGET_HOST_POSIX_X11
+        /* Note that the MVisualInfo is not owned by the MenuContext! */
+        glXDestroyContext( fgDisplay.Display, fgStructure.MenuContext->MContext );
+#endif
         free( fgStructure.MenuContext );
         fgStructure.MenuContext = NULL;
     }
@@ -239,11 +411,19 @@
         free( timer );
     }
 
-#if !TARGET_HOST_WINCE
+#if !defined(_WIN32_WCE)
     if ( fgState.JoysticksInitialised )
         fgJoystickClose( );
-#endif /* !TARGET_HOST_WINCE */
+
+    if ( fgState.InputDevsInitialised )
+        fgInputDeviceClose( );
+#endif /* !defined(_WIN32_WCE) */
     fgState.JoysticksInitialised = GL_FALSE;
+    fgState.InputDevsInitialised = GL_FALSE;
+
+    fgState.MajorVersion = 1;
+    fgState.MinorVersion = 0;
+    fgState.ContextFlags = 0;
 
     fgState.Initialised = GL_FALSE;
 
@@ -266,15 +446,13 @@
     fgState.ExecState           = GLUT_EXEC_STATE_INIT;
 
     fgState.KeyRepeat       = GLUT_KEY_REPEAT_ON;
-    fgState.Modifiers       = 0xffffffff;
+    fgState.Modifiers       = INVALID_MODIFIERS;
 
     fgState.GameModeSize.X  = 640;
     fgState.GameModeSize.Y  = 480;
     fgState.GameModeDepth   =  16;
     fgState.GameModeRefresh =  72;
 
-    fgState.Time.Set = GL_FALSE;
-
     fgListInit( &fgState.Timers );
     fgListInit( &fgState.FreeTimers );
 
@@ -292,7 +470,7 @@
         fgState.ProgramName = NULL;
     }
 
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
 
     /*
      * Make sure all X-client data we have created will be destroyed on
@@ -306,7 +484,7 @@
      */
     XCloseDisplay( fgDisplay.Display );
 
-#elif TARGET_HOST_WIN32 || TARGET_HOST_WINCE
+#elif TARGET_HOST_MS_WINDOWS
 
     /* Reset the timer granularity */
     timeEndPeriod ( 1 );
@@ -320,7 +498,7 @@
  * Everything inside the following #ifndef is copied from the X sources.
  */
 
-#if TARGET_HOST_WIN32 || TARGET_HOST_WINCE
+#if TARGET_HOST_MS_WINDOWS
 
 /*
 
@@ -512,10 +690,11 @@
 
     fgCreateStructure( );
 
-    fgElapsedTime( );
+    /* Get start time */
+    fgState.Time = fgSystemTime();
 
     /* check if GLUT_FPS env var is set */
-#if !TARGET_HOST_WINCE
+#ifndef _WIN32_WCE
     {
         const char *fps = getenv( "GLUT_FPS" );
         if( fps )
@@ -607,7 +786,7 @@
             argv[ i ] = argv[ j ];
     }
 
-#endif /* TARGET_HOST_WINCE */
+#endif /* _WIN32_WCE */
 
     /*
      * Have the display created now. If there wasn't a "-display"
@@ -646,6 +825,14 @@
 }
 
 /*
+ * Undoes all the "glutInit" stuff
+ */
+void FGAPIENTRY glutExit ( void )
+{
+  fgDeinitialize ();
+}
+
+/*
  * Sets the default initial window position for new windows
  */
 void FGAPIENTRY glutInitWindowPosition( int x, int y )
@@ -705,7 +892,7 @@
      * delimited by blanks or tabs.
      */
     char *token ;
-    int len = strlen ( displayMode );
+    size_t len = strlen ( displayMode );
     char *buffer = (char *)malloc ( (len+1) * sizeof(char) );
     memcpy ( buffer, displayMode, len );
     buffer[len] = '\0';
@@ -715,9 +902,16 @@
     {
         /* Process this token */
         int i ;
+
+        /* Temporary fix:  Ignore any length specifications and at least
+         * process the basic token
+         * TODO:  Fix this permanently
+         */
+        size_t cleanlength = strcspn ( token, "=<>~!" );
+
         for ( i = 0; i < NUM_TOKENS; i++ )
         {
-            if ( strcmp ( token, Tokens[i] ) == 0 ) break ;
+            if ( strncmp ( token, Tokens[i], cleanlength ) == 0 ) break ;
         }
 
         switch ( i )
@@ -814,64 +1008,64 @@
         case 20 :  /* "win32pdf": (incorrect spelling but was there before */
         case 21 :  /* "win32pfd":  matches the Win32 Pixel Format Descriptor by
                       number */
-#if TARGET_HOST_WIN32
+#if TARGET_HOST_MS_WINDOWS
 #endif
             break ;
 
         case 22 :  /* "xvisual":  matches the X visual ID by number */
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
 #endif
             break ;
 
         case 23 :  /* "xstaticgray": */
         case 29 :  /* "xstaticgrey":  boolean indicating if the frame buffer
                       configuration's X visual is of type StaticGray */
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
 #endif
             break ;
 
         case 24 :  /* "xgrayscale": */
         case 30 :  /* "xgreyscale":  boolean indicating if the frame buffer
                       configuration's X visual is of type GrayScale */
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
 #endif
             break ;
 
         case 25 :  /* "xstaticcolor": */
         case 31 :  /* "xstaticcolour":  boolean indicating if the frame buffer
                       configuration's X visual is of type StaticColor */
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
 #endif
             break ;
 
         case 26 :  /* "xpseudocolor": */
         case 32 :  /* "xpseudocolour":  boolean indicating if the frame buffer
                       configuration's X visual is of type PseudoColor */
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
 #endif
             break ;
 
         case 27 :  /* "xtruecolor": */
         case 33 :  /* "xtruecolour":  boolean indicating if the frame buffer
                       configuration's X visual is of type TrueColor */
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
 #endif
             break ;
 
         case 28 :  /* "xdirectcolor": */
         case 34 :  /* "xdirectcolour":  boolean indicating if the frame buffer
                       configuration's X visual is of type DirectColor */
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
 #endif
             break ;
 
         case 35 :  /* "borderless":  windows should not have borders */
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
 #endif
             break ;
 
         case 36 :  /* "aux":  some number of aux buffers */
-            glut_state_flag |= GLUT_AUX1;
+            glut_state_flag |= GLUT_AUX;
             break ;
 
         case 37 :  /* Unrecognized */
@@ -889,4 +1083,20 @@
     fgState.DisplayMode = glut_state_flag;
 }
 
+/* -- SETTING OPENGL 3.0 CONTEXT CREATION PARAMETERS ---------------------- */
+
+void FGAPIENTRY glutInitContextVersion( int majorVersion, int minorVersion )
+{
+    /* We will make use of these valuse when creating a new OpenGL context... */
+    fgState.MajorVersion = majorVersion;
+    fgState.MinorVersion = minorVersion;
+}
+
+
+void FGAPIENTRY glutInitContextFlags( int flags )
+{
+    /* We will make use of this value when creating a new OpenGL context... */
+    fgState.ContextFlags = flags;
+}
+
 /*** END OF FILE ***/
diff -ruN freeglut-2.4.0/src/freeglut_input_devices.c freeglut-2.4.0-svn759/src/freeglut_input_devices.c
--- freeglut-2.4.0/src/freeglut_input_devices.c	1969-12-31 17:00:00.000000000 -0700
+++ freeglut-2.4.0-svn759/src/freeglut_input_devices.c	2008-11-09 23:05:20.000000000 -0700
@@ -0,0 +1,380 @@
+/*
+ * freeglut_input_devices.c
+ *
+ * Handles miscellaneous input devices via direct serial-port access.
+ * Proper X11 XInput device support is not yet supported.
+ * Also lacks Mac support.
+ *
+ * Written by Joe Krahn <krahn@niehs.nih.gov> 2005
+ *
+ * Copyright (c) 2005 Stephen J. Baker. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PAWEL W. OLSZTA OR STEPHEN J. BAKER BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#ifdef HAVE_CONFIG_H
+#    include "config.h"
+#endif
+
+#include <GL/freeglut.h>
+#include "freeglut_internal.h"
+
+#if TARGET_HOST_POSIX_X11
+#include <errno.h>
+#include <sys/ioctl.h>
+#include <sys/time.h>
+#include <time.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <termios.h>
+#include <fcntl.h>
+#include <sys/types.h>
+
+typedef struct {
+   int fd;
+   struct termios termio, termio_save;
+} SERIALPORT;
+
+#elif TARGET_HOST_MS_WINDOWS
+#include <sys/types.h>
+#include <winbase.h>
+typedef struct {
+   HANDLE fh;
+   COMMTIMEOUTS timeouts_save;
+   DCB dcb_save;
+} SERIALPORT;
+
+#endif
+
+/********************* Dialbox definitions ***********************/
+
+#define DIAL_NUM_VALUATORS 8
+
+/* dial parser state machine states */
+#define DIAL_NEW                (-1)
+#define DIAL_WHICH_DEVICE       0
+#define DIAL_VALUE_HIGH         1
+#define DIAL_VALUE_LOW          2
+
+/* dial/button box commands */
+#define DIAL_INITIALIZE                 0x20
+#define DIAL_SET_LEDS                   0x75
+#define DIAL_SET_TEXT                   0x61
+#define DIAL_SET_AUTO_DIALS             0x50
+#define DIAL_SET_AUTO_DELTA_DIALS       0x51
+#define DIAL_SET_FILTER                 0x53
+#define DIAL_SET_BUTTONS_MOM_TYPE       0x71
+#define DIAL_SET_AUTO_MOM_BUTTONS       0x73
+#define DIAL_SET_ALL_LEDS               0x4b
+#define DIAL_CLEAR_ALL_LEDS             0x4c
+
+/* dial/button box replies and events */
+#define DIAL_INITIALIZED        0x20
+#define DIAL_BASE               0x30
+#define DIAL_DELTA_BASE         0x40
+#define DIAL_PRESS_BASE         0xc0
+#define DIAL_RELEASE_BASE       0xe0
+
+/* macros to determine reply type */
+#define IS_DIAL_EVENT(ch)       (((ch)>=DIAL_BASE)&&((ch)<DIAL_BASE+DIAL_NUM_VALUATORS))
+#define IS_KEY_PRESS(ch)        (((ch)>=DIAL_PRESS_BASE)&&((ch)<DIAL_PRESS_BASE+DIAL_NUM_BUTTONS))
+#define IS_KEY_RELEASE(ch)      (((ch)>=DIAL_RELEASE_BASE)&&((ch)<DIAL_RELEASE_BASE+DIAL_NUM_BUTTONS))
+#define IS_INIT_EVENT(ch)       ((ch)==DIAL_INITIALIZED)
+
+/*****************************************************************/
+
+static SERIALPORT *serial_open ( const char *device );
+static void serial_close ( SERIALPORT *port );
+static int serial_getchar ( SERIALPORT *port );
+static int serial_putchar ( SERIALPORT *port, unsigned char ch );
+static void serial_flush ( SERIALPORT *port );
+
+static void send_dial_event(int dial, int value);
+static void poll_dials(int id);
+
+/* local variables */
+static SERIALPORT *dialbox_port=NULL;
+
+/*****************************************************************/
+
+/*
+ * Implementation for glutDeviceGet(GLUT_HAS_DIAL_AND_BUTTON_BOX)
+ */
+int fgInputDeviceDetect( void )
+{
+    fgInitialiseInputDevices ();
+
+    if ( !dialbox_port )
+        return 0;
+
+    if ( !fgState.InputDevsInitialised )
+        return 0;
+
+    return 1;
+}
+
+/*
+ * Try initializing the input device(s)
+ */
+void fgInitialiseInputDevices ( void )
+{
+    const char *dial_device=NULL;
+    if( !fgState.InputDevsInitialised )
+    {
+        dial_device = getenv ( "GLUT_DIALS_SERIAL" );
+#if TARGET_HOST_MS_WINDOWS
+        if (!dial_device){
+            static char devname[256];
+            DWORD size=sizeof(devname);
+            DWORD type = REG_SZ;
+            HKEY key;
+            if (RegOpenKeyA(HKEY_LOCAL_MACHINE,"SOFTWARE\\FreeGLUT",&key)==ERROR_SUCCESS) {
+                if (RegQueryValueExA(key,"DialboxSerialPort",NULL,&type,(LPBYTE)devname,&size)==ERROR_SUCCESS){
+                    dial_device=devname;
+                }
+                RegCloseKey(key);
+            }
+        }
+#endif
+        if ( !dial_device ) return;
+        if ( !( dialbox_port = serial_open ( dial_device ) ) ) return;
+        serial_putchar(dialbox_port,DIAL_INITIALIZE);
+        glutTimerFunc ( 10, poll_dials, 0 );
+        fgState.InputDevsInitialised = GL_TRUE;
+    }
+}
+
+/*
+ *
+ */
+void fgInputDeviceClose( void )
+{
+    if ( fgState.InputDevsInitialised )
+    {
+        serial_close ( dialbox_port );
+        dialbox_port = NULL;
+        fgState.InputDevsInitialised = GL_FALSE;
+    }
+}
+
+/********************************************************************/
+
+/* Check all windows for dialbox callbacks */
+static void fghcbEnumDialCallbacks ( SFG_Window *window, SFG_Enumerator *enumerator )
+{
+    /* Built-in to INVOKE_WCB():  if window->Callbacks[CB_Dials] */
+    INVOKE_WCB ( *window,Dials, ( ((int*)enumerator->data)[0], ((int*)enumerator->data)[1]) );
+    fgEnumSubWindows ( window, fghcbEnumDialCallbacks, enumerator );
+}
+
+static void send_dial_event ( int num, int value )
+{
+    SFG_Enumerator enumerator;
+    int data[2];
+    data[0] = num;
+    data[1] = value;
+    enumerator.found = GL_FALSE;
+    enumerator.data  =  data;
+    fgEnumWindows ( fghcbEnumDialCallbacks, &enumerator );
+}
+
+/********************************************************************/
+static void poll_dials ( int id )
+{
+    int data;
+    static int dial_state = DIAL_NEW;
+    static int dial_which;
+    static int dial_value;
+    static int dials[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
+
+    if ( !dialbox_port ) return;
+
+    while ( (data=serial_getchar(dialbox_port)) != EOF )
+    {
+        if ( ( dial_state > DIAL_WHICH_DEVICE ) || IS_DIAL_EVENT ( data ) )
+        {
+            switch ( dial_state )
+            {
+            case DIAL_WHICH_DEVICE:
+                dial_which = data - DIAL_BASE;
+                dial_state++;
+                break;
+            case DIAL_VALUE_HIGH:
+                dial_value = ( data << 8 );
+                dial_state++;
+                break;
+            case DIAL_VALUE_LOW:
+                dial_value |= data;
+                if ( dial_value & 0x8000 ) dial_value -= 0x10000;
+                dials[dial_which] = dial_value;
+                send_dial_event ( dial_which + 1, dial_value * 360 / 256 );
+                dial_state = DIAL_WHICH_DEVICE;
+                break;
+            default:
+                /* error: Impossible state value! */
+                break;
+            }
+        }
+        else if ( data == DIAL_INITIALIZED )
+        {
+            fgState.InputDevsInitialised = GL_TRUE;
+            dial_state = DIAL_WHICH_DEVICE;
+            serial_putchar(dialbox_port,DIAL_SET_AUTO_DIALS);
+            serial_putchar(dialbox_port,0xff);
+            serial_putchar(dialbox_port,0xff);
+        }
+        else  /* Unknown data; try flushing. */
+            serial_flush(dialbox_port);
+    }
+
+    glutTimerFunc ( 2, poll_dials, 0 );
+}
+
+
+/******** OS Specific Serial I/O routines *******/
+#if TARGET_HOST_POSIX_X11 /* ==> Linux/BSD/UNIX POSIX serial I/O */
+static SERIALPORT *serial_open ( const char *device )
+{
+    int fd;
+    struct termios termio;
+    SERIALPORT *port;
+
+    fd = open(device, O_RDWR | O_NONBLOCK );
+    if (fd <0) {
+        perror(device);
+        return NULL;
+    }
+
+    port = malloc(sizeof(SERIALPORT));
+    memset(port, 0, sizeof(SERIALPORT));
+    port->fd = fd;
+
+    /* save current port settings */
+    tcgetattr(fd,&port->termio_save);
+
+    memset(&termio, 0, sizeof(termio));
+    termio.c_cflag = CS8 | CREAD | HUPCL ;
+    termio.c_iflag = IGNPAR | IGNBRK ;
+    termio.c_cc[VTIME]    = 0;   /* inter-character timer */
+    termio.c_cc[VMIN]     = 1;   /* block read until 1 chars received, when blocking I/O */
+
+    cfsetispeed(&termio, B9600);
+    cfsetospeed(&termio, B9600);
+    tcsetattr(fd,TCSANOW,&termio);
+
+    serial_flush(port);
+    return port;
+}
+
+static void serial_close(SERIALPORT *port)
+{
+    if (port)
+    {
+        /* restore old port settings */
+        tcsetattr(port->fd,TCSANOW,&port->termio_save);
+        close(port->fd);
+        free(port);
+    }
+}
+
+static int serial_getchar(SERIALPORT *port)
+{
+    unsigned char ch;
+    if (!port) return EOF;
+    if (read(port->fd,&ch,1)) return ch;
+    return EOF;
+}
+
+static int serial_putchar(SERIALPORT *port, unsigned char ch){
+    if (!port) return 0;
+    return write(port->fd,&ch,1);
+}
+
+static void serial_flush ( SERIALPORT *port )
+{
+    tcflush ( port->fd, TCIOFLUSH );
+}
+
+#elif TARGET_HOST_MS_WINDOWS
+
+static SERIALPORT *serial_open(const char *device){
+    HANDLE fh;
+    DCB dcb={sizeof(DCB)};
+    COMMTIMEOUTS timeouts;
+    SERIALPORT *port;
+
+    fh = CreateFile(device,GENERIC_READ|GENERIC_WRITE,0,NULL,
+      OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
+    if (!fh) return NULL;
+
+    port = malloc(sizeof(SERIALPORT));
+    ZeroMemory(port, sizeof(SERIALPORT));
+    port->fh = fh;
+
+    /* save current port settings */
+    GetCommState(fh,&port->dcb_save);
+    GetCommTimeouts(fh,&port->timeouts_save);
+
+    dcb.DCBlength=sizeof(DCB);
+    BuildCommDCB("96,n,8,1",&dcb);
+    SetCommState(fh,&dcb);
+
+    ZeroMemory(&timeouts,sizeof(timeouts));
+    timeouts.ReadTotalTimeoutConstant=1;
+    timeouts.WriteTotalTimeoutConstant=1;
+    SetCommTimeouts(fh,&timeouts);
+
+    serial_flush(port);
+
+    return port;
+}
+
+static void serial_close(SERIALPORT *port){
+    if (port){
+        /* restore old port settings */
+        SetCommState(port->fh,&port->dcb_save);
+        SetCommTimeouts(port->fh,&port->timeouts_save);
+        CloseHandle(port->fh);
+        free(port);
+    }
+}
+
+static int serial_getchar(SERIALPORT *port){
+    DWORD n;
+    unsigned char ch;
+    if (!port) return EOF;
+    if (!ReadFile(port->fh,&ch,1,&n,NULL)) return EOF;
+    if (n==1) return ch;
+    return EOF;
+}
+
+static int serial_putchar(SERIALPORT *port, unsigned char ch){
+    DWORD n;
+    if (!port) return 0;
+    return WriteFile(port->fh,&ch,1,&n,NULL);
+}
+
+static void serial_flush ( SERIALPORT *port )
+{
+    FlushFileBuffers(port->fh);
+}
+
+#endif
diff -ruN freeglut-2.4.0/src/freeglut_internal.h freeglut-2.4.0-svn759/src/freeglut_internal.h
--- freeglut-2.4.0/src/freeglut_internal.h	2005-06-02 16:39:32.000000000 -0600
+++ freeglut-2.4.0-svn759/src/freeglut_internal.h	2008-11-09 23:05:14.000000000 -0700
@@ -37,42 +37,88 @@
 #define  VERSION_MINOR 4
 #define  VERSION_PATCH 0
 
-/* Freeglut is meant to be available under all Unix/X11 and Win32 platforms. */
-#if defined(_WIN32_WCE)
-#   define  TARGET_HOST_UNIX_X11    0
-#   define  TARGET_HOST_WIN32       0
-#   define  TARGET_HOST_WINCE       1
-#elif defined(_MSC_VER) || defined(__CYGWIN__) || defined(__MINGW32__)
-#   define  TARGET_HOST_UNIX_X11    0
-#   define  TARGET_HOST_WIN32       1
-#   define  TARGET_HOST_WINCE       0
+/* Freeglut is intended to function under all Unix/X11 and Win32 platforms. */
+/* XXX: Don't all MS-Windows compilers (except Cygwin) have _WIN32 defined?
+ * XXX: If so, remove the first set of defined()'s below.
+ */
+#if defined(_MSC_VER) || defined(__WATCOMC__) || defined(__MINGW32__) \
+    || defined(_WIN32) || defined(_WIN32_WCE) \
+    || ( defined(__CYGWIN__) && defined(X_DISPLAY_MISSING) )
+#   define  TARGET_HOST_MS_WINDOWS 1
+
+#elif defined(__posix__) || defined(__unix__) || defined(__linux__)
+#   define  TARGET_HOST_POSIX_X11  1
+
+/* FIXME: no Macintosh support?
+#if ...
+#   define  TARGET_HOST_MAC_OSX    1
 #else
-#   define  TARGET_HOST_UNIX_X11    1
-#   define  TARGET_HOST_WIN32       0
-#   define  TARGET_HOST_WINCE       0
+#   error "Unrecognized target host!"
+*/
 #endif
 
-#define  FREEGLUT_MAX_MENUS         3
+#ifndef TARGET_HOST_MS_WINDOWS
+#   define  TARGET_HOST_MS_WINDOWS 0
+#endif
 
-/* Somehow all Win32 include headers depend on this one: */
-#if TARGET_HOST_WIN32
-#include <windows.h>
-#include <windowsx.h>
-#include <mmsystem.h>
-#include <TCHAR.H>
+#ifndef  TARGET_HOST_POSIX_X11
+#   define  TARGET_HOST_POSIX_X11  0
 #endif
 
-#if defined(_MSC_VER)
-#define strdup   _strdup
+#ifndef  TARGET_HOST_MAC_OSX
+#   define  TARGET_HOST_MAC_OSX    0
+#endif
+
+/* -- FIXED CONFIGURATION LIMITS ------------------------------------------- */
+
+#define  FREEGLUT_MAX_MENUS         3
+
+/* -- PLATFORM-SPECIFIC INCLUDES ------------------------------------------- */
+
+/* All Win32 headers depend on the huge Windows.h recursive include.
+ * Note: Let's use proper case for MS-Win headers. Even though it's
+ * not required due to case insensitivity, it's a good habit to keep
+ * because the cross-platform includes are case sensitive.
+ */
+#if TARGET_HOST_MS_WINDOWS && !defined(_WIN32_WCE)
+#    include <Windows.h>
+#    include <WindowsX.h>
+#    include <MMSystem.h>
+/* CYGWIN does not have tchar.h, but has TEXT(x), defined in winnt.h. */
+#    ifndef __CYGWIN__
+#      include <tchar.h>
+#    else
+#      define _TEXT(x) TEXT(x)
+#      define _T(x)    TEXT(x)
+#    endif
+
+#elif TARGET_HOST_POSIX_X11
+#    include <GL/glx.h>
+#    include <X11/Xlib.h>
+#    include <X11/Xatom.h>
+#    include <X11/keysym.h>
+#    include <X11/extensions/XInput.h>
+#    ifdef HAVE_X11_EXTENSIONS_XF86VMODE_H
+#        include <X11/extensions/xf86vmode.h>
+#    endif
+/* If GLX is too old, we will fail during runtime when multisampling
+   is requested, but at least freeglut compiles. */
+#    ifndef GLX_SAMPLE_BUFFERS
+#        define GLX_SAMPLE_BUFFERS 0x80A8
+#    endif
+#    ifndef GLX_SAMPLES
+#        define GLX_SAMPLES 0x80A9
+#    endif
+
 #endif
 
-/* Those files should be available on every platform. */
-#include <GL/gl.h>
-#include <GL/glu.h>
+/* These files should be available on every platform. */
 #include <stdio.h>
 #include <string.h>
 #include <math.h>
 #include <stdlib.h>
+
+/* These are included based on autoconf directives. */
 #if HAVE_SYS_TYPES_H
 #    include <sys/types.h>
 #endif
@@ -82,27 +128,52 @@
 #if TIME_WITH_SYS_TIME
 #    include <sys/time.h>
 #    include <time.h>
+#elif HAVE_SYS_TIME_H
+#    include <sys/time.h>
 #else
-#    if HAVE_SYS_TIME_H
-#        include <sys/time.h>
+#    include <time.h>
+#endif
+
+/* -- AUTOCONF HACKS --------------------------------------------------------*/
+
+/* XXX: Update autoconf to avoid these.
+ * XXX: Are non-POSIX platforms intended not to use autoconf?
+ * If so, perhaps there should be a config_guess.h for them. Alternatively,
+ * config guesses could be placed above, just after the config.h exclusion.
+ */
+#if defined(__FreeBSD__) || defined(__NetBSD__)
+#    define HAVE_USB_JS 1
+#    if defined(__NetBSD__) || ( defined(__FreeBSD__) && __FreeBSD_version >= 500000)
+#        define HAVE_USBHID_H 1
+#    endif
+#endif
+
+#if TARGET_HOST_MS_WINDOWS
+#    define  HAVE_VPRINTF 1
+#endif
+
+#if !defined(HAVE_VPRINTF) && !defined(HAVE_DOPRNT)
+/* XXX warning directive here? */
+#    define  HAVE_VPRINTF 1
+#endif
+
+/* MinGW may lack a prototype for ChangeDisplaySettingsEx() (depending on the version?) */
+#if TARGET_HOST_MS_WINDOWS && !defined(ChangeDisplaySettingsEx)
+LONG WINAPI ChangeDisplaySettingsExA(LPCSTR,LPDEVMODEA,HWND,DWORD,LPVOID);
+LONG WINAPI ChangeDisplaySettingsExW(LPCWSTR,LPDEVMODEW,HWND,DWORD,LPVOID);
+#    ifdef UNICODE
+#        define ChangeDisplaySettingsEx ChangeDisplaySettingsExW
 #    else
-#        include <time.h>
+#        define ChangeDisplaySettingsEx ChangeDisplaySettingsExA
 #    endif
 #endif
 
-/* The system-dependant include files should go here: */
-#if TARGET_HOST_UNIX_X11
-    #include <GL/glx.h>
-    #include <X11/Xlib.h>
-    #include <X11/Xatom.h>
-    #include <X11/keysym.h>
-
-    #ifdef HAVE_X11_EXTENSIONS_XF86VMODE_H
-    #include <X11/extensions/xf86vmode.h>
-    #endif
+#if defined(_MSC_VER) || defined(__WATCOMC__)
+/* strdup() is non-standard, for all but POSIX-2001 */
+#define strdup   _strdup
 #endif
 
-/* Microsoft VisualC++ 5.0's <math.h> does not define the PI */
+/* M_PI is non-standard (defined by BSD, not ISO-C) */
 #ifndef M_PI
 #    define  M_PI  3.14159265358979323846
 #endif
@@ -115,6 +186,10 @@
 #    define  FALSE  0
 #endif
 
+/* General defines */
+
+#define INVALID_MODIFIERS 0xffffffff
+
 /* -- GLOBAL TYPE DEFINITIONS ---------------------------------------------- */
 
 /* Freeglut callbacks type definitions */
@@ -177,18 +252,6 @@
     GLboolean       Use;                /* ...and a single boolean.          */
 };
 
-/* A helper structure holding a timeval and a boolean */
-typedef struct tagSFG_Time SFG_Time;
-struct tagSFG_Time
-{
-#if TARGET_HOST_WIN32 || TARGET_HOST_WINCE
-    DWORD Value;
-#else
-    struct timeval  Value;
-#endif
-    GLboolean       Set;
-};
-
 /*
  * An enumeration containing the state of the GLUT execution:
  * initializing, running, or stopping
@@ -225,7 +288,7 @@
     GLuint           SwapCount;            /* Count of glutSwapBuffer calls  */
     GLuint           SwapTime;             /* Time of last SwapBuffers       */
 
-    SFG_Time         Time;                 /* Time that glutInit was called  */
+    unsigned long    Time;                 /* Time that glutInit was called  */
     SFG_List         Timers;               /* The freeglut timer hooks       */
     SFG_List         FreeTimers;           /* The unused timer hooks         */
 
@@ -244,18 +307,28 @@
     fgExecutionState ExecState;           /* Used for GLUT termination       */
     char            *ProgramName;         /* Name of the invoking program    */
     GLboolean        JoysticksInitialised;  /* Only initialize if application calls for them */
+    GLboolean        InputDevsInitialised;  /* Only initialize if application calls for them */
+
+    int              AuxiliaryBufferNumber;  /* Number of auxiliary buffers */
+    int              SampleNumber;         /*  Number of samples per pixel  */
+
+    int              MajorVersion;         /* Major OpenGL context version  */
+    int              MinorVersion;         /* Minor OpenGL context version  */
+    int              ContextFlags;         /* OpenGL context flags          */
 };
 
 /* The structure used by display initialization in freeglut_init.c */
 typedef struct tagSFG_Display SFG_Display;
 struct tagSFG_Display
 {
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
     Display*        Display;            /* The display we are being run in.  */
     int             Screen;             /* The screen we are about to use.   */
     Window          RootWindow;         /* The screen's root window.         */
     int             Connection;         /* The display's connection number   */
     Atom            DeleteWindow;       /* The window deletion atom          */
+    Atom            State;              /* The state atom                    */
+    Atom            StateFullScreen;    /* The full screen atom              */
 
 #ifdef X_XF86VidModeGetModeLine
     /*
@@ -270,9 +343,9 @@
     int             DisplayPointerX;    /* saved X location of the pointer   */
     int             DisplayPointerY;    /* saved Y location of the pointer   */
 
-#endif
+#endif /* X_XF86VidModeGetModeLine */
 
-#elif TARGET_HOST_WIN32 || TARGET_HOST_WINCE
+#elif TARGET_HOST_MS_WINDOWS
     HINSTANCE        Instance;          /* The application's instance        */
     DEVMODE         DisplayMode;        /* Desktop's display settings        */
 
@@ -299,12 +372,12 @@
  * Make "freeglut" window handle and context types so that we don't need so
  * much conditionally-compiled code later in the library.
  */
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
 
 typedef Window     SFG_WindowHandleType ;
 typedef GLXContext SFG_WindowContextType ;
 
-#elif TARGET_HOST_WIN32 || TARGET_HOST_WINCE
+#elif TARGET_HOST_MS_WINDOWS
 
 typedef HWND    SFG_WindowHandleType ;
 typedef HGLRC   SFG_WindowContextType ;
@@ -321,9 +394,9 @@
     SFG_WindowHandleType  Handle;    /* The window's handle                 */
     SFG_WindowContextType Context;   /* The window's OpenGL/WGL context     */
 
-#if TARGET_HOST_UNIX_X11
-    XVisualInfo*    VisualInfo;      /* The window's visual information     */
-#elif TARGET_HOST_WIN32 || TARGET_HOST_WINCE
+#if TARGET_HOST_POSIX_X11
+    GLXFBConfig*    FBConfig;        /* The window's FBConfig               */
+#elif TARGET_HOST_MS_WINDOWS
     HDC             Device;          /* The window's device context         */
 #endif
 
@@ -352,7 +425,6 @@
     GLboolean       IgnoreKeyRepeat;    /* Whether to ignore key repeat.     */
     GLboolean       KeyRepeating;       /* Currently in repeat mode          */
 
-    GLboolean       IsGameMode;         /* Is this the game mode window?     */
     GLboolean       NeedToResize;       /* Do we need to resize the window?  */
 };
 
@@ -422,7 +494,7 @@
  * current window.
  *
  */
-#if TARGET_HOST_WIN32
+#if TARGET_HOST_MS_WINDOWS && !defined(_WIN32_WCE) /* FIXME: also WinCE? */
 #define INVOKE_WCB(window,cbname,arg_list)    \
 do                                            \
 {                                             \
@@ -499,11 +571,7 @@
 typedef struct tagSFG_MenuContext SFG_MenuContext;
 struct tagSFG_MenuContext
 {
-#if TARGET_HOST_UNIX_X11
-    XVisualInfo*        VisualInfo;       /* The window's visual information */
-#endif
-
-    SFG_WindowContextType Context;        /* The menu window's WGL context   */
+    SFG_WindowContextType MContext;       /* The menu window's WGL context   */
 };
 
 /* This structure describes a menu */
@@ -578,19 +646,19 @@
 typedef struct tagSFG_Structure SFG_Structure;
 struct tagSFG_Structure
 {
-    SFG_List        Windows;      /* The global windows list            */
-    SFG_List        Menus;        /* The global menus list              */
+    SFG_List        Windows;         /* The global windows list            */
+    SFG_List        Menus;           /* The global menus list              */
     SFG_List        WindowsToDestroy;
 
-    SFG_Window*     CurrentWindow; /* The currently set window          */
-    SFG_Menu*       CurrentMenu;   /* Same, but menu...                 */
+    SFG_Window*     CurrentWindow;   /* The currently set window          */
+    SFG_Menu*       CurrentMenu;     /* Same, but menu...                 */
 
-    SFG_MenuContext* MenuContext; /* OpenGL rendering context for menus */
+    SFG_MenuContext* MenuContext;    /* OpenGL rendering context for menus */
 
-    SFG_Window*      GameMode;    /* The game mode window               */
+    SFG_Window*      GameModeWindow; /* The game mode window               */
 
-    int              WindowID;    /* The new current window ID          */
-    int              MenuID;      /* The new current menu ID            */
+    int              WindowID;       /* The new current window ID          */
+    int              MenuID;         /* The new current menu ID            */
 };
 
 /*
@@ -728,12 +796,12 @@
 void fgDestroyStructure( void );
 
 /* A helper function to check if a display mode is possible to use */
-#if TARGET_HOST_UNIX_X11
-XVisualInfo* fgChooseVisual( void );
+#if TARGET_HOST_POSIX_X11
+GLXFBConfig* fgChooseFBConfig( void );
 #endif
 
 /* The window procedure for Win32 events handling */
-#if TARGET_HOST_WIN32 || TARGET_HOST_WINCE
+#if TARGET_HOST_MS_WINDOWS
 LRESULT CALLBACK fgWindowProc( HWND hWnd, UINT uMsg,
                                WPARAM wParam, LPARAM lParam );
 GLboolean fgSetupPixelFormat( SFG_Window* window, GLboolean checkOnly,
@@ -746,12 +814,14 @@
  * Defined in freeglut_structure.c, freeglut_window.c.
  */
 SFG_Window* fgCreateWindow( SFG_Window* parent, const char* title,
-                            int x, int y, int w, int h,
+                            GLboolean positionUse, int x, int y,
+                            GLboolean sizeUse, int w, int h,
                             GLboolean gameMode, GLboolean isMenu );
 void        fgSetWindow ( SFG_Window *window );
 void        fgOpenWindow( SFG_Window* window, const char* title,
-                          int x, int y, int w, int h, GLboolean gameMode,
-                          GLboolean isSubWindow );
+                          GLboolean positionUse, int x, int y,
+                          GLboolean sizeUse, int w, int h,
+                          GLboolean gameMode, GLboolean isSubWindow );
 void        fgCloseWindow( SFG_Window* window );
 void        fgAddToWindowDestroyList ( SFG_Window* window );
 void        fgCloseWindows ();
@@ -767,10 +837,10 @@
 void        fgJoystickClose( void );
 void        fgJoystickPollWindow( SFG_Window* window );
 
-/* More joystick functions.  Should these go into the API?  */
-int  glutJoystickGetNumAxes( int ident );
-int  glutJoystickGetNumButtons( int ident );
-int  glutJoystickNotWorking( int ident );
+/* InputDevice Initialisation and Closure */
+int         fgInputDeviceDetect( void );
+void        fgInitialiseInputDevices( void );
+void        fgInputDeviceClose( void );
 
 /* Setting the cursor for a given window */
 void fgSetCursor ( SFG_Window *window, int cursorID );
@@ -830,6 +900,9 @@
 /* Elapsed time as per glutGet(GLUT_ELAPSED_TIME). */
 long fgElapsedTime( void );
 
+/* System time in milliseconds */
+long unsigned fgSystemTime(void);
+
 /* List functions */
 void fgListInit(SFG_List *list);
 void fgListAppend(SFG_List *list, SFG_Node *node);
@@ -841,6 +914,15 @@
 void fgError( const char *fmt, ... );
 void fgWarning( const char *fmt, ... );
 
+/*
+ * Check if "hint" is present in "property" for "window".  See freeglut_init.c
+ */
+#if TARGET_HOST_POSIX_X11
+int fgHintPresent(Window window, Atom property, Atom hint);
+#endif
+
+SFG_Proc fghGetProcAddress( const char *procName );
+
 #endif /* FREEGLUT_INTERNAL_H */
 
 /*** END OF FILE ***/
diff -ruN freeglut-2.4.0/src/freeglut_joystick.c freeglut-2.4.0-svn759/src/freeglut_joystick.c
--- freeglut-2.4.0/src/freeglut_joystick.c	2005-05-04 06:53:48.000000000 -0600
+++ freeglut-2.4.0-svn759/src/freeglut_joystick.c	2008-11-09 23:05:14.000000000 -0700
@@ -59,7 +59,7 @@
 #    include <IOKit/hid/IOHIDLib.h>
 #endif
 
-#if TARGET_HOST_WIN32
+#if TARGET_HOST_MS_WINDOWS && !defined(_WIN32_WCE)
 #    define _JS_MAX_AXES  8
 #    include <windows.h>
 #    include <mmsystem.h>
@@ -67,7 +67,7 @@
 
 #endif
 
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
 #    define _JS_MAX_AXES 16
 #    if HAVE_SYS_IOCTL_H
 #        include <sys/ioctl.h>
@@ -80,7 +80,7 @@
 /* XXX The below hack is done until freeglut's autoconf is updated. */
 #        define HAVE_USB_JS    1
 
-#        if defined(__FreeBSD__) && __FreeBSD_version >= 500000
+#        if defined(__FreeBSD__)
 #            include <sys/joystick.h>
 #        else
 /*
@@ -385,14 +385,14 @@
          maxReport[_JS_MAX_AXES];
 #endif
 
-#if TARGET_HOST_WIN32
+#if TARGET_HOST_MS_WINDOWS && !defined(_WIN32_WCE)
     JOYCAPS     jsCaps;
     JOYINFOEX   js;
     UINT        js_id;
 #endif
 
 
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
 #   if defined(__FreeBSD__) || defined(__NetBSD__)
        struct os_specific_s *os;
 #   endif
@@ -455,7 +455,7 @@
  */
 static void fghJoystickRawRead( SFG_Joystick* joy, int* buttons, float* axes )
 {
-#if TARGET_HOST_WIN32
+#if TARGET_HOST_MS_WINDOWS && !defined(_WIN32_WCE)
     MMRESULT status;
 #else
     int status;
@@ -531,7 +531,7 @@
     }
 #endif
 
-#if TARGET_HOST_WIN32
+#if TARGET_HOST_MS_WINDOWS && !defined(_WIN32_WCE)
     status = joyGetPosEx( joy->js_id, &joy->js );
 
     if ( status != JOYERR_NOERROR )
@@ -597,7 +597,7 @@
     }
 #endif
 
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
 #    if defined(__FreeBSD__) || defined(__NetBSD__)
     if ( joy->os->is_analog )
     {
@@ -656,9 +656,9 @@
                if (usage > 0 && usage < _JS_MAX_BUTTONS + 1)
                {
                    if (d)
-                       joy->os->cache_buttons |= (1 << usage - 1);
+                       joy->os->cache_buttons |=  (1 << ( usage - 1 ));
                    else
-                       joy->os->cache_buttons &= ~(1 << usage - 1);
+                       joy->os->cache_buttons &= ~(1 << ( usage - 1 ));
                }
             }
         }
@@ -975,11 +975,11 @@
 }
 #endif
 
-#if TARGET_HOST_WIN32
+#if TARGET_HOST_MS_WINDOWS && !defined(_WIN32_WCE)
 /* Inspired by
    http://msdn.microsoft.com/archive/en-us/dnargame/html/msdn_sidewind3d.asp
  */
-#    if defined(_MSC_VER)
+#    if FREEGLUT_LIB_PRAGMAS
 #        pragma comment (lib, "advapi32.lib")
 #    endif
 
@@ -1039,7 +1039,7 @@
 
 static void fghJoystickOpen( SFG_Joystick* joy )
 {
-    int i;
+    int i = 0;
 #if TARGET_HOST_MACINTOSH
     OSStatus err;
 #endif
@@ -1053,17 +1053,22 @@
         CFDictionaryRef props;
     CFTypeRef topLevelElement;
 #endif
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
 #    if defined( __FreeBSD__ ) || defined( __NetBSD__ )
        char *cp;
 #    endif
 #    ifdef JS_NEW
        unsigned char u;
 #    else
-       int counter;
+#      if defined( __linux__ )
+         int counter = 0;
+#      endif
 #    endif
 #endif
 
+    /* Silence gcc, the correct #ifdefs would be too fragile... */
+    (void)i;
+
     /*
      * Default values (for no joystick -- each conditional will reset the
      * error flag)
@@ -1222,7 +1227,7 @@
     CFRelease( props );
 #endif
 
-#if TARGET_HOST_WIN32
+#if TARGET_HOST_MS_WINDOWS && !defined(_WIN32_WCE)
     joy->js.dwFlags = JOY_RETURNALL;
     joy->js.dwSize  = sizeof( joy->js );
 
@@ -1284,7 +1289,7 @@
     }
 #endif
 
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
 #if defined( __FreeBSD__ ) || defined( __NetBSD__ )
     for( i = 0; i < _JS_MAX_AXES; i++ )
         joy->os->cache_axes[ i ] = 0.0f;
@@ -1530,7 +1535,7 @@
     }
 #endif
 
-#if TARGET_HOST_WIN32
+#if TARGET_HOST_MS_WINDOWS && !defined(_WIN32_WCE)
     switch( ident )
     {
     case 0:
@@ -1548,7 +1553,7 @@
     }
 #endif
 
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
 #    if defined( __FreeBSD__ ) || defined( __NetBSD__ )
     fgJoystick[ ident ]->id = ident;
     fgJoystick[ ident ]->error = GL_FALSE;
@@ -1581,15 +1586,14 @@
  */
 void fgInitialiseJoysticks ( void )
 {
-  /* Initialization courtesy of OpenGLUT -- do we want it? */
-  if( !fgState.JoysticksInitialised )
-  {
-    int ident ;
-    for ( ident = 0; ident < MAX_NUM_JOYSTICKS; ident++ )
-      fghJoystickInit( ident );
+    if( !fgState.JoysticksInitialised )
+    {
+        int ident ;
+        for ( ident = 0; ident < MAX_NUM_JOYSTICKS; ident++ )
+            fghJoystickInit( ident );
 
-    fgState.JoysticksInitialised = GL_TRUE;
-  }
+        fgState.JoysticksInitialised = GL_TRUE;
+    }
 }
 
 /*
@@ -1614,11 +1618,11 @@
                 close( fgJoystick[ ident ]->hidDev );
 #endif
 
-#if TARGET_HOST_WIN32
+#if TARGET_HOST_MS_WINDOWS && !defined(_WIN32_WCE)
             /* Do nothing special */
 #endif
 
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
 #if defined( __FreeBSD__ ) || defined( __NetBSD__ )
             if( fgJoystick[ident]->os )
             {
@@ -1680,21 +1684,18 @@
  */
 int fgJoystickDetect( void )
 {
-  int ident;
-
-  fgInitialiseJoysticks ();
+    int ident;
 
-  if ( !fgJoystick )
-    return 0;
+    fgInitialiseJoysticks ();
 
-  if ( !fgState.JoysticksInitialised )
-    return 0;
+    if ( !fgState.JoysticksInitialised )
+        return 0;
 
-  for( ident=0; ident<MAX_NUM_JOYSTICKS; ident++ )
-    if( fgJoystick[ident] && !fgJoystick[ident]->error )
-      return 1;
+    for( ident=0; ident<MAX_NUM_JOYSTICKS; ident++ )
+        if( fgJoystick[ident] && !fgJoystick[ident]->error )
+            return 1;
 
-  return 0;
+    return 0;
 }
 
 /*
diff -ruN freeglut-2.4.0/src/freeglut_main.c freeglut-2.4.0-svn759/src/freeglut_main.c
--- freeglut-2.4.0/src/freeglut_main.c	2005-06-02 16:28:41.000000000 -0600
+++ freeglut-2.4.0-svn759/src/freeglut_main.c	2008-11-09 23:05:14.000000000 -0700
@@ -29,19 +29,15 @@
 #include "freeglut_internal.h"
 #include <errno.h>
 #include <stdarg.h>
-#if TARGET_HOST_WIN32
+#if  HAVE_VPRINTF
 #    define VFPRINTF(s,f,a) vfprintf((s),(f),(a))
+#elif HAVE_DOPRNT
+#    define VFPRINTF(s,f,a) _doprnt((f),(a),(s))
 #else
-#    if HAVE_VPRINTF
-#        define VFPRINTF(s,f,a) vfprintf((s),(f),(a))
-#    elif HAVE_DOPRNT
-#        define VFPRINTF(s,f,a) _doprnt((f),(a),(s))
-#    else
-#        define VFPRINTF(s,f,a)
-#    endif
+#    define VFPRINTF(s,f,a)
 #endif
 
-#if TARGET_HOST_WINCE
+#ifdef _WIN32_WCE
 
 typedef struct GXDisplayProperties GXDisplayProperties;
 typedef struct GXKeyList GXKeyList;
@@ -55,7 +51,7 @@
 
 struct GXKeyList gxKeyList;
 
-#endif
+#endif /* _WIN32_WCE */
 
 /*
  * Try to get the maximum value allowed for ints, falling back to the minimum
@@ -69,7 +65,7 @@
 #endif
 
 #ifndef MIN
-#define MIN(a,b) (((a)<(b)) ? (a) : (b))
+#    define MIN(a,b) (((a)<(b)) ? (a) : (b))
 #endif
 
 
@@ -98,13 +94,13 @@
     freeglut_return_if_fail( window != NULL );
 
 
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
 
     XResizeWindow( fgDisplay.Display, window->Window.Handle,
                    width, height );
     XFlush( fgDisplay.Display ); /* XXX Shouldn't need this */
 
-#elif TARGET_HOST_WIN32
+#elif TARGET_HOST_MS_WINDOWS && !defined(_WIN32_WCE)
     {
         RECT winRect;
         int x, y, w, h;
@@ -124,7 +120,7 @@
 
         if ( window->Parent == NULL )
         {
-            if ( ! window->IsMenu && !window->State.IsGameMode )
+            if ( ! window->IsMenu && (window != fgStructure.GameModeWindow) )
             {
                 w += GetSystemMetrics( SM_CXSIZEFRAME ) * 2;
                 h += GetSystemMetrics( SM_CYSIZEFRAME ) * 2 +
@@ -158,7 +154,7 @@
 
     /*
      * XXX Should update {window->State.OldWidth, window->State.OldHeight}
-     * XXX to keep in lockstep with UNIX_X11 code.
+     * XXX to keep in lockstep with POSIX_X11 code.
      */
     if( FETCH_WCB( *window, Reshape ) )
         INVOKE_WCB( *window, Reshape, ( width, height ) );
@@ -225,9 +221,9 @@
     {
         window->State.Redisplay = GL_FALSE;
 
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
         fghRedrawWindow ( window ) ;
-#elif TARGET_HOST_WIN32 || TARGET_HOST_WINCE
+#elif TARGET_HOST_MS_WINDOWS
         RedrawWindow(
             window->Window.Handle, NULL, NULL,
             RDW_NOERASE | RDW_INTERNALPAINT | RDW_INVALIDATE | RDW_UPDATENOW
@@ -262,9 +258,9 @@
     if( window->State.JoystickLastPoll + window->State.JoystickPollRate <=
         checkTime )
     {
-#if !TARGET_HOST_WINCE
+#if !defined(_WIN32_WCE)
         fgJoystickPollWindow( window );
-#endif /* !TARGET_HOST_WINCE */
+#endif /* !defined(_WIN32_WCE) */
         window->State.JoystickLastPoll = checkTime;
     }
 
@@ -305,42 +301,32 @@
     }
 }
 
+ 
+/* Platform-dependent time in milliseconds, as an unsigned 32-bit integer.
+ * This value wraps every 49.7 days, but integer overflows cancel
+ * when subtracting an initial start time, unless the total time exceeds
+ * 32-bit, where the GLUT API return value is also overflowed.
+ */  
+unsigned long fgSystemTime(void) {
+#if HAVE_GETTIMEOFDAY
+    struct timeval now;
+    gettimeofday( &now, NULL );
+    return now.tv_usec/1000 + now.tv_sec*1000;
+#elif TARGET_HOST_MS_WINDOWS
+#    if defined(_WIN32_WCE)
+    return GetTickCount();
+#    else
+    return timeGetTime();
+#    endif
+#endif
+}
+  
 /*
  * Elapsed Time
  */
 long fgElapsedTime( void )
 {
-    if ( fgState.Time.Set )
-    {
-#if TARGET_HOST_UNIX_X11
-        struct timeval now;
-        long elapsed;
-
-        gettimeofday( &now, NULL );
-
-        elapsed = (now.tv_usec - fgState.Time.Value.tv_usec) / 1000;
-        elapsed += (now.tv_sec - fgState.Time.Value.tv_sec) * 1000;
-
-        return elapsed;
-#elif TARGET_HOST_WIN32
-        return timeGetTime() - fgState.Time.Value;
-#elif TARGET_HOST_WINCE
-        return GetTickCount() - fgState.Time.Value;
-#endif
-    }
-    else
-    {
-#if TARGET_HOST_UNIX_X11
-        gettimeofday( &fgState.Time.Value, NULL );
-#elif TARGET_HOST_WIN32
-        fgState.Time.Value = timeGetTime ();
-#elif TARGET_HOST_WINCE
-        fgState.Time.Value = GetTickCount();
-#endif
-        fgState.Time.Set = GL_TRUE ;
-
-        return 0 ;
-    }
+    return (long) (fgSystemTime() - fgState.Time);
 }
 
 /*
@@ -413,7 +399,7 @@
 }
 static void fghHavePendingRedisplaysCallback( SFG_Window* w, SFG_Enumerator* e)
 {
-    if( w->State.Redisplay )
+    if( w->State.Redisplay && w->State.Visible )
     {
         e->found = GL_TRUE;
         e->data = w;
@@ -461,7 +447,7 @@
     if( fghHaveJoystick( ) && ( msec > 10 ) )     
         msec = 10;
 
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
     /*
      * Possibly due to aggressive use of XFlush() and friends,
      * it is possible to have our socket drained but still have
@@ -488,24 +474,24 @@
         if( ( -1 == err ) && ( errno != EINTR ) )
             fgWarning ( "freeglut select() error: %d", errno );
     }
-#elif TARGET_HOST_WIN32 || TARGET_HOST_WINCE
-    MsgWaitForMultipleObjects( 0, NULL, FALSE, msec, QS_ALLEVENTS );
+#elif TARGET_HOST_MS_WINDOWS
+    MsgWaitForMultipleObjects( 0, NULL, FALSE, msec, QS_ALLINPUT );
 #endif
 }
 
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
 /*
- * Returns GLUT modifier mask for an XEvent.
+ * Returns GLUT modifier mask for the state field of an X11 event.
  */
-static int fghGetXModifiers( XEvent *event )
+static int fghGetXModifiers( int state )
 {
     int ret = 0;
 
-    if( event->xkey.state & ( ShiftMask | LockMask ) )
+    if( state & ( ShiftMask | LockMask ) )
         ret |= GLUT_ACTIVE_SHIFT;
-    if( event->xkey.state & ControlMask )
+    if( state & ControlMask )
         ret |= GLUT_ACTIVE_CTRL;
-    if( event->xkey.state & Mod1Mask )
+    if( state & Mod1Mask )
         ret |= GLUT_ACTIVE_ALT;
 
     return ret;
@@ -513,6 +499,450 @@
 #endif
 
 
+#if TARGET_HOST_POSIX_X11 && _DEBUG
+
+static const char* fghTypeToString( int type )
+{
+    switch( type ) {
+    case KeyPress: return "KeyPress";
+    case KeyRelease: return "KeyRelease";
+    case ButtonPress: return "ButtonPress";
+    case ButtonRelease: return "ButtonRelease";
+    case MotionNotify: return "MotionNotify";
+    case EnterNotify: return "EnterNotify";
+    case LeaveNotify: return "LeaveNotify";
+    case FocusIn: return "FocusIn";
+    case FocusOut: return "FocusOut";
+    case KeymapNotify: return "KeymapNotify";
+    case Expose: return "Expose";
+    case GraphicsExpose: return "GraphicsExpose";
+    case NoExpose: return "NoExpose";
+    case VisibilityNotify: return "VisibilityNotify";
+    case CreateNotify: return "CreateNotify";
+    case DestroyNotify: return "DestroyNotify";
+    case UnmapNotify: return "UnmapNotify";
+    case MapNotify: return "MapNotify";
+    case MapRequest: return "MapRequest";
+    case ReparentNotify: return "ReparentNotify";
+    case ConfigureNotify: return "ConfigureNotify";
+    case ConfigureRequest: return "ConfigureRequest";
+    case GravityNotify: return "GravityNotify";
+    case ResizeRequest: return "ResizeRequest";
+    case CirculateNotify: return "CirculateNotify";
+    case CirculateRequest: return "CirculateRequest";
+    case PropertyNotify: return "PropertyNotify";
+    case SelectionClear: return "SelectionClear";
+    case SelectionRequest: return "SelectionRequest";
+    case SelectionNotify: return "SelectionNotify";
+    case ColormapNotify: return "ColormapNotify";
+    case ClientMessage: return "ClientMessage";
+    case MappingNotify: return "MappingNotify";
+    default: return "UNKNOWN";
+    }
+}
+
+static const char* fghBoolToString( Bool b )
+{
+    return b == False ? "False" : "True";
+}
+
+static const char* fghNotifyHintToString( char is_hint )
+{
+    switch( is_hint ) {
+    case NotifyNormal: return "NotifyNormal";
+    case NotifyHint: return "NotifyHint";
+    default: return "UNKNOWN";
+    }
+}
+
+static const char* fghNotifyModeToString( int mode )
+{
+    switch( mode ) {
+    case NotifyNormal: return "NotifyNormal";
+    case NotifyGrab: return "NotifyGrab";
+    case NotifyUngrab: return "NotifyUngrab";
+    case NotifyWhileGrabbed: return "NotifyWhileGrabbed";
+    default: return "UNKNOWN";
+    }
+}
+
+static const char* fghNotifyDetailToString( int detail )
+{
+    switch( detail ) {
+    case NotifyAncestor: return "NotifyAncestor";
+    case NotifyVirtual: return "NotifyVirtual";
+    case NotifyInferior: return "NotifyInferior";
+    case NotifyNonlinear: return "NotifyNonlinear";
+    case NotifyNonlinearVirtual: return "NotifyNonlinearVirtual";
+    case NotifyPointer: return "NotifyPointer";
+    case NotifyPointerRoot: return "NotifyPointerRoot";
+    case NotifyDetailNone: return "NotifyDetailNone";
+    default: return "UNKNOWN";
+    }
+}
+
+static const char* fghVisibilityToString( int state ) {
+    switch( state ) {
+    case VisibilityUnobscured: return "VisibilityUnobscured";
+    case VisibilityPartiallyObscured: return "VisibilityPartiallyObscured";
+    case VisibilityFullyObscured: return "VisibilityFullyObscured";
+    default: return "UNKNOWN";
+    }
+}
+
+static const char* fghConfigureDetailToString( int detail )
+{
+    switch( detail ) {
+    case Above: return "Above";
+    case Below: return "Below";
+    case TopIf: return "TopIf";
+    case BottomIf: return "BottomIf";
+    case Opposite: return "Opposite";
+    default: return "UNKNOWN";
+    }
+}
+
+static const char* fghPlaceToString( int place )
+{
+    switch( place ) {
+    case PlaceOnTop: return "PlaceOnTop";
+    case PlaceOnBottom: return "PlaceOnBottom";
+    default: return "UNKNOWN";
+    }
+}
+
+static const char* fghMappingRequestToString( int request )
+{
+    switch( request ) {
+    case MappingModifier: return "MappingModifier";
+    case MappingKeyboard: return "MappingKeyboard";
+    case MappingPointer: return "MappingPointer";
+    default: return "UNKNOWN";
+    }
+}
+
+static const char* fghPropertyStateToString( int state )
+{
+    switch( state ) {
+    case PropertyNewValue: return "PropertyNewValue";
+    case PropertyDelete: return "PropertyDelete";
+    default: return "UNKNOWN";
+    }
+}
+
+static const char* fghColormapStateToString( int state )
+{
+    switch( state ) {
+    case ColormapUninstalled: return "ColormapUninstalled";
+    case ColormapInstalled: return "ColormapInstalled";
+    default: return "UNKNOWN";
+    }
+}
+
+static void fghPrintEvent( XEvent *event )
+{
+    switch( event->type ) {
+
+    case KeyPress:
+    case KeyRelease: {
+        XKeyEvent *e = &event->xkey;
+        fgWarning( "%s: window=0x%x, root=0x%x, subwindow=0x%x, time=%lu, "
+                   "(x,y)=(%d,%d), (x_root,y_root)=(%d,%d), state=0x%x, "
+                   "keycode=%u, same_screen=%s", fghTypeToString( e->type ),
+                   e->window, e->root, e->subwindow, (unsigned long)e->time,
+                   e->x, e->y, e->x_root, e->y_root, e->state, e->keycode,
+                   fghBoolToString( e->same_screen ) );
+        break;
+    }
+
+    case ButtonPress:
+    case ButtonRelease: {
+        XButtonEvent *e = &event->xbutton;
+        fgWarning( "%s: window=0x%x, root=0x%x, subwindow=0x%x, time=%lu, "
+                   "(x,y)=(%d,%d), (x_root,y_root)=(%d,%d), state=0x%x, "
+                   "button=%u, same_screen=%d", fghTypeToString( e->type ),
+                   e->window, e->root, e->subwindow, (unsigned long)e->time,
+                   e->x, e->y, e->x_root, e->y_root, e->state, e->button,
+                   fghBoolToString( e->same_screen ) );
+        break;
+    }
+
+    case MotionNotify: {
+        XMotionEvent *e = &event->xmotion;
+        fgWarning( "%s: window=0x%x, root=0x%x, subwindow=0x%x, time=%lu, "
+                   "(x,y)=(%d,%d), (x_root,y_root)=(%d,%d), state=0x%x, "
+                   "is_hint=%s, same_screen=%d", fghTypeToString( e->type ),
+                   e->window, e->root, e->subwindow, (unsigned long)e->time,
+                   e->x, e->y, e->x_root, e->y_root, e->state,
+                   fghNotifyHintToString( e->is_hint ),
+                   fghBoolToString( e->same_screen ) );
+        break;
+    }
+
+    case EnterNotify:
+    case LeaveNotify: {
+        XCrossingEvent *e = &event->xcrossing;
+        fgWarning( "%s: window=0x%x, root=0x%x, subwindow=0x%x, time=%lu, "
+                   "(x,y)=(%d,%d), mode=%s, detail=%s, same_screen=%d, "
+                   "focus=%d, state=0x%x", fghTypeToString( e->type ),
+                   e->window, e->root, e->subwindow, (unsigned long)e->time,
+                   e->x, e->y, fghNotifyModeToString( e->mode ),
+                   fghNotifyDetailToString( e->detail ), (int)e->same_screen,
+                   (int)e->focus, e->state );
+        break;
+    }
+
+    case FocusIn:
+    case FocusOut: {
+        XFocusChangeEvent *e = &event->xfocus;
+        fgWarning( "%s: window=0x%x, mode=%s, detail=%s",
+                   fghTypeToString( e->type ), e->window,
+                   fghNotifyModeToString( e->mode ),
+                   fghNotifyDetailToString( e->detail ) );
+        break;
+    }
+
+    case KeymapNotify: {
+        XKeymapEvent *e = &event->xkeymap;
+        char buf[32 * 2 + 1];
+        int i;
+        for ( i = 0; i < 32; i++ ) {
+            snprintf( &buf[ i * 2 ], sizeof( buf ) - i * 2,
+                      "%02x", e->key_vector[ i ] );
+        }
+        buf[ i ] = '\0';
+        fgWarning( "%s: window=0x%x, %s", fghTypeToString( e->type ), e->window,
+                   buf );
+        break;
+    }
+
+    case Expose: {
+        XExposeEvent *e = &event->xexpose;
+        fgWarning( "%s: window=0x%x, (x,y)=(%d,%d), (width,height)=(%d,%d), "
+                   "count=%d", fghTypeToString( e->type ), e->window, e->x,
+                   e->y, e->width, e->height, e->count );
+        break;
+    }
+
+    case GraphicsExpose: {
+        XGraphicsExposeEvent *e = &event->xgraphicsexpose;
+        fgWarning( "%s: drawable=0x%x, (x,y)=(%d,%d), (width,height)=(%d,%d), "
+                   "count=%d, (major_code,minor_code)=(%d,%d)",
+                   fghTypeToString( e->type ), e->drawable, e->x, e->y,
+                   e->width, e->height, e->count, e->major_code,
+                   e->minor_code );
+        break;
+    }
+
+    case NoExpose: {
+        XNoExposeEvent *e = &event->xnoexpose;
+        fgWarning( "%s: drawable=0x%x, (major_code,minor_code)=(%d,%d)",
+                   fghTypeToString( e->type ), e->drawable, e->major_code,
+                   e->minor_code );
+        break;
+    }
+
+    case VisibilityNotify: {
+        XVisibilityEvent *e = &event->xvisibility;
+        fgWarning( "%s: window=0x%x, state=%s", fghTypeToString( e->type ),
+                   e->window, fghVisibilityToString( e->state) );
+        break;
+    }
+
+    case CreateNotify: {
+        XCreateWindowEvent *e = &event->xcreatewindow;
+        fgWarning( "%s: (x,y)=(%d,%d), (width,height)=(%d,%d), border_width=%d, "
+                   "window=0x%x, override_redirect=%s",
+                   fghTypeToString( e->type ), e->x, e->y, e->width, e->height,
+                   e->border_width, e->window,
+                   fghBoolToString( e->override_redirect ) );
+        break;
+    }
+
+    case DestroyNotify: {
+        XDestroyWindowEvent *e = &event->xdestroywindow;
+        fgWarning( "%s: event=0x%x, window=0x%x",
+                   fghTypeToString( e->type ), e->event, e->window );
+        break;
+    }
+
+    case UnmapNotify: {
+        XUnmapEvent *e = &event->xunmap;
+        fgWarning( "%s: event=0x%x, window=0x%x, from_configure=%s",
+                   fghTypeToString( e->type ), e->event, e->window,
+                   fghBoolToString( e->from_configure ) );
+        break;
+    }
+
+    case MapNotify: {
+        XMapEvent *e = &event->xmap;
+        fgWarning( "%s: event=0x%x, window=0x%x, override_redirect=%s",
+                   fghTypeToString( e->type ), e->event, e->window,
+                   fghBoolToString( e->override_redirect ) );
+        break;
+    }
+
+    case MapRequest: {
+        XMapRequestEvent *e = &event->xmaprequest;
+        fgWarning( "%s: parent=0x%x, window=0x%x",
+                   fghTypeToString( event->type ), e->parent, e->window );
+        break;
+    }
+
+    case ReparentNotify: {
+        XReparentEvent *e = &event->xreparent;
+        fgWarning( "%s: event=0x%x, window=0x%x, parent=0x%x, (x,y)=(%d,%d), "
+                   "override_redirect=%s", fghTypeToString( e->type ),
+                   e->event, e->window, e->parent, e->x, e->y,
+                   fghBoolToString( e->override_redirect ) );
+        break;
+    }
+
+    case ConfigureNotify: {
+        XConfigureEvent *e = &event->xconfigure;
+        fgWarning( "%s: event=0x%x, window=0x%x, (x,y)=(%d,%d), "
+                   "(width,height)=(%d,%d), border_width=%d, above=0x%x, "
+                   "override_redirect=%s", fghTypeToString( e->type ), e->event,
+                   e->window, e->x, e->y, e->width, e->height, e->border_width,
+                   e->above, fghBoolToString( e->override_redirect ) );
+        break;
+    }
+
+    case ConfigureRequest: {
+        XConfigureRequestEvent *e = &event->xconfigurerequest;
+        fgWarning( "%s: parent=0x%x, window=0x%x, (x,y)=(%d,%d), "
+                   "(width,height)=(%d,%d), border_width=%d, above=0x%x, "
+                   "detail=%s, value_mask=%lx", fghTypeToString( e->type ),
+                   e->parent, e->window, e->x, e->y, e->width, e->height,
+                   e->border_width, e->above,
+                   fghConfigureDetailToString( e->detail ), e->value_mask );
+        break;
+    }
+
+    case GravityNotify: {
+        XGravityEvent *e = &event->xgravity;
+        fgWarning( "%s: event=0x%x, window=0x%x, (x,y)=(%d,%d)",
+                   fghTypeToString( e->type ), e->event, e->window, e->x, e->y );
+        break;
+    }
+
+    case ResizeRequest: {
+        XResizeRequestEvent *e = &event->xresizerequest;
+        fgWarning( "%s: window=0x%x, (width,height)=(%d,%d)",
+                   fghTypeToString( e->type ), e->window, e->width, e->height );
+        break;
+    }
+
+    case CirculateNotify: {
+        XCirculateEvent *e = &event->xcirculate;
+        fgWarning( "%s: event=0x%x, window=0x%x, place=%s",
+                   fghTypeToString( e->type ), e->event, e->window,
+                   fghPlaceToString( e->place ) );
+        break;
+    }
+
+    case CirculateRequest: {
+        XCirculateRequestEvent *e = &event->xcirculaterequest;
+        fgWarning( "%s: parent=0x%x, window=0x%x, place=%s",
+                   fghTypeToString( e->type ), e->parent, e->window,
+                   fghPlaceToString( e->place ) );
+        break;
+    }
+
+    case PropertyNotify: {
+        XPropertyEvent *e = &event->xproperty;
+        fgWarning( "%s: window=0x%x, atom=%lu, time=%lu, state=%s",
+                   fghTypeToString( e->type ), e->window,
+                   (unsigned long)e->atom, (unsigned long)e->time,
+                   fghPropertyStateToString( e->state ) );
+        break;
+    }
+
+    case SelectionClear: {
+        XSelectionClearEvent *e = &event->xselectionclear;
+        fgWarning( "%s: window=0x%x, selection=%lu, time=%lu",
+                   fghTypeToString( e->type ), e->window,
+                   (unsigned long)e->selection, (unsigned long)e->time );
+        break;
+    }
+
+    case SelectionRequest: {
+        XSelectionRequestEvent *e = &event->xselectionrequest;
+        fgWarning( "%s: owner=0x%x, requestor=0x%x, selection=0x%x, "
+                   "target=0x%x, property=%lu, time=%lu",
+                   fghTypeToString( e->type ), e->owner, e->requestor,
+                   (unsigned long)e->selection, (unsigned long)e->target,
+                   (unsigned long)e->property, (unsigned long)e->time );
+        break;
+    }
+
+    case SelectionNotify: {
+        XSelectionEvent *e = &event->xselection;
+        fgWarning( "%s: requestor=0x%x, selection=0x%x, target=0x%x, "
+                   "property=%lu, time=%lu", fghTypeToString( e->type ),
+                   e->requestor, (unsigned long)e->selection,
+                   (unsigned long)e->target, (unsigned long)e->property,
+                   (unsigned long)e->time );
+        break;
+    }
+
+    case ColormapNotify: {
+        XColormapEvent *e = &event->xcolormap;
+        fgWarning( "%s: window=0x%x, colormap=%lu, new=%s, state=%s",
+                   fghTypeToString( e->type ), e->window,
+                   (unsigned long)e->colormap, fghBoolToString( e->new ),
+                   fghColormapStateToString( e->state ) );
+        break;
+    }
+
+    case ClientMessage: {
+        XClientMessageEvent *e = &event->xclient;
+        char buf[ 61 ];
+        char* p = buf;
+        char* end = buf + sizeof( buf );
+        int i;
+        switch( e->format ) {
+        case 8:
+          for ( i = 0; i < 20; i++, p += 3 ) {
+                snprintf( p, end - p, " %02x", e->data.b[ i ] );
+            }
+            break;
+        case 16:
+            for ( i = 0; i < 10; i++, p += 5 ) {
+                snprintf( p, end - p, " %04x", e->data.s[ i ] );
+            }
+            break;
+        case 32:
+            for ( i = 0; i < 5; i++, p += 9 ) {
+                snprintf( p, end - p, " %08lx", e->data.l[ i ] );
+            }
+            break;
+        }
+        *p = '\0';
+        fgWarning( "%s: window=0x%x, message_type=%lu, format=%d, data=(%s )",
+                   fghTypeToString( e->type ), e->window,
+                   (unsigned long)e->message_type, e->format, buf );
+        break;
+    }
+
+    case MappingNotify: {
+        XMappingEvent *e = &event->xmapping;
+        fgWarning( "%s: window=0x%x, request=%s, first_keycode=%d, count=%d",
+                   fghTypeToString( e->type ), e->window,
+                   fghMappingRequestToString( e->request ), e->first_keycode,
+                   e->count );
+        break;
+    }
+
+    default: {
+        fgWarning( "%s", fghTypeToString( event->type ) );
+        break;
+    }
+    }
+}
+
+#endif
+
 /* -- INTERFACE FUNCTIONS -------------------------------------------------- */
 
 /*
@@ -520,7 +950,7 @@
  */
 void FGAPIENTRY glutMainLoopEvent( void )
 {
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
     SFG_Window* window;
     XEvent event;
 
@@ -539,6 +969,9 @@
     while( XPending( fgDisplay.Display ) )
     {
         XNextEvent( fgDisplay.Display, &event );
+#if _DEBUG
+        fghPrintEvent( &event );
+#endif
 
         switch( event.type )
         {
@@ -570,20 +1003,20 @@
              *
              * GLUT presumably does this because it generally tries to treat
              * sub-windows the same as windows.
-             *
-             * XXX Technically, GETWINDOW( xconfigure ) and
-             * XXX {event.xconfigure} may not be legit ways to get at
-             * XXX data for CreateNotify events.  In practice, the data
-             * XXX is in a union which is laid out much the same either
-             * XXX way.  But if you want to split hairs, this isn't legit,
-             * XXX and we should instead duplicate some code.
              */
         case CreateNotify:
         case ConfigureNotify:
-            GETWINDOW( xconfigure );
             {
-                int width = event.xconfigure.width;
-                int height = event.xconfigure.height;
+                int width, height;
+                if( event.type == CreateNotify ) {
+                    GETWINDOW( xcreatewindow );
+                    width = event.xcreatewindow.width;
+                    height = event.xcreatewindow.height;
+                } else {
+                    GETWINDOW( xconfigure );
+                    width = event.xconfigure.width;
+                    height = event.xconfigure.height;
+                }
 
                 if( ( width != window->State.OldWidth ) ||
                     ( height != window->State.OldHeight ) )
@@ -633,11 +1066,13 @@
             break;
 
         case MapNotify:
+            break;
+
         case UnmapNotify:
-            /*
-             * If we never do anything with this, can we just not ask to
-             * get these messages?
-             */
+            /* We get this when iconifying a window. */ 
+            GETWINDOW( xunmap );
+            INVOKE_WCB( *window, WindowStatus, ( GLUT_HIDDEN ) );
+            window->State.Visible = GL_FALSE;
             break;
 
         case MappingNotify:
@@ -650,20 +1085,15 @@
 
         case VisibilityNotify:
         {
-            GETWINDOW( xvisibility );
-            /*
-             * XXX INVOKE_WCB() does this check for us.
-             */
-            if( ! FETCH_WCB( *window, WindowStatus ) )
-                break;
-            fgSetWindow( window );
-
             /*
              * Sending this event, the X server can notify us that the window
              * has just acquired one of the three possible visibility states:
              * VisibilityUnobscured, VisibilityPartiallyObscured or
-             * VisibilityFullyObscured
+             * VisibilityFullyObscured. Note that we DO NOT receive a
+             * VisibilityNotify event when iconifying a window, we only get an
+             * UnmapNotify then.
              */
+            GETWINDOW( xvisibility );
             switch( event.xvisibility.state )
             {
             case VisibilityUnobscured:
@@ -729,14 +1159,15 @@
              * XXX track ButtonPress/ButtonRelease events in our own
              * XXX bit-mask?
              */
-#define BUTTON_MASK \
-  ( Button1Mask | Button2Mask | Button3Mask | Button4Mask | Button5Mask )
-            if ( event.xmotion.state & BUTTON_MASK )
+	    fgState.Modifiers = fghGetXModifiers( event.xmotion.state );
+            if ( event.xmotion.state & ( Button1Mask | Button2Mask | Button3Mask | Button4Mask | Button5Mask ) ) {
                 INVOKE_WCB( *window, Motion, ( event.xmotion.x,
                                                event.xmotion.y ) );
-            else
+            } else {
                 INVOKE_WCB( *window, Passive, ( event.xmotion.x,
                                                 event.xmotion.y ) );
+	    }
+	    fgState.Modifiers = INVALID_MODIFIERS;
         }
         break;
 
@@ -782,7 +1213,7 @@
                 ! FETCH_WCB( *window, MouseWheel ) )
                 break;
 
-            fgState.Modifiers = fghGetXModifiers( &event );
+            fgState.Modifiers = fghGetXModifiers( event.xbutton.state );
 
             /* Finally execute the mouse or mouse wheel callback */
             if( ( button < glutDeviceGet ( GLUT_NUM_MOUSE_BUTTONS ) ) || ( ! FETCH_WCB( *window, MouseWheel ) ) )
@@ -817,9 +1248,7 @@
                                                        event.xbutton.y )
                     );
             }
-
-            /* Trash the modifiers state */
-            fgState.Modifiers = 0xffffffff;
+            fgState.Modifiers = INVALID_MODIFIERS;
         }
         break;
 
@@ -861,7 +1290,10 @@
             /* Cease processing this event if it is auto repeated */
 
             if (window->State.KeyRepeating)
+            {
+                if (event.type == KeyPress) window->State.KeyRepeating = GL_FALSE;
                 break;
+            }
 
             if( event.type == KeyPress )
             {
@@ -894,11 +1326,11 @@
                     if( keyboard_cb )
                     {
                         fgSetWindow( window );
-                        fgState.Modifiers = fghGetXModifiers( &event );
+                        fgState.Modifiers = fghGetXModifiers( event.xkey.state );
                         keyboard_cb( asciiCode[ 0 ],
                                      event.xkey.x, event.xkey.y
                         );
-                        fgState.Modifiers = 0xffffffff;
+                        fgState.Modifiers = INVALID_MODIFIERS;
                     }
                 }
                 else
@@ -948,9 +1380,9 @@
                     if( special_cb && (special != -1) )
                     {
                         fgSetWindow( window );
-                        fgState.Modifiers = fghGetXModifiers( &event );
+                        fgState.Modifiers = fghGetXModifiers( event.xkey.state );
                         special_cb( special, event.xkey.x, event.xkey.y );
-                        fgState.Modifiers = 0xffffffff;
+                        fgState.Modifiers = INVALID_MODIFIERS;
                     }
                 }
             }
@@ -960,13 +1392,17 @@
         case ReparentNotify:
             break; /* XXX Should disable this event */
 
+        /* Not handled */
+        case GravityNotify:
+            break;
+
         default:
-            fgWarning ("Unknown X event type: %d", event.type);
+            fgWarning ("Unknown X event type: %d\n", event.type);
             break;
         }
     }
 
-#elif TARGET_HOST_WIN32 || TARGET_HOST_WINCE
+#elif TARGET_HOST_MS_WINDOWS
 
     MSG stMsg;
 
@@ -1008,13 +1444,13 @@
 {
     int action;
 
-#if TARGET_HOST_WIN32 || TARGET_HOST_WINCE
+#if TARGET_HOST_MS_WINDOWS
     SFG_Window *window = (SFG_Window *)fgStructure.Windows.First ;
 #endif
 
     FREEGLUT_EXIT_IF_NOT_INITIALISED ( "glutMainLoop" );
 
-#if TARGET_HOST_WIN32 || TARGET_HOST_WINCE
+#if TARGET_HOST_MS_WINDOWS
     /*
      * Processing before the main loop:  If there is a window which is open and
      * which has a visibility callback, call it.  I know this is an ugly hack,
@@ -1093,7 +1529,7 @@
 }
 
 
-#if TARGET_HOST_WIN32 || TARGET_HOST_WINCE
+#if TARGET_HOST_MS_WINDOWS
 /*
  * Determine a GLUT modifer mask based on MS-WINDOWS system info.
  */
@@ -1116,7 +1552,7 @@
 {
     SFG_Window* window;
     PAINTSTRUCT ps;
-    LONG lRet = 1;
+    LRESULT lRet = 1;
 
     FREEGLUT_INTERNAL_ERROR_EXIT_IF_NOT_INITIALISED ( "Event Handler" ) ;
 
@@ -1141,20 +1577,20 @@
         {
             unsigned int current_DisplayMode = fgState.DisplayMode;
             fgState.DisplayMode = GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH;
-#if !TARGET_HOST_WINCE
+#if !defined(_WIN32_WCE)
             fgSetupPixelFormat( window, GL_FALSE, PFD_MAIN_PLANE );
 #endif
             fgState.DisplayMode = current_DisplayMode;
 
             if( fgStructure.MenuContext )
                 wglMakeCurrent( window->Window.Device,
-                                fgStructure.MenuContext->Context
+                                fgStructure.MenuContext->MContext
                 );
             else
             {
                 fgStructure.MenuContext =
                     (SFG_MenuContext *)malloc( sizeof(SFG_MenuContext) );
-                fgStructure.MenuContext->Context =
+                fgStructure.MenuContext->MContext =
                     wglCreateContext( window->Window.Device );
             }
 
@@ -1163,7 +1599,7 @@
         }
         else
         {
-#if !TARGET_HOST_WINCE
+#if !defined(_WIN32_WCE)
             fgSetupPixelFormat( window, GL_FALSE, PFD_MAIN_PLANE );
 #endif
 
@@ -1180,12 +1616,19 @@
         }
 
         window->State.NeedToResize = GL_TRUE;
-        window->State.Width  = fgState.Size.X;
-        window->State.Height = fgState.Size.Y;
+        if( ( window->State.Width < 0 ) || ( window->State.Height < 0 ) )
+        {
+            SFG_Window *current_window = fgStructure.CurrentWindow;
+
+            fgSetWindow( window );
+            window->State.Width = glutGet( GLUT_WINDOW_WIDTH );
+            window->State.Height = glutGet( GLUT_WINDOW_HEIGHT );
+            fgSetWindow( current_window );
+        }
 
         ReleaseDC( window->Window.Handle, window->Window.Device );
 
-#if TARGET_HOST_WINCE
+#if defined(_WIN32_WCE)
         /* Take over button handling */
         {
             HINSTANCE dxDllLib=LoadLibrary(_T("gx.dll"));
@@ -1201,7 +1644,7 @@
                 gxKeyList = (*GXGetDefaultKeys_)(GX_LANDSCAPEKEYS);
         }
 
-#endif /* TARGET_HOST_WINCE */
+#endif /* defined(_WIN32_WCE) */
         break;
 
     case WM_SIZE:
@@ -1213,13 +1656,13 @@
         if( window->State.Visible )
         {
             window->State.NeedToResize = GL_TRUE;
-#if TARGET_HOST_WINCE
+#if defined(_WIN32_WCE)
             window->State.Width  = HIWORD(lParam);
             window->State.Height = LOWORD(lParam);
 #else
             window->State.Width  = LOWORD(lParam);
             window->State.Height = HIWORD(lParam);
-#endif /* TARGET_HOST_WINCE */
+#endif /* defined(_WIN32_WCE) */
         }
 
         break;
@@ -1290,13 +1733,13 @@
 
     case WM_MOUSEMOVE:
     {
-#if TARGET_HOST_WINCE
+#if defined(_WIN32_WCE)
         window->State.MouseX = 320-HIWORD( lParam );
         window->State.MouseY = LOWORD( lParam );
 #else
         window->State.MouseX = LOWORD( lParam );
         window->State.MouseY = HIWORD( lParam );
-#endif /* TARGET_HOST_WINCE */
+#endif /* defined(_WIN32_WCE) */
         /* Restrict to [-32768, 32767] to match X11 behaviour       */
         /* See comment in "freeglut_developer" mailing list 10/4/04 */
         if ( window->State.MouseX > 32767 ) window->State.MouseX -= 65536;
@@ -1319,7 +1762,7 @@
             INVOKE_WCB( *window, Passive, ( window->State.MouseX,
                                             window->State.MouseY ) );
 
-        fgState.Modifiers = 0xffffffff;
+        fgState.Modifiers = INVALID_MODIFIERS;
     }
     break;
 
@@ -1333,13 +1776,13 @@
         GLboolean pressed = GL_TRUE;
         int button;
 
-#if TARGET_HOST_WINCE
+#if defined(_WIN32_WCE)
         window->State.MouseX = 320-HIWORD( lParam );
         window->State.MouseY = LOWORD( lParam );
 #else
         window->State.MouseX = LOWORD( lParam );
         window->State.MouseY = HIWORD( lParam );
-#endif /* TARGET_HOST_WINCE */
+#endif /* defined(_WIN32_WCE) */
 
         /* Restrict to [-32768, 32767] to match X11 behaviour       */
         /* See comment in "freeglut_developer" mailing list 10/4/04 */
@@ -1378,7 +1821,7 @@
             break;
         }
 
-#if !TARGET_HOST_WINCE
+#if !defined(_WIN32_WCE)
         if( GetSystemMetrics( SM_SWAPBUTTON ) )
         {
             if( button == GLUT_LEFT_BUTTON )
@@ -1387,7 +1830,7 @@
                 if( button == GLUT_RIGHT_BUTTON )
                     button = GLUT_LEFT_BUTTON;
         }
-#endif /* !TARGET_HOST_WINCE */
+#endif /* !defined(_WIN32_WCE) */
 
         if( button == -1 )
             return DefWindowProc( hWnd, uMsg, lParam, wParam );
@@ -1429,7 +1872,7 @@
             )
         );
 
-        fgState.Modifiers = 0xffffffff;
+        fgState.Modifiers = INVALID_MODIFIERS;
     }
     break;
 
@@ -1496,7 +1939,7 @@
                 );
             }
 
-        fgState.Modifiers = 0xffffffff;
+        fgState.Modifiers = INVALID_MODIFIERS;
     }
     break ;
 
@@ -1555,7 +1998,7 @@
             );
         }
 
-#if TARGET_HOST_WINCE
+#if defined(_WIN32_WCE)
         if(!(lParam & 0x40000000)) /* Prevent auto-repeat */
         {
             if(wParam==(unsigned)gxKeyList.vkRight)
@@ -1583,7 +2026,7 @@
                           window->State.MouseX, window->State.MouseY )
             );
 
-        fgState.Modifiers = 0xffffffff;
+        fgState.Modifiers = INVALID_MODIFIERS;
     }
     break;
 
@@ -1643,20 +2086,20 @@
 
         default:
         {
-#if !TARGET_HOST_WINCE
+#if !defined(_WIN32_WCE)
             BYTE state[ 256 ];
             WORD code[ 2 ];
 
             GetKeyboardState( state );
 
-            if( ToAscii( wParam, 0, state, code, 0 ) == 1 )
+            if( ToAscii( (UINT)wParam, 0, state, code, 0 ) == 1 )
                 wParam=code[ 0 ];
 
             INVOKE_WCB( *window, KeyboardUp,
                         ( (char)wParam,
                           window->State.MouseX, window->State.MouseY )
             );
-#endif /* !TARGET_HOST_WINCE */
+#endif /* !defined(_WIN32_WCE) */
         }
         }
 
@@ -1666,7 +2109,7 @@
                           window->State.MouseX, window->State.MouseY )
             );
 
-        fgState.Modifiers = 0xffffffff;
+        fgState.Modifiers = INVALID_MODIFIERS;
     }
     break;
 
@@ -1681,7 +2124,7 @@
                     ( (char)wParam,
                       window->State.MouseX, window->State.MouseY )
         );
-        fgState.Modifiers = 0xffffffff;
+        fgState.Modifiers = INVALID_MODIFIERS;
     }
     break;
 
@@ -1716,7 +2159,7 @@
         lRet = DefWindowProc( hWnd, uMsg, wParam, lParam );
         break;
 
-#if !TARGET_HOST_WINCE
+#if !defined(_WIN32_WCE)
     case WM_SYNCPAINT:  /* 0x0088 */
         /* Another window has moved, need to update this one */
         window->State.Redisplay = GL_TRUE;
@@ -1797,6 +2240,17 @@
             case SC_HOTKEY     :
                 break ;
 
+#if(WINVER >= 0x0400)
+            case SC_DEFAULT    :
+                break ;
+
+            case SC_MONITORPOWER    :
+                break ;
+
+            case SC_CONTEXTHELP    :
+                break ;
+#endif /* WINVER >= 0x0400 */
+
             default:
 #if _DEBUG
                 fgWarning( "Unknown wParam type 0x%x", wParam );
@@ -1804,7 +2258,7 @@
                 break;
             }
         }
-#endif /* !TARGET_HOST_WINCE */
+#endif /* !defined(_WIN32_WCE) */
 
         /* We need to pass the message on to the operating system as well */
         lRet = DefWindowProc( hWnd, uMsg, wParam, lParam );
diff -ruN freeglut-2.4.0/src/freeglut_menu.c freeglut-2.4.0-svn759/src/freeglut_menu.c
--- freeglut-2.4.0/src/freeglut_menu.c	2005-05-15 09:04:29.000000000 -0600
+++ freeglut-2.4.0-svn759/src/freeglut_menu.c	2008-11-09 23:05:14.000000000 -0700
@@ -52,7 +52,7 @@
  * that that wasn't the original intent...if not, perhaps we need another
  * symbolic constant, FREEGLUT_MENU_ITEM_BORDER, or such.)
  */
-#if TARGET_HOST_WIN32 || TARGET_HOST_WINCE
+#if TARGET_HOST_MS_WINDOWS
 #define  FREEGLUT_MENU_FONT    GLUT_BITMAP_8_BY_13
 #else
 #define  FREEGLUT_MENU_FONT    GLUT_BITMAP_HELVETICA_18
@@ -71,7 +71,7 @@
  * too.  These variables should be stuffed into global state and initialized
  * via the glutInit*() system.
  */
-#if TARGET_HOST_WIN32 || TARGET_HOST_WINCE
+#if TARGET_HOST_MS_WINDOWS
 static float menu_pen_fore  [4] = {0.0f,  0.0f,  0.0f,  1.0f};
 static float menu_pen_back  [4] = {0.85f, 0.85f, 0.85f, 1.0f};
 static float menu_pen_hfore [4] = {1.0f,  1.0f,  1.0f,  1.0f};
@@ -140,9 +140,9 @@
  */
 static GLvoid fghGetVMaxExtent( SFG_Window* window, int* x, int* y )
 {
-    if( fgStructure.GameMode )
+    if( fgStructure.GameModeWindow )
     {
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
         int wx, wy;
         Window w;
 
@@ -263,9 +263,13 @@
                     menuEntry->SubMenu->X = menu->X - menuEntry->SubMenu->Width;
 
                 if( menuEntry->SubMenu->Y + menuEntry->SubMenu->Height > max_y )
+                {
                     menuEntry->SubMenu->Y -= ( menuEntry->SubMenu->Height -
                                                FREEGLUT_MENU_HEIGHT -
                                                2 * FREEGLUT_MENU_BORDER );
+                    if( menuEntry->SubMenu->Y < 0 )
+                        menuEntry->SubMenu->Y = 0;
+                }
 
                 fgSetWindow( menuEntry->SubMenu->Window );
                 glutPositionWindow( menuEntry->SubMenu->X,
@@ -552,7 +556,11 @@
         menu->X -=menu->Width;
 
     if( menu->Y + menu->Height > max_y )
+    {
         menu->Y -=menu->Height;
+        if( menu->Y < 0 )
+            menu->Y = 0;
+    }
 
     menu->Window->State.MouseX =
         window->State.MouseX + glutGet( GLUT_WINDOW_X ) - menu->X;
diff -ruN freeglut-2.4.0/src/freeglut_misc.c freeglut-2.4.0-svn759/src/freeglut_misc.c
--- freeglut-2.4.0/src/freeglut_misc.c	2005-04-22 08:17:31.000000000 -0600
+++ freeglut-2.4.0-svn759/src/freeglut_misc.c	2008-11-09 23:05:14.000000000 -0700
@@ -47,7 +47,7 @@
 int FGAPIENTRY glutExtensionSupported( const char* extension )
 {
   const char *extensions, *start;
-  const int len = strlen( extension );
+  const size_t len = strlen( extension );
 
   /* Make sure there is a current window, and thus a current context available */
   FREEGLUT_EXIT_IF_NOT_INITIALISED ( "glutExtensionSupported" );
@@ -76,6 +76,49 @@
   return 0 ;
 }
 
+#ifndef GL_INVALID_FRAMEBUFFER_OPERATION
+#ifdef GL_INVALID_FRAMEBUFFER_OPERATION_EXT
+#define GL_INVALID_FRAMEBUFFER_OPERATION GL_INVALID_FRAMEBUFFER_OPERATION_EXT
+#else
+#define GL_INVALID_FRAMEBUFFER_OPERATION 0x0506
+#endif
+#endif
+
+#ifndef GL_TABLE_TOO_LARGE
+#ifdef GL_TABLE_TOO_LARGE_EXT
+#define GL_TABLE_TOO_LARGE GL_TABLE_TOO_LARGE_EXT
+#else
+#define GL_TABLE_TOO_LARGE 0x8031
+#endif
+#endif
+
+#ifndef GL_TEXTURE_TOO_LARGE
+#ifdef GL_TEXTURE_TOO_LARGE_EXT
+#define GL_TEXTURE_TOO_LARGE GL_TEXTURE_TOO_LARGE_EXT
+#else
+#define GL_TEXTURE_TOO_LARGE 0x8065
+#endif
+#endif
+
+/*
+ * A cut-down local version of gluErrorString to avoid depending on GLU.
+ */
+static const char* fghErrorString( GLenum error )
+{
+  switch ( error ) {
+  case GL_INVALID_ENUM: return "invalid enumerant";
+  case GL_INVALID_VALUE: return "invalid value";
+  case GL_INVALID_OPERATION: return "invalid operation";
+  case GL_STACK_OVERFLOW: return "stack overflow";
+  case GL_STACK_UNDERFLOW: return "stack underflow";
+  case GL_OUT_OF_MEMORY: return "out of memory";
+  case GL_TABLE_TOO_LARGE: return "table too large";
+  case GL_INVALID_FRAMEBUFFER_OPERATION: return "invalid framebuffer operation";
+  case GL_TEXTURE_TOO_LARGE: return "texture too large";
+  default: return "unknown GL error";
+  }
+}
+
 /*
  * This function reports all the OpenGL errors that happened till now
  */
@@ -84,7 +127,7 @@
     GLenum error;
     FREEGLUT_EXIT_IF_NOT_INITIALISED ( "glutReportErrors" );
     while( ( error = glGetError() ) != GL_NO_ERROR )
-        fgWarning( "GL error: %s", gluErrorString( error ) );
+        fgWarning( "GL error: %s", fghErrorString( error ) );
 }
 
 /*
@@ -133,11 +176,11 @@
 void FGAPIENTRY glutForceJoystickFunc( void )
 {
     FREEGLUT_EXIT_IF_NOT_INITIALISED ( "glutForceJoystickFunc" );
-#if !TARGET_HOST_WINCE
+#if !defined(_WIN32_WCE)
     freeglut_return_if_fail( fgStructure.CurrentWindow != NULL );
     freeglut_return_if_fail( FETCH_WCB( *( fgStructure.CurrentWindow ), Joystick ) );
     fgJoystickPollWindow( fgStructure.CurrentWindow );
-#endif /* !TARGET_HOST_WINCE */
+#endif /* !defined(_WIN32_WCE) */
 }
 
 /*
diff -ruN freeglut-2.4.0/src/freeglut_state.c freeglut-2.4.0-svn759/src/freeglut_state.c
--- freeglut-2.4.0/src/freeglut_state.c	2005-04-22 08:17:31.000000000 -0600
+++ freeglut-2.4.0-svn759/src/freeglut_state.c	2008-11-09 23:05:14.000000000 -0700
@@ -45,22 +45,49 @@
 
 /* -- PRIVATE FUNCTIONS ---------------------------------------------------- */
 
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
 /*
  * Queries the GL context about some attributes
  */
 static int fghGetConfig( int attribute )
 {
   int returnValue = 0;
+  int result;  /*  Not checked  */
 
   if( fgStructure.CurrentWindow )
-      glXGetConfig( fgDisplay.Display, fgStructure.CurrentWindow->Window.VisualInfo,
-                    attribute, &returnValue );
+      result = glXGetFBConfigAttrib( fgDisplay.Display,
+                                     *(fgStructure.CurrentWindow->Window.FBConfig),
+                                     attribute,
+                                     &returnValue );
 
   return returnValue;
 }
 #endif
 
+/* Check if the window is in full screen state. */
+static int fghCheckFullScreen(void)
+{
+#if TARGET_HOST_POSIX_X11
+
+  int result;
+
+  result = 0;
+  if (fgDisplay.StateFullScreen != None)
+    {
+      result = fgHintPresent(fgStructure.CurrentWindow->Window.Handle,
+			     fgDisplay.State,
+			     fgDisplay.StateFullScreen);
+    }
+
+  return result;
+
+#else
+
+  return 0;
+
+#endif
+}
+
 /* -- INTERFACE FUNCTIONS -------------------------------------------------- */
 
 /*
@@ -113,22 +140,41 @@
             fgStructure.CurrentWindow->State.Cursor = value;
         break;
 
+    case GLUT_AUX:
+      fgState.AuxiliaryBufferNumber = value;
+      break;
+
+    case GLUT_MULTISAMPLE:
+      fgState.SampleNumber = value;
+      break;
+
     default:
         fgWarning( "glutSetOption(): missing enum handle %d", eWhat );
         break;
     }
 }
 
+#if TARGET_HOST_MS_WINDOWS
+/* The following include file is available from SGI but is not standard:
+ *   #include <GL/wglext.h>
+ * So we copy the necessary parts out of it to support the multisampling query
+ */
+#define WGL_SAMPLES_ARB                0x2042
+#endif
+
+
 /*
  * General settings query method
  */
 int FGAPIENTRY glutGet( GLenum eWhat )
 {
-#if TARGET_HOST_WIN32 || TARGET_HOST_WINCE
+#if TARGET_HOST_MS_WINDOWS
     int returnValue ;
     GLboolean boolValue ;
 #endif
 
+    int nsamples = 0;
+
     switch (eWhat)
     {
     case GLUT_INIT_STATE:
@@ -148,21 +194,30 @@
     case GLUT_SCREEN_HEIGHT:        return fgDisplay.ScreenHeight  ;
     case GLUT_SCREEN_WIDTH_MM:      return fgDisplay.ScreenWidthMM ;
     case GLUT_SCREEN_HEIGHT_MM:     return fgDisplay.ScreenHeightMM;
-    case GLUT_INIT_WINDOW_X:        return fgState.Position.X      ;
-    case GLUT_INIT_WINDOW_Y:        return fgState.Position.Y      ;
-    case GLUT_INIT_WINDOW_WIDTH:    return fgState.Size.X          ;
-    case GLUT_INIT_WINDOW_HEIGHT:   return fgState.Size.Y          ;
+    case GLUT_INIT_WINDOW_X:        return fgState.Position.Use ?
+                                           fgState.Position.X : -1 ;
+    case GLUT_INIT_WINDOW_Y:        return fgState.Position.Use ?
+                                           fgState.Position.Y : -1 ;
+    case GLUT_INIT_WINDOW_WIDTH:    return fgState.Size.Use ?
+                                           fgState.Size.X : -1     ;
+    case GLUT_INIT_WINDOW_HEIGHT:   return fgState.Size.Use ?
+                                           fgState.Size.Y : -1     ;
     case GLUT_INIT_DISPLAY_MODE:    return fgState.DisplayMode     ;
+    case GLUT_INIT_MAJOR_VERSION:   return fgState.MajorVersion    ;
+    case GLUT_INIT_MINOR_VERSION:   return fgState.MinorVersion    ;
+    case GLUT_INIT_FLAGS:           return fgState.ContextFlags    ;
 
+#if TARGET_HOST_POSIX_X11
     /*
      * The window/context specific queries are handled mostly by
      * fghGetConfig().
      */
     case GLUT_WINDOW_NUM_SAMPLES:
-        /* XXX Multisampling. Return what I know about multisampling. */
-        return 0;
+#ifdef GLX_VERSION_1_3
+        glGetIntegerv(GL_SAMPLES, &nsamples);
+#endif
+        return nsamples;
 
-#if TARGET_HOST_UNIX_X11
     /*
      * The rest of GLX queries under X are general enough to use a macro to
      * check them
@@ -196,7 +251,20 @@
              */
             return 0;
         }
-        return fgStructure.CurrentWindow->Window.VisualInfo->visual->map_entries;
+        else
+        {
+          const GLXFBConfig * fbconfig =
+                fgStructure.CurrentWindow->Window.FBConfig;
+
+          XVisualInfo * visualInfo =
+                glXGetVisualFromFBConfig( fgDisplay.Display, *fbconfig );
+
+          const int result = visualInfo->visual->map_entries;
+
+          XFree(visualInfo);
+
+          return result;
+        }
 
     /*
      * Those calls are somewhat similiar, as they use XGetWindowAttributes()
@@ -260,16 +328,38 @@
 
     /* I do not know yet if there will be a fgChooseVisual() function for Win32 */
     case GLUT_DISPLAY_MODE_POSSIBLE:
-        return( fgChooseVisual() == NULL ? 0 : 1 );
+    {
+        /*  We should not have to call fgChooseFBConfig again here.  */
+        GLXFBConfig * fbconfig;
+        int isPossible;
+
+        fbconfig = fgChooseFBConfig();
+
+        if (fbconfig == NULL)
+        {
+            isPossible = 0;
+        }
+        else
+        {
+            isPossible = 1;
+            XFree(fbconfig);
+        }
+
+        return isPossible;
+    }
 
     /* This is system-dependant */
     case GLUT_WINDOW_FORMAT_ID:
         if( fgStructure.CurrentWindow == NULL )
             return 0;
 
-        return fgStructure.CurrentWindow->Window.VisualInfo->visualid;
+        return fghGetConfig( GLX_VISUAL_ID );
+
+#elif TARGET_HOST_MS_WINDOWS
 
-#elif TARGET_HOST_WIN32 || TARGET_HOST_WINCE
+    case GLUT_WINDOW_NUM_SAMPLES:
+      glGetIntegerv(WGL_SAMPLES_ARB, &nsamples);
+      return nsamples;
 
     /* Handle the OpenGL inquiries */
     case GLUT_WINDOW_RGBA:
@@ -361,8 +451,8 @@
 
         /* ...then we've got to correct the results we've just received... */
 
-#if !TARGET_HOST_WINCE
-        if ( ( fgStructure.GameMode != fgStructure.CurrentWindow ) && ( fgStructure.CurrentWindow->Parent == NULL ) &&
+#if !defined(_WIN32_WCE)
+        if ( ( fgStructure.GameModeWindow != fgStructure.CurrentWindow ) && ( fgStructure.CurrentWindow->Parent == NULL ) &&
              ( ! fgStructure.CurrentWindow->IsMenu ) )
         {
           winRect.left   += GetSystemMetrics( SM_CXSIZEFRAME );
@@ -370,7 +460,7 @@
           winRect.top    += GetSystemMetrics( SM_CYSIZEFRAME ) + GetSystemMetrics( SM_CYCAPTION );
           winRect.bottom -= GetSystemMetrics( SM_CYSIZEFRAME );
         }
-#endif /* !TARGET_HOST_WINCE */
+#endif /* !defined(_WIN32_WCE) */
 
         switch( eWhat )
         {
@@ -383,33 +473,33 @@
     break;
 
     case GLUT_WINDOW_BORDER_WIDTH :
-#if TARGET_HOST_WINCE
+#if defined(_WIN32_WCE)
         return 0;
 #else
         return GetSystemMetrics( SM_CXSIZEFRAME );
-#endif /* !TARGET_HOST_WINCE */
+#endif /* !defined(_WIN32_WCE) */
 
     case GLUT_WINDOW_HEADER_HEIGHT :
-#if TARGET_HOST_WINCE
+#if defined(_WIN32_WCE)
         return 0;
 #else
         return GetSystemMetrics( SM_CYCAPTION );
-#endif /* TARGET_HOST_WINCE */
+#endif /* defined(_WIN32_WCE) */
 
     case GLUT_DISPLAY_MODE_POSSIBLE:
-#if TARGET_HOST_WINCE
-        return GL_FALSE;
+#if defined(_WIN32_WCE)
+        return 0;
 #else
         return fgSetupPixelFormat( fgStructure.CurrentWindow, GL_TRUE,
                                     PFD_MAIN_PLANE );
-#endif /* TARGET_HOST_WINCE */
+#endif /* defined(_WIN32_WCE) */
 
 
     case GLUT_WINDOW_FORMAT_ID:
-#if !TARGET_HOST_WINCE
+#if !defined(_WIN32_WCE)
         if( fgStructure.CurrentWindow != NULL )
             return GetPixelFormat( fgStructure.CurrentWindow->Window.Device );
-#endif /* TARGET_HOST_WINCE */
+#endif /* defined(_WIN32_WCE) */
         return 0;
 
 #endif
@@ -449,6 +539,10 @@
         return fgState.DirectContext;
         break;
 
+    case GLUT_FULL_SCREEN:
+        return fghCheckFullScreen();
+        break;
+
     default:
         fgWarning( "glutGet(): missing enum handle %d", eWhat );
         break;
@@ -468,60 +562,57 @@
     {
     case GLUT_HAS_KEYBOARD:
         /*
-         * We always have a keyboard present on PC machines...
+         * Win32 is assumed a keyboard, and this cannot be queried,
+         * except for WindowsCE.
          *
-         * XXX I think that some of my PCs will boot without a keyboard.
-         * XXX Also, who says that we are running on a PC?  UNIX/X11
-         * XXX is much more generic, and X11 can go over a network.
-         * XXX Though in actuality, we can probably assume BOTH a
-         * XXX mouse and keyboard for most/all of our users.
+         * X11 has a core keyboard by definition, although it can
+         * be present as a virtual/dummy keyboard. For now, there
+         * is no reliable way to tell if a real keyboard is present.
          */
-        return TRUE ;
+#if defined(_WIN32_CE)
+        return ( GetKeyboardStatus() & KBDI_KEYBOARD_PRESENT ) ? 1 : 0;
+#   if FREEGLUT_LIB_PRAGMAS
+#       pragma comment (lib,"Kbdui.lib")
+#   endif
 
-#if TARGET_HOST_UNIX_X11
+#else
+        return 1;
+#endif
 
+#if TARGET_HOST_POSIX_X11
+
+    /* X11 has a mouse by definition */
     case GLUT_HAS_MOUSE:
-        return TRUE ;
+        return 1 ;
 
     case GLUT_NUM_MOUSE_BUTTONS:
-        /*
-         * Return the number of mouse buttons available. This is a big guess.
+        /* We should be able to pass NULL when the last argument is zero,
+         * but at least one X server has a bug where this causes a segfault.
          *
-         * XXX We can probe /var/run/dmesg.boot which is world-readable.
-         * XXX This would be somewhat system-dependant, but is doable.
-         * XXX E.g., on NetBSD, my USB mouse registers:
-         * XXX   ums0 at uhidev0: 3 buttons and Z dir.
-         * XXX We can also probe /var/log/XFree86\..*\.log to get
-         * XXX lines such as:
-         * XXX   (**) Option "Buttons" "5"
-         * XXX   (**) Option "ZAxisMapping" "4 5"
-         * XXX   (**) Mouse0: ZAxisMapping: buttons 4 and 5
-         * XXX   (**) Mouse0: Buttons: 5
-         * XXX ...which tells us even more, and is a bit less
-         * XXX system-dependant.  (Other than MS-WINDOWS, all
-         * XXX target hosts with actual users are probably running
-         * XXX XFree86...)  It is at least worth taking a look at
-         * XXX this file.
+         * In XFree86/Xorg servers, a mouse wheel is seen as two buttons
+         * rather than an Axis; "freeglut_main.c" expects this when
+         * checking for a wheel event.
          */
-        return 3 ;
+        {
+            unsigned char map;
+            int nbuttons = XGetPointerMapping(fgDisplay.Display, &map,0);
+            return nbuttons;
+        }
 
-#elif TARGET_HOST_WIN32 || TARGET_HOST_WINCE
+#elif TARGET_HOST_MS_WINDOWS
 
     case GLUT_HAS_MOUSE:
         /*
-         * The Windows can be booted without a mouse.
-         * It would be nice to have this reported.
+         * MS Windows can be booted without a mouse.
          */
         return GetSystemMetrics( SM_MOUSEPRESENT );
 
     case GLUT_NUM_MOUSE_BUTTONS:
-        /* We are much more fortunate under Win32 about this... */
-#if TARGET_HOST_WINCE
+#  if defined(_WIN32_WCE)
         return 1;
-#else
+#  else
         return GetSystemMetrics( SM_CMOUSEBUTTONS );
-#endif /* TARGET_HOST_WINCE */
-
+#  endif
 #endif
 
     case GLUT_HAS_JOYSTICK:
@@ -540,14 +631,21 @@
     case GLUT_JOYSTICK_AXES:
         return glutJoystickGetNumAxes ( 0 );
 
-    case GLUT_HAS_SPACEBALL:
     case GLUT_HAS_DIAL_AND_BUTTON_BOX:
+        return fgInputDeviceDetect ();
+
+    case GLUT_NUM_DIALS:
+        if ( fgState.InputDevsInitialised ) return 8;
+        return 0;
+ 
+    case GLUT_NUM_BUTTON_BOX_BUTTONS:
+        return 0;
+
+    case GLUT_HAS_SPACEBALL:
     case GLUT_HAS_TABLET:
-        return FALSE;
+        return 0;
 
     case GLUT_NUM_SPACEBALL_BUTTONS:
-    case GLUT_NUM_BUTTON_BOX_BUTTONS:
-    case GLUT_NUM_DIALS:
     case GLUT_NUM_TABLET_BUTTONS:
         return 0;
 
@@ -572,7 +670,7 @@
 int FGAPIENTRY glutGetModifiers( void )
 {
     FREEGLUT_EXIT_IF_NOT_INITIALISED ( "glutGetModifiers" );
-    if( fgState.Modifiers == 0xffffffff )
+    if( fgState.Modifiers == INVALID_MODIFIERS )
     {
         fgWarning( "glutGetModifiers() called outside an input callback" );
         return 0;
@@ -597,16 +695,16 @@
     switch( eWhat )
     {
 
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
 
     case GLUT_OVERLAY_POSSIBLE:
-        return FALSE;
+        return 0;
 
     case GLUT_LAYER_IN_USE:
         return GLUT_NORMAL;
 
     case GLUT_HAS_OVERLAY:
-        return FALSE;
+        return 0;
 
     case GLUT_TRANSPARENT_INDEX:
         /*
@@ -618,23 +716,23 @@
 
     case GLUT_NORMAL_DAMAGED:
         /* XXX Actually I do not know. Maybe. */
-        return FALSE;
+        return 0;
 
     case GLUT_OVERLAY_DAMAGED:
         return -1;
 
-#elif TARGET_HOST_WIN32 || TARGET_HOST_WINCE
+#elif TARGET_HOST_MS_WINDOWS
 
     case GLUT_OVERLAY_POSSIBLE:
 /*      return fgSetupPixelFormat( fgStructure.CurrentWindow, GL_TRUE,
                                    PFD_OVERLAY_PLANE ); */
-      return FALSE ;
+      return 0 ;
 
     case GLUT_LAYER_IN_USE:
         return GLUT_NORMAL;
 
     case GLUT_HAS_OVERLAY:
-        return FALSE;
+        return 0;
 
     case GLUT_TRANSPARENT_INDEX:
         /*
@@ -646,7 +744,7 @@
 
     case GLUT_NORMAL_DAMAGED:
         /* XXX Actually I do not know. Maybe. */
-        return FALSE;
+        return 0;
 
     case GLUT_OVERLAY_DAMAGED:
         return -1;
@@ -661,4 +759,114 @@
     return -1;
 }
 
+int * FGAPIENTRY glutGetModeValues(GLenum eWhat, int * size)
+{
+  int * array;
+
+#if TARGET_HOST_POSIX_X11
+  int attributes[9];
+  GLXFBConfig * fbconfigArray;  /*  Array of FBConfigs  */
+  int fbconfigArraySize;        /*  Number of FBConfigs in the array  */
+  int attribute_name = 0;
+#endif
+
+  FREEGLUT_EXIT_IF_NOT_INITIALISED("glutGetModeValues");
+
+  array = NULL;
+  *size = 0;
+
+  switch (eWhat)
+    {
+#if TARGET_HOST_POSIX_X11
+    case GLUT_AUX:
+    case GLUT_MULTISAMPLE:
+
+      attributes[0] = GLX_BUFFER_SIZE;
+      attributes[1] = GLX_DONT_CARE;
+
+      switch (eWhat)
+        {
+        case GLUT_AUX:
+          /*
+            FBConfigs are now sorted by increasing number of auxiliary
+            buffers.  We want at least one buffer.
+          */
+          attributes[2] = GLX_AUX_BUFFERS;
+          attributes[3] = 1;
+          attributes[4] = None;
+
+          attribute_name = GLX_AUX_BUFFERS;
+
+          break;
+
+
+        case GLUT_MULTISAMPLE:
+          attributes[2] = GLX_AUX_BUFFERS;
+          attributes[3] = GLX_DONT_CARE;
+          attributes[4] = GLX_SAMPLE_BUFFERS;
+          attributes[5] = 1;
+          /*
+            FBConfigs are now sorted by increasing number of samples per
+            pixel.  We want at least one sample.
+          */
+          attributes[6] = GLX_SAMPLES;
+          attributes[7] = 1;
+          attributes[8] = None;
+
+          attribute_name = GLX_SAMPLES;
+
+          break;
+        }
+
+      fbconfigArray = glXChooseFBConfig(fgDisplay.Display,
+                                        fgDisplay.Screen,
+                                        attributes,
+                                        &fbconfigArraySize);
+
+      if (fbconfigArray != NULL)
+        {
+          int * temp_array;
+          int result;   /*  Returned by glXGetFBConfigAttrib. Not checked.  */
+          int previous_value;
+          int i;
+
+          temp_array = malloc(sizeof(int) * fbconfigArraySize);
+          previous_value = 0;
+
+          for (i = 0; i < fbconfigArraySize; i++)
+            {
+              int value;
+
+              result = glXGetFBConfigAttrib(fgDisplay.Display,
+                                            fbconfigArray[i],
+                                            attribute_name,
+                                            &value);
+              if (value > previous_value)
+                {
+                  temp_array[*size] = value;
+                  previous_value = value;
+                  (*size)++;
+                }
+            }
+
+          array = malloc(sizeof(int) * (*size));
+          for (i = 0; i < *size; i++)
+            {
+              array[i] = temp_array[i];
+            }
+
+          free(temp_array);
+          XFree(fbconfigArray);
+        }
+
+      break;
+#endif      
+
+    default:
+      break;
+    }
+
+  return array;
+}
+
 /*** END OF FILE ***/
diff -ruN freeglut-2.4.0/src/freeglut_stroke_mono_roman.c freeglut-2.4.0-svn759/src/freeglut_stroke_mono_roman.c
--- freeglut-2.4.0/src/freeglut_stroke_mono_roman.c	2004-09-23 11:48:48.000000000 -0600
+++ freeglut-2.4.0-svn759/src/freeglut_stroke_mono_roman.c	2008-11-09 23:05:14.000000000 -0700
@@ -28,6 +28,7 @@
 
 /* This file has been automatically generated by the genstroke utility. */
 
+#include <GL/freeglut.h>
 #include "freeglut_internal.h"
 
 /* char: 0x20 */
diff -ruN freeglut-2.4.0/src/freeglut_stroke_roman.c freeglut-2.4.0-svn759/src/freeglut_stroke_roman.c
--- freeglut-2.4.0/src/freeglut_stroke_roman.c	2004-09-23 11:48:49.000000000 -0600
+++ freeglut-2.4.0-svn759/src/freeglut_stroke_roman.c	2008-11-09 23:05:14.000000000 -0700
@@ -28,6 +28,7 @@
 
 /* This file has been automatically generated by the genstroke utility. */
 
+#include <GL/freeglut.h>
 #include "freeglut_internal.h"
 
 /* char: 0x20 */
diff -ruN freeglut-2.4.0/src/freeglut_structure.c freeglut-2.4.0-svn759/src/freeglut_structure.c
--- freeglut-2.4.0/src/freeglut_structure.c	2005-04-26 11:44:57.000000000 -0600
+++ freeglut-2.4.0-svn759/src/freeglut_structure.c	2008-11-09 23:05:14.000000000 -0700
@@ -65,12 +65,16 @@
  * If parent is set to NULL, the window created will be a topmost one.
  */
 SFG_Window* fgCreateWindow( SFG_Window* parent, const char* title,
-                            int x, int y, int w, int h,
+                            GLboolean positionUse, int x, int y,
+                            GLboolean sizeUse, int w, int h,
                             GLboolean gameMode, GLboolean isMenu )
 {
     /* Have the window object created */
     SFG_Window *window = (SFG_Window *)calloc( sizeof(SFG_Window), 1 );
 
+#if TARGET_HOST_UNIX_X11
+    window->Window.FBConfig = NULL;
+#endif
     fghClearCallBacks( window );
 
     /* Initialize the object properties */
@@ -98,7 +102,7 @@
      * Open the window now. The fgOpenWindow() function is system
      * dependant, and resides in freeglut_window.c. Uses fgState.
      */
-    fgOpenWindow( window, title, x, y, w, h, gameMode,
+    fgOpenWindow( window, title, positionUse, x, y, sizeUse, w, h, gameMode,
                   (GLboolean)(parent ? GL_TRUE : GL_FALSE) );
 
     return window;
@@ -119,7 +123,8 @@
 
     /* Create a window for the menu to reside in. */
 
-    fgCreateWindow( NULL, "freeglut menu", x, y, w, h, GL_FALSE, GL_TRUE );
+    fgCreateWindow( NULL, "freeglut menu", GL_TRUE, x, y, GL_TRUE, w, h,
+                    GL_FALSE, GL_TRUE );
     menu->Window = fgStructure.CurrentWindow;
     glutDisplayFunc( fgDisplayMenu );
 
@@ -346,7 +351,7 @@
     fgStructure.CurrentWindow = NULL;
     fgStructure.CurrentMenu = NULL;
     fgStructure.MenuContext = NULL;
-    fgStructure.GameMode = NULL;
+    fgStructure.GameModeWindow = NULL;
     fgStructure.WindowID = 0;
     fgStructure.MenuID = 0;
 }
diff -ruN freeglut-2.4.0/src/freeglut_teapot.c freeglut-2.4.0-svn759/src/freeglut_teapot.c
--- freeglut-2.4.0/src/freeglut_teapot.c	2005-01-03 03:13:26.000000000 -0700
+++ freeglut-2.4.0-svn759/src/freeglut_teapot.c	2008-11-09 23:05:14.000000000 -0700
@@ -81,7 +81,7 @@
 
 static void fghTeapot( GLint grid, GLdouble scale, GLenum type )
 {
-#if TARGET_HOST_WINCE
+#if defined(_WIN32_WCE)
 		int i, numV=sizeof(strip_vertices)/4, numI=sizeof(strip_normals)/4;
 #else
     double p[4][4][3], q[4][4][3], r[4][4][3], s[4][4][3];
@@ -99,7 +99,7 @@
     glScaled( 0.5 * scale, 0.5 * scale, 0.5 * scale );
     glTranslated( 0.0, 0.0, -1.5 );
 
-#if TARGET_HOST_WINCE
+#if defined(_WIN32_WCE)
     glRotated( 90.0, 1.0, 0.0, 0.0 );
     glBegin( GL_TRIANGLE_STRIP );
 
@@ -163,7 +163,7 @@
         glEvalMesh2(type, 0, grid, 0, grid);
       }
     }
-#endif  /* TARGET_HOST_WINCE */
+#endif  /* defined(_WIN32_WCE) */
 
     glPopMatrix();
     glPopAttrib();
diff -ruN freeglut-2.4.0/src/freeglut_teapot_data.h freeglut-2.4.0-svn759/src/freeglut_teapot_data.h
--- freeglut-2.4.0/src/freeglut_teapot_data.h	2005-01-02 19:04:45.000000000 -0700
+++ freeglut-2.4.0-svn759/src/freeglut_teapot_data.h	2008-11-09 23:05:14.000000000 -0700
@@ -24,7 +24,7 @@
 #ifndef  FREEGLUT_TEAPOT_DATA_H
 #define  FREEGLUT_TEAPOT_DATA_H
 
-#if TARGET_HOST_WINCE
+#if defined(_WIN32_WCE)
 /*
  * Submitted through the kind offices of Daniel Wagner (daniel@ims.tuwien.ac.at)
  */
@@ -2305,7 +2305,7 @@
 31, 31, 118, 237, 205, 449, 186, 470, 496, 494, 176, 155, 429, 112, 185, 89, 185, 421, 94, 300, 379, 170, -1
 };
 
-#else  /* TARGET_HOST_WINCE */
+#else  /* defined(_WIN32_WCE) */
 
 /*
  * Original teapot code copyright follows:
@@ -2422,7 +2422,7 @@
     { {0.0, 0.0}, {1.0, 0.0} },
     { {0.0, 1.0}, {1.0, 1.0} }
 };
-#endif  /* TARGET_HOST_WINCE */
+#endif  /* defined(_WIN32_WCE) */
 
 
 #endif  /* FREEGLUT_TEAPOT_DATA_H */
diff -ruN freeglut-2.4.0/src/freeglut_window.c freeglut-2.4.0-svn759/src/freeglut_window.c
--- freeglut-2.4.0/src/freeglut_window.c	2005-05-19 18:47:37.000000000 -0600
+++ freeglut-2.4.0-svn759/src/freeglut_window.c	2008-11-09 23:05:14.000000000 -0700
@@ -28,9 +28,15 @@
 #include <GL/freeglut.h>
 #include "freeglut_internal.h"
 
-#if TARGET_HOST_WINCE
-#include <aygshell.h>
-#pragma comment( lib, "Aygshell.lib" )
+#if TARGET_HOST_POSIX_X11
+#include <limits.h>  /* LONG_MAX */
+#endif
+
+#if defined(_WIN32_WCE)
+#   include <Aygshell.h>
+#   ifdef FREEGLUT_LIB_PRAGMAS
+#       pragma comment( lib, "Aygshell.lib" )
+#   endif
 
 static wchar_t* fghWstrFromStr(const char* str)
 {
@@ -42,13 +48,12 @@
     return wstr;
 }
 
-
-#endif /* TARGET_HOST_WINCE */
+#endif /* defined(_WIN32_WCE) */
 
 /*
  * TODO BEFORE THE STABLE RELEASE:
  *
- *  fgChooseVisual()        -- OK, but what about glutInitDisplayString()?
+ *  fgChooseFBConfig()      -- OK, but what about glutInitDisplayString()?
  *  fgSetupPixelFormat      -- ignores the display mode settings
  *  fgOpenWindow()          -- check the Win32 version, -iconic handling!
  *  fgCloseWindow()         -- check the Win32 version
@@ -73,12 +78,10 @@
 /*
  * Chooses a visual basing on the current display mode settings
  */
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
 
-XVisualInfo* fgChooseVisual( void )
+GLXFBConfig* fgChooseFBConfig( void )
 {
-#define BUFFER_SIZES 6
-    int bufferSize[BUFFER_SIZES] = { 16, 12, 8, 4, 2, 1 };
     GLboolean wantIndexedMode = GL_FALSE;
     int attributes[ 32 ];
     int where = 0;
@@ -94,11 +97,13 @@
     if( fgState.DisplayMode & GLUT_INDEX )
     {
         ATTRIB_VAL( GLX_BUFFER_SIZE, 8 );
+        /*  Buffer size is selected later.  */
+
+        ATTRIB_VAL( GLX_RENDER_TYPE, GLX_COLOR_INDEX_BIT );
         wantIndexedMode = GL_TRUE;
     }
     else
     {
-        ATTRIB( GLX_RGBA );
         ATTRIB_VAL( GLX_RED_SIZE,   1 );
         ATTRIB_VAL( GLX_GREEN_SIZE, 1 );
         ATTRIB_VAL( GLX_BLUE_SIZE,  1 );
@@ -107,10 +112,10 @@
     }
 
     if( fgState.DisplayMode & GLUT_DOUBLE )
-        ATTRIB( GLX_DOUBLEBUFFER );
+        ATTRIB_VAL( GLX_DOUBLEBUFFER, True );
 
     if( fgState.DisplayMode & GLUT_STEREO )
-        ATTRIB( GLX_STEREO );
+        ATTRIB_VAL( GLX_STEREO, True );
 
     if( fgState.DisplayMode & GLUT_DEPTH )
         ATTRIB_VAL( GLX_DEPTH_SIZE, 1 );
@@ -127,53 +132,161 @@
             ATTRIB_VAL( GLX_ACCUM_ALPHA_SIZE, 1 );
     }
 
-    if( fgState.DisplayMode & GLUT_AUX1 )
-        ATTRIB_VAL( GLX_AUX_BUFFERS, 1 );
-    if( fgState.DisplayMode & GLUT_AUX2 )
-        ATTRIB_VAL( GLX_AUX_BUFFERS, 2 );
-    if( fgState.DisplayMode & GLUT_AUX3 )
-        ATTRIB_VAL( GLX_AUX_BUFFERS, 3 );
-    if( fgState.DisplayMode & GLUT_AUX4 )
-        ATTRIB_VAL( GLX_AUX_BUFFERS, 4 );
-
+    if ((fgState.DisplayMode & GLUT_AUX)
+     || (fgState.DisplayMode & GLUT_AUX1)
+     || (fgState.DisplayMode & GLUT_AUX2)
+     || (fgState.DisplayMode & GLUT_AUX3)
+     || (fgState.DisplayMode & GLUT_AUX4))
+      {
+        ATTRIB_VAL(GLX_AUX_BUFFERS, fgState.AuxiliaryBufferNumber)
+      }
+
+    if (fgState.DisplayMode & GLUT_MULTISAMPLE)
+      {
+        ATTRIB_VAL(GLX_SAMPLE_BUFFERS, 1)
+        ATTRIB_VAL(GLX_SAMPLES, fgState.SampleNumber)
+      }
 
     /* Push a null at the end of the list */
     ATTRIB( None );
 
-    if( ! wantIndexedMode )
-        return glXChooseVisual( fgDisplay.Display, fgDisplay.Screen,
-                                attributes );
-    else
     {
-        XVisualInfo* visualInfo;
-        int i;
+        GLXFBConfig * fbconfigArray;  /*  Array of FBConfigs  */
+        GLXFBConfig * fbconfig;       /*  The FBConfig we want  */
+        int fbconfigArraySize;        /*  Number of FBConfigs in the array  */
 
-        /*
-         * In indexed mode, we need to check how many bits of depth can we
-         * achieve.  We do this by trying each possibility from the list
-         * given in the {bufferSize} array.  If we match, we return to caller.
-         */
-        for( i=0; i<BUFFER_SIZES; i++ )
+
+        /*  Get all FBConfigs that match "attributes".  */
+        fbconfigArray = glXChooseFBConfig( fgDisplay.Display,
+                                           fgDisplay.Screen,
+                                           attributes,
+                                           &fbconfigArraySize );
+
+        if (fbconfigArray != NULL)
         {
-            attributes[ 1 ] = bufferSize[ i ];
-            visualInfo = glXChooseVisual( fgDisplay.Display, fgDisplay.Screen,
-                                          attributes );
-            if( visualInfo != NULL )
-                return visualInfo;
+            int result;  /* Returned by glXGetFBConfigAttrib, not checked. */
+
+
+            if( wantIndexedMode )
+            {
+                /*
+                 * In index mode, we want the largest buffer size, i.e. visual
+                 * depth.  Here, FBConfigs are sorted by increasing buffer size
+                 * first, so FBConfigs with the largest size come last.
+                 */
+
+                int bufferSizeMin, bufferSizeMax;
+
+                /*  Get bufferSizeMin.  */
+                result =
+                  glXGetFBConfigAttrib( fgDisplay.Display,
+                                        fbconfigArray[0],
+                                        GLX_BUFFER_SIZE,
+                                        &bufferSizeMin );
+                /*  Get bufferSizeMax.  */
+                result =
+                  glXGetFBConfigAttrib( fgDisplay.Display,
+                                        fbconfigArray[fbconfigArraySize - 1],
+                                        GLX_BUFFER_SIZE,
+                                        &bufferSizeMax );
+
+                if (bufferSizeMax > bufferSizeMin)
+                {
+                    /* 
+                     * Free and reallocate fbconfigArray, keeping only FBConfigs
+                     * with the largest buffer size.
+                     */
+                    XFree(fbconfigArray);
+
+                    /*  Add buffer size token at the end of the list.  */
+                    where--;
+                    ATTRIB_VAL( GLX_BUFFER_SIZE, bufferSizeMax );
+                    ATTRIB( None );
+
+                    fbconfigArray = glXChooseFBConfig( fgDisplay.Display,
+                                                       fgDisplay.Screen,
+                                                       attributes,
+                                                       &fbconfigArraySize );
+                }
+            }
+
+            /*
+             * We now have an array of FBConfigs, the first one being the "best"
+             * one.  So we should return only this FBConfig:
+             *
+             * int fbconfigXID;
+             *
+             *  - pick the XID of the FBConfig we want
+             * result = glXGetFBConfigAttrib( fgDisplay.Display,
+             *                                fbconfigArray[0],
+             *                                GLX_FBCONFIG_ID,
+             *                                &fbconfigXID );
+             *
+             * - free the array
+             * XFree(fbconfigArray);
+             *
+             * - reset "attributes" with the XID
+             * where = 0;
+             * ATTRIB_VAL( GLX_FBCONFIG_ID, fbconfigXID );
+             * ATTRIB( None );
+             *
+             * - get our FBConfig only
+             * fbconfig = glXChooseFBConfig( fgDisplay.Display,
+             *                               fgDisplay.Screen,
+             *                               attributes,
+             *                               &fbconfigArraySize );
+             *
+             * However, for some configurations (for instance multisampling with
+             * Mesa 6.5.2 and ATI drivers), this does not work:
+             * glXChooseFBConfig returns NULL, whereas fbconfigXID is a valid
+             * XID.  Further investigation is needed.
+             *
+             * So, for now, we return the whole array of FBConfigs.  This should
+             * not produce any side effects elsewhere.
+             */
+            fbconfig = fbconfigArray;
         }
-        return NULL;
+        else
+        {
+           fbconfig = NULL;
+        }
+
+        return fbconfig;
     }
 }
-#endif
+#endif /* TARGET_HOST_POSIX_X11 */
 
 /*
  * Setup the pixel format for a Win32 window
  */
-#if TARGET_HOST_WIN32
+#if TARGET_HOST_MS_WINDOWS
+/* The following include file is available from SGI but is not standard:
+ *   #include <GL/wglext.h>
+ * So we copy the necessary parts out of it.
+ * XXX: should local definitions for extensions be put in a separate include file?
+ */
+typedef const char * (WINAPI * PFNWGLGETEXTENSIONSSTRINGARBPROC) (HDC hdc);
+
+typedef BOOL (WINAPI * PFNWGLCHOOSEPIXELFORMATARBPROC) (HDC hdc, const int *piAttribIList, const FLOAT *pfAttribFList, UINT nMaxFormats, int *piFormats, UINT *nNumFormats);
+
+#define WGL_DRAW_TO_WINDOW_ARB         0x2001
+#define WGL_ACCELERATION_ARB           0x2003
+#define WGL_SUPPORT_OPENGL_ARB         0x2010
+#define WGL_DOUBLE_BUFFER_ARB          0x2011
+#define WGL_COLOR_BITS_ARB             0x2014
+#define WGL_ALPHA_BITS_ARB             0x201B
+#define WGL_DEPTH_BITS_ARB             0x2022
+#define WGL_STENCIL_BITS_ARB           0x2023
+#define WGL_FULL_ACCELERATION_ARB      0x2027
+
+#define WGL_SAMPLE_BUFFERS_ARB         0x2041
+#define WGL_SAMPLES_ARB                0x2042
+
+
 GLboolean fgSetupPixelFormat( SFG_Window* window, GLboolean checkOnly,
                               unsigned char layer_type )
 {
-#if TARGET_HOST_WINCE
+#if defined(_WIN32_WCE)
     return GL_TRUE;
 #else
     PIXELFORMATDESCRIPTOR* ppfd, pfd;
@@ -184,6 +297,9 @@
     if( fgState.DisplayMode & GLUT_DOUBLE )
         flags |= PFD_DOUBLEBUFFER;
 
+    if( fgState.DisplayMode & GLUT_STEREO )
+        flags |= PFD_STEREO;
+
 #if defined(_MSC_VER)
 #pragma message( "fgSetupPixelFormat(): there is still some work to do here!" )
 #endif
@@ -192,15 +308,31 @@
     pfd.nSize           = sizeof(PIXELFORMATDESCRIPTOR);
     pfd.nVersion        = 1;
     pfd.dwFlags         = flags;
-    pfd.iPixelType      = PFD_TYPE_RGBA;
+
+    if( fgState.DisplayMode & GLUT_INDEX )
+    {
+        pfd.iPixelType = PFD_TYPE_COLORINDEX;
+        pfd.cRedBits                = 0;
+        pfd.cGreenBits            = 0;
+        pfd.cBlueBits             = 0;
+        pfd.cAlphaBits            = 0;
+    }
+    else
+    {
+        pfd.iPixelType      = PFD_TYPE_RGBA;
+        pfd.cRedBits                = 8;
+        pfd.cGreenBits            = 8;
+        pfd.cBlueBits             = 8;
+        if ( fgState.DisplayMode & GLUT_ALPHA )
+            pfd.cAlphaBits            = 8;
+        else
+            pfd.cAlphaBits            = 0;
+    }
+
     pfd.cColorBits      = 24;
-    pfd.cRedBits        = 0;
     pfd.cRedShift       = 0;
-    pfd.cGreenBits      = 0;
     pfd.cGreenShift     = 0;
-    pfd.cBlueBits       = 0;
     pfd.cBlueShift      = 0;
-    pfd.cAlphaBits      = 0;
     pfd.cAlphaShift     = 0;
     pfd.cAccumBits      = 0;
     pfd.cAccumRedBits   = 0;
@@ -235,15 +367,88 @@
     ppfd = &pfd;
 
     pixelformat = ChoosePixelFormat( window->Window.Device, ppfd );
+
+    /* windows hack for multismapling */
+    if (fgState.DisplayMode&GLUT_MULTISAMPLE)
+    {        
+        PFNWGLGETEXTENSIONSSTRINGARBPROC wglGetEntensionsStringARB=NULL;
+        HGLRC rc, rc_before=wglGetCurrentContext();
+        HWND hWnd;
+        HDC hDC, hDC_before=wglGetCurrentDC();
+        WNDCLASS wndCls;
+
+        /* create a dummy window */
+        ZeroMemory(&wndCls, sizeof(wndCls));
+        wndCls.lpfnWndProc = DefWindowProc;
+        wndCls.hInstance = fgDisplay.Instance;
+        wndCls.style = CS_OWNDC | CS_HREDRAW | CS_VREDRAW;
+        wndCls.lpszClassName = _T("FREEGLUT_dummy");
+        RegisterClass( &wndCls );
+
+        hWnd=CreateWindow(_T("FREEGLUT_dummy"), _T(""), WS_CLIPSIBLINGS | WS_CLIPCHILDREN | WS_OVERLAPPEDWINDOW , 0,0,0,0, 0, 0, fgDisplay.Instance, 0 );
+        hDC=GetDC(hWnd);
+        SetPixelFormat( hDC, pixelformat, ppfd );
+        
+        rc = wglCreateContext( hDC );
+        wglMakeCurrent(hDC, rc);
+        
+        wglGetEntensionsStringARB=(PFNWGLGETEXTENSIONSSTRINGARBPROC)wglGetProcAddress("wglGetExtensionsStringARB");
+        if (wglGetEntensionsStringARB)
+        {
+            const char * pWglExtString=wglGetEntensionsStringARB(hDC);
+            if (pWglExtString)
+            {
+                if (strstr(pWglExtString, "WGL_ARB_multisample"))
+                {
+                    int pAttributes[100];
+                    int iCounter=0;
+                    int iPixelFormat;
+                    BOOL bValid;
+                    float fAttributes[] = {0,0};
+                    UINT numFormats;
+                    PFNWGLCHOOSEPIXELFORMATARBPROC wglChoosePixelFormatARBProc=NULL;
+
+                    wglChoosePixelFormatARBProc=(PFNWGLCHOOSEPIXELFORMATARBPROC)wglGetProcAddress("wglChoosePixelFormatARB");
+                    if ( wglChoosePixelFormatARBProc )
+                    {
+                        pAttributes[iCounter++]=WGL_DRAW_TO_WINDOW_ARB;        pAttributes[iCounter++]=GL_TRUE;
+                        pAttributes[iCounter++]=WGL_SUPPORT_OPENGL_ARB;        pAttributes[iCounter++]=GL_TRUE;
+                        pAttributes[iCounter++]=WGL_ACCELERATION_ARB;        pAttributes[iCounter++]=WGL_FULL_ACCELERATION_ARB;
+
+                        pAttributes[iCounter++]=WGL_COLOR_BITS_ARB;            pAttributes[iCounter++]=pfd.cColorBits ;
+                        pAttributes[iCounter++]=WGL_ALPHA_BITS_ARB;            pAttributes[iCounter++]=pfd.cAlphaBits;
+                        pAttributes[iCounter++]=WGL_DEPTH_BITS_ARB;            pAttributes[iCounter++]=pfd.cDepthBits;
+                        pAttributes[iCounter++]=WGL_STENCIL_BITS_ARB;        pAttributes[iCounter++]=pfd.cStencilBits;
+
+                        pAttributes[iCounter++]=WGL_DOUBLE_BUFFER_ARB;        pAttributes[iCounter++]=(fgState.DisplayMode & GLUT_DOUBLE)!=0;
+                        pAttributes[iCounter++]=WGL_SAMPLE_BUFFERS_ARB;        pAttributes[iCounter++]=GL_TRUE;
+                        pAttributes[iCounter++]=WGL_SAMPLES_ARB;            pAttributes[iCounter++]=4;
+                        pAttributes[iCounter++]=0;                            pAttributes[iCounter++]=0;    /* terminator */
+
+                        bValid = wglChoosePixelFormatARBProc(window->Window.Device,pAttributes,fAttributes,1,&iPixelFormat,&numFormats);
+
+                        if (bValid && numFormats>0)
+                            pixelformat=iPixelFormat;
+                    }
+                }
+                wglMakeCurrent( hDC_before, rc_before);
+                wglDeleteContext(rc);
+                ReleaseDC(hWnd, hDC);
+                DestroyWindow(hWnd);
+                UnregisterClass(_T("FREEGLUT_dummy"), fgDisplay.Instance);
+            }
+        }
+    }
+
     if( pixelformat == 0 )
         return GL_FALSE;
 
     if( checkOnly )
         return GL_TRUE;
     return SetPixelFormat( window->Window.Device, pixelformat, ppfd );
-#endif /* TARGET_HOST_WINCE */
+#endif /* defined(_WIN32_WCE) */
 }
-#endif
+#endif /* TARGET_HOST_MS_WINDOWS */
 
 /*
  * Sets the OpenGL context and the fgStructure "Current Window" pointer to
@@ -251,14 +456,15 @@
  */
 void fgSetWindow ( SFG_Window *window )
 {
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
     if ( window )
-        glXMakeCurrent(
+        glXMakeContextCurrent(
             fgDisplay.Display,
             window->Window.Handle,
+            window->Window.Handle,
             window->Window.Context
         );
-#elif TARGET_HOST_WIN32 || TARGET_HOST_WINCE
+#elif TARGET_HOST_MS_WINDOWS
     if( fgStructure.CurrentWindow )
         ReleaseDC( fgStructure.CurrentWindow->Window.Handle,
                    fgStructure.CurrentWindow->Window.Device );
@@ -276,15 +482,101 @@
 }
 
 
+
+#if TARGET_HOST_POSIX_X11
+
+#ifndef GLX_CONTEXT_MAJOR_VERSION_ARB
+#define GLX_CONTEXT_MAJOR_VERSION_ARB 0x2091
+#endif
+
+#ifndef GLX_CONTEXT_MINOR_VERSION_ARB
+#define GLX_CONTEXT_MINOR_VERSION_ARB 0x2092
+#endif
+
+#ifndef GLX_CONTEXT_FLAGS_ARB
+#define GLX_CONTEXT_FLAGS_ARB 0x2094
+#endif
+
+#ifndef GLX_CONTEXT_DEBUG_BIT_ARB
+#define GLX_CONTEXT_DEBUG_BIT_ARB 0x0001
+#endif
+
+#ifndef GLX_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB
+#define GLX_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB 0x0002
+#endif
+
+typedef GLXContext (*CreateContextAttribsProc)(Display *dpy, GLXFBConfig config,
+					       GLXContext share_list, Bool direct,
+					       const int *attrib_list);
+
+static GLXContext fghCreateNewContext( SFG_Window* window )
+{
+  /* for color model calculation */
+  int menu = ( window->IsMenu && !fgStructure.MenuContext );
+  int index_mode = ( fgState.DisplayMode & GLUT_INDEX );
+
+  /* "classic" context creation */
+  Display *dpy = fgDisplay.Display;
+  GLXFBConfig config = *(window->Window.FBConfig);
+  int render_type = ( !menu && index_mode ) ? GLX_COLOR_INDEX_TYPE : GLX_RGBA_TYPE;
+  GLXContext share_list = NULL;
+  Bool direct = ( fgState.DirectContext != GLUT_FORCE_INDIRECT_CONTEXT );
+  GLXContext context;
+
+  /* new context creation */
+  int attribs[7];
+  CreateContextAttribsProc createContextAttribs;
+
+  /* If nothing fancy has been required, simply use the old context creation GLX API entry */
+  if ( fgState.MajorVersion == 1 && fgState.MinorVersion == 0 && fgState.ContextFlags == 0)
+  {
+    context = glXCreateNewContext( dpy, config, render_type, share_list, direct );
+    if ( context == NULL ) {
+      fgError( "could not create new OpenGL context" );
+    }
+    return context;
+  }
+
+  /* color index mode is not available anymore with OpenGL 3.0 */
+  if ( render_type == GLX_COLOR_INDEX_TYPE ) {
+    fgWarning( "color index mode is deprecated, using RGBA mode" );
+  }
+
+  attribs[0] = GLX_CONTEXT_MAJOR_VERSION_ARB;
+  attribs[1] = fgState.MajorVersion;
+  attribs[2] = GLX_CONTEXT_MINOR_VERSION_ARB;
+  attribs[3] = fgState.MinorVersion;
+  attribs[4] = GLX_CONTEXT_FLAGS_ARB;
+  attribs[5] = ((fgState.ContextFlags & GLUT_DEBUG) ? GLX_CONTEXT_DEBUG_BIT_ARB : 0) |
+    ((fgState.ContextFlags & GLUT_FORWARD_COMPATIBLE) ? GLX_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB : 0);
+  attribs[6] = 0;
+
+  createContextAttribs = (CreateContextAttribsProc) fghGetProcAddress( "glXCreateContextAttribsARB" );
+  if ( createContextAttribs == NULL ) {
+    fgError( "glXCreateContextAttribsARB not found" );
+  }
+
+  context = createContextAttribs( dpy, config, share_list, direct, attribs );
+  if ( context == NULL ) {
+    fgError( "could not create new OpenGL %d.%d context (flags %x)",
+	     fgState.MajorVersion, fgState.MinorVersion, fgState.ContextFlags );
+  }
+  return context;
+}
+#endif
+
+
 /*
  * Opens a window. Requires a SFG_Window object created and attached
  * to the freeglut structure. OpenGL context is created here.
  */
 void fgOpenWindow( SFG_Window* window, const char* title,
-                   int x, int y, int w, int h,
+                   GLboolean positionUse, int x, int y,
+                   GLboolean sizeUse, int w, int h,
                    GLboolean gameMode, GLboolean isSubWindow )
 {
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
+    XVisualInfo * visualInfo;
     XSetWindowAttributes winAttr;
     XTextProperty textProperty;
     XSizeHints sizeHints;
@@ -296,33 +588,39 @@
     if( window->IsMenu && ( ! fgStructure.MenuContext ) )
         fgState.DisplayMode = GLUT_DOUBLE | GLUT_RGB ;
 
-    window->Window.VisualInfo = fgChooseVisual( );
+    window->Window.FBConfig = fgChooseFBConfig( );
 
     if( window->IsMenu && ( ! fgStructure.MenuContext ) )
         fgState.DisplayMode = current_DisplayMode ;
 
-    if( ! window->Window.VisualInfo )
+    if( ! window->Window.FBConfig )
     {
         /*
-         * The "fgChooseVisual" returned a null meaning that the visual
+         * The "fgChooseFBConfig" returned a null meaning that the visual
          * context is not available.
          * Try a couple of variations to see if they will work.
          */
         if( !( fgState.DisplayMode & GLUT_DOUBLE ) )
         {
             fgState.DisplayMode |= GLUT_DOUBLE ;
-            window->Window.VisualInfo = fgChooseVisual( );
+            window->Window.FBConfig = fgChooseFBConfig( );
             fgState.DisplayMode &= ~GLUT_DOUBLE;
         }
 
-        /*
-         * GLUT also checks for multi-sampling, but I don't see that
-         * anywhere else in FREEGLUT so I won't bother with it for the moment.
-         */
+        if( fgState.DisplayMode & GLUT_MULTISAMPLE )
+        {
+            fgState.DisplayMode &= ~GLUT_MULTISAMPLE ;
+            window->Window.FBConfig = fgChooseFBConfig( );
+            fgState.DisplayMode |= GLUT_MULTISAMPLE;
+        }
     }
 
-    FREEGLUT_INTERNAL_ERROR_EXIT( window->Window.VisualInfo != NULL,
-                                  "Visual with necessary capabilities not found", "fgOpenWindow" );
+    FREEGLUT_INTERNAL_ERROR_EXIT( window->Window.FBConfig != NULL,
+                                  "FBConfig with necessary capabilities not found", "fgOpenWindow" );
+
+    /*  Get the X visual.  */
+    visualInfo = glXGetVisualFromFBConfig( fgDisplay.Display,
+                                           *(window->Window.FBConfig) );
 
     /*
      * XXX HINT: the masks should be updated when adding/removing callbacks.
@@ -345,7 +643,7 @@
 
     winAttr.colormap = XCreateColormap(
         fgDisplay.Display, fgDisplay.RootWindow,
-        window->Window.VisualInfo->visual, AllocNone
+        visualInfo->visual, AllocNone
     );
 
     mask = CWBackPixmap | CWBorderPixel | CWColormap | CWEventMask;
@@ -356,13 +654,18 @@
         mask |= CWOverrideRedirect;
     }
 
+    if( ! positionUse )
+        x = y = -1; /* default window position */
+    if( ! sizeUse )
+        w = h = 300; /* default window size */
+
     window->Window.Handle = XCreateWindow(
         fgDisplay.Display,
         window->Parent == NULL ? fgDisplay.RootWindow :
         window->Parent->Window.Handle,
         x, y, w, h, 0,
-        window->Window.VisualInfo->depth, InputOutput,
-        window->Window.VisualInfo->visual, mask,
+        visualInfo->depth, InputOutput,
+        visualInfo->visual, mask,
         &winAttr
     );
 
@@ -370,6 +673,7 @@
      * The GLX context creation, possibly trying the direct context rendering
      *  or else use the current context if the user has so specified
      */
+
     if( window->IsMenu )
     {
         /*
@@ -380,34 +684,21 @@
         {
             fgStructure.MenuContext =
                 (SFG_MenuContext *)malloc( sizeof(SFG_MenuContext) );
-            fgStructure.MenuContext->VisualInfo = window->Window.VisualInfo;
-            fgStructure.MenuContext->Context = glXCreateContext(
-                fgDisplay.Display, fgStructure.MenuContext->VisualInfo,
-                NULL, ( fgState.DirectContext != GLUT_FORCE_INDIRECT_CONTEXT )
-            );
+            fgStructure.MenuContext->MContext = fghCreateNewContext( window );
         }
 
-        /* window->Window.Context = fgStructure.MenuContext->Context; */
-        window->Window.Context = glXCreateContext(
-            fgDisplay.Display, window->Window.VisualInfo,
-            NULL, ( fgState.DirectContext != GLUT_FORCE_INDIRECT_CONTEXT )
-        );
+        /* window->Window.Context = fgStructure.MenuContext->MContext; */
+        window->Window.Context = fghCreateNewContext( window );
     }
     else if( fgState.UseCurrentContext )
     {
         window->Window.Context = glXGetCurrentContext( );
 
         if( ! window->Window.Context )
-            window->Window.Context = glXCreateContext(
-                fgDisplay.Display, window->Window.VisualInfo,
-                NULL, ( fgState.DirectContext != GLUT_FORCE_INDIRECT_CONTEXT )
-            );
+            window->Window.Context = fghCreateNewContext( window );
     }
     else
-        window->Window.Context = glXCreateContext(
-            fgDisplay.Display, window->Window.VisualInfo,
-            NULL, ( fgState.DirectContext != GLUT_FORCE_INDIRECT_CONTEXT )
-        );
+        window->Window.Context = fghCreateNewContext( window );
 
 #if !defined( __FreeBSD__ ) && !defined( __NetBSD__ )
     if(  !glXIsDirect( fgDisplay.Display, window->Window.Context ) )
@@ -415,9 +706,6 @@
       if( fgState.DirectContext == GLUT_FORCE_DIRECT_CONTEXT )
         fgError( "Unable to force direct context rendering for window '%s'",
                  title );
-      else if( fgState.DirectContext == GLUT_TRY_DIRECT_CONTEXT )
-        fgWarning( "Unable to create direct context rendering for window '%s'\nThis may hurt performance.",
-                 title );
     }
 #endif
 
@@ -428,9 +716,9 @@
     window->State.Visible = GL_TRUE;
 
     sizeHints.flags = 0;
-    if ( fgState.Position.Use )
+    if ( positionUse )
         sizeHints.flags |= USPosition;
-    if ( fgState.Size.Use )
+    if ( sizeUse )
         sizeHints.flags |= USSize;
 
     /*
@@ -467,20 +755,24 @@
     XSetWMProtocols( fgDisplay.Display, window->Window.Handle,
                      &fgDisplay.DeleteWindow, 1 );
 
-    glXMakeCurrent(
+    glXMakeContextCurrent(
         fgDisplay.Display,
         window->Window.Handle,
+        window->Window.Handle,
         window->Window.Context
     );
 
     XMapWindow( fgDisplay.Display, window->Window.Handle );
 
-#elif TARGET_HOST_WIN32 || TARGET_HOST_WINCE
+    XFree(visualInfo);
+
+#elif TARGET_HOST_MS_WINDOWS
 
     WNDCLASS wc;
     DWORD flags;
     DWORD exFlags = 0;
     ATOM atom;
+    int WindowStyle = 0;
 
     /* Grab the window class we have registered on glutInit(): */
     atom = GetClassInfo( fgDisplay.Instance, _T("FREEGLUT"), &wc );
@@ -501,7 +793,9 @@
     }
     else
     {
-#if !TARGET_HOST_WINCE
+        int worig = w, horig = h;
+
+#if !defined(_WIN32_WCE)
         if ( ( ! isSubWindow ) && ( ! window->IsMenu ) )
         {
             /*
@@ -513,17 +807,29 @@
             h += (GetSystemMetrics( SM_CYSIZEFRAME ) )*2 +
                 GetSystemMetrics( SM_CYCAPTION );
         }
-#endif /* TARGET_HOST_WINCE */
+#endif /* defined(_WIN32_WCE) */
 
-        if( ! fgState.Position.Use )
+        if( ! positionUse )
         {
             x = CW_USEDEFAULT;
             y = CW_USEDEFAULT;
         }
-        if( ! fgState.Size.Use )
+        /* setting State.Width/Height to call resize callback later */
+        if( ! sizeUse )
+        {
+            if( ! window->IsMenu )
+            {
+                w = CW_USEDEFAULT;
+                h = CW_USEDEFAULT;
+            }
+            else /* fail safe - Windows can make a window of size (0, 0) */
+                w = h = 300; /* default window size */
+            window->State.Width = window->State.Height = -1;
+        }
+        else
         {
-            w = CW_USEDEFAULT;
-            h = CW_USEDEFAULT;
+            window->State.Width = worig;
+            window->State.Height = horig;
         }
 
         /*
@@ -537,7 +843,7 @@
             flags |= WS_POPUP;
             exFlags |= WS_EX_TOOLWINDOW;
         }
-#if !TARGET_HOST_WINCE
+#if !defined(_WIN32_WCE)
         else if( window->Parent == NULL )
             flags |= WS_OVERLAPPEDWINDOW;
 #endif
@@ -545,7 +851,7 @@
             flags |= WS_CHILD;
     }
 
-#if TARGET_HOST_WINCE
+#if defined(_WIN32_WCE)
     {
         wchar_t* wstr = fghWstrFromStr(title);
 
@@ -572,7 +878,7 @@
 #else
     window->Window.Handle = CreateWindowEx(
         exFlags,
-        "FREEGLUT",
+        _T("FREEGLUT"),
         title,
         flags,
         x, y, w, h,
@@ -581,17 +887,44 @@
         fgDisplay.Instance,
         (LPVOID) window
     );
-#endif /* TARGET_HOST_WINCE */
+#endif /* defined(_WIN32_WCE) */
 
     if( !( window->Window.Handle ) )
         fgError( "Failed to create a window (%s)!", title );
 
-#if TARGET_HOST_WINCE
+    /* Make a menu window always on top - fix Feature Request 947118 */
+    if( window->IsMenu || gameMode )
+        SetWindowPos(
+                        window->Window.Handle,
+                        HWND_TOPMOST,
+                        0, 0, 0, 0,
+                        SWP_NOMOVE | SWP_NOSIZE
+                    );
+
+    /* Hack to remove the caption (title bar) and/or border
+     * and all the system menu controls.
+     */
+    WindowStyle = GetWindowLong(window->Window.Handle, GWL_STYLE);
+    if ( fgState.DisplayMode & GLUT_CAPTIONLESS )
+    {
+        SetWindowLong ( window->Window.Handle, GWL_STYLE,
+                        WindowStyle & ~(WS_DLGFRAME | WS_SYSMENU | WS_MINIMIZEBOX | WS_MAXIMIZEBOX));
+    }
+    else if ( fgState.DisplayMode & GLUT_BORDERLESS )
+    {
+        SetWindowLong ( window->Window.Handle, GWL_STYLE,
+                        WindowStyle & ~(WS_BORDER | WS_SYSMENU | WS_MINIMIZEBOX | WS_MAXIMIZEBOX));
+    }
+/*  SetWindowPos(window->Window.Handle, NULL, 0, 0, 0, 0,
+     SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED); */
+
+
+#if defined(_WIN32_WCE)
     ShowWindow( window->Window.Handle, SW_SHOW );
 #else
     ShowWindow( window->Window.Handle,
                 fgState.ForceIconic ? SW_SHOWMINIMIZED : SW_SHOW );
-#endif /* TARGET_HOST_WINCE */
+#endif /* defined(_WIN32_WCE) */
 
     UpdateWindow( window->Window.Handle );
     ShowCursor( TRUE );  /* XXX Old comments say "hide cursor"! */
@@ -615,13 +948,14 @@
  */
 void fgCloseWindow( SFG_Window* window )
 {
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
 
     glXDestroyContext( fgDisplay.Display, window->Window.Context );
+    XFree( window->Window.FBConfig );
     XDestroyWindow( fgDisplay.Display, window->Window.Handle );
-    XFlush( fgDisplay.Display ); /* XXX Shouldn't need this */
+    /* XFlush( fgDisplay.Display ); */ /* XXX Shouldn't need this */
 
-#elif TARGET_HOST_WIN32 || TARGET_HOST_WINCE
+#elif TARGET_HOST_MS_WINDOWS
 
     /* Make sure we don't close a window with current context active */
     if( fgStructure.CurrentWindow == window )
@@ -668,9 +1002,10 @@
      */
     FREEGLUT_EXIT_IF_NOT_INITIALISED ( "glutCreateWindow" );
 
-    return fgCreateWindow( NULL, title, fgState.Position.X, fgState.Position.Y,
-                           fgState.Size.X, fgState.Size.Y, GL_FALSE,
-                           GL_FALSE )->ID;
+    return fgCreateWindow( NULL, title, fgState.Position.Use,
+                           fgState.Position.X, fgState.Position.Y,
+                           fgState.Size.Use, fgState.Size.X, fgState.Size.Y,
+                           GL_FALSE, GL_FALSE )->ID;
 }
 
 /*
@@ -711,7 +1046,7 @@
         h = -h ;
     }
 
-    window = fgCreateWindow( parent, "", x, y, w, h, GL_FALSE, GL_FALSE );
+    window = fgCreateWindow( parent, "", GL_TRUE, x, y, GL_TRUE, w, h, GL_FALSE, GL_FALSE );
     ret = window->ID;
 
     return ret;
@@ -760,10 +1095,18 @@
  */
 int FGAPIENTRY glutGetWindow( void )
 {
-    FREEGLUT_EXIT_IF_NOT_INITIALISED ( "glutGetWindow" );
-    if( fgStructure.CurrentWindow == NULL )
+    SFG_Window *win = fgStructure.CurrentWindow;
+    /*
+     * Since GLUT did not throw an error if this function was called without a prior call to
+     * "glutInit", this function shouldn't do so here.  Instead let us return a zero.
+     * See Feature Request "[ 1307049 ] glutInit check".
+     */
+    if ( ! fgState.Initialised )
         return 0;
-    return fgStructure.CurrentWindow->ID;
+
+    while ( win && win->IsMenu )
+        win = win->Parent;
+    return win ? win->ID : 0;
 }
 
 /*
@@ -774,12 +1117,12 @@
     FREEGLUT_EXIT_IF_NOT_INITIALISED ( "glutShowWindow" );
     FREEGLUT_EXIT_IF_NO_WINDOW ( "glutShowWindow" );
 
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
 
     XMapWindow( fgDisplay.Display, fgStructure.CurrentWindow->Window.Handle );
     XFlush( fgDisplay.Display ); /* XXX Shouldn't need this */
 
-#elif TARGET_HOST_WIN32 || TARGET_HOST_WINCE
+#elif TARGET_HOST_MS_WINDOWS
 
     ShowWindow( fgStructure.CurrentWindow->Window.Handle, SW_SHOW );
 
@@ -796,7 +1139,7 @@
     FREEGLUT_EXIT_IF_NOT_INITIALISED ( "glutHideWindow" );
     FREEGLUT_EXIT_IF_NO_WINDOW ( "glutHideWindow" );
 
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
 
     if( fgStructure.CurrentWindow->Parent == NULL )
         XWithdrawWindow( fgDisplay.Display,
@@ -807,7 +1150,7 @@
                       fgStructure.CurrentWindow->Window.Handle );
     XFlush( fgDisplay.Display ); /* XXX Shouldn't need this */
 
-#elif TARGET_HOST_WIN32 || TARGET_HOST_WINCE
+#elif TARGET_HOST_MS_WINDOWS
 
     ShowWindow( fgStructure.CurrentWindow->Window.Handle, SW_HIDE );
 
@@ -825,13 +1168,13 @@
     FREEGLUT_EXIT_IF_NO_WINDOW ( "glutIconifyWindow" );
 
     fgStructure.CurrentWindow->State.Visible   = GL_FALSE;
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
 
     XIconifyWindow( fgDisplay.Display, fgStructure.CurrentWindow->Window.Handle,
                     fgDisplay.Screen );
     XFlush( fgDisplay.Display ); /* XXX Shouldn't need this */
 
-#elif TARGET_HOST_WIN32 || TARGET_HOST_WINCE
+#elif TARGET_HOST_MS_WINDOWS
 
     ShowWindow( fgStructure.CurrentWindow->Window.Handle, SW_MINIMIZE );
 
@@ -849,7 +1192,7 @@
     FREEGLUT_EXIT_IF_NO_WINDOW ( "glutSetWindowTitle" );
     if( ! fgStructure.CurrentWindow->Parent )
     {
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
 
         XTextProperty text;
 
@@ -866,18 +1209,17 @@
 
         XFlush( fgDisplay.Display ); /* XXX Shouldn't need this */
 
-#elif TARGET_HOST_WIN32
-
-        SetWindowText( fgStructure.CurrentWindow->Window.Handle, title );
-
-#elif TARGET_HOST_WINCE
+#elif TARGET_HOST_MS_WINDOWS
+#    ifdef _WIN32_WCE
         {
             wchar_t* wstr = fghWstrFromStr(title);
-
             SetWindowText( fgStructure.CurrentWindow->Window.Handle, wstr );
-
             free(wstr);
         }
+#    else
+        SetWindowText( fgStructure.CurrentWindow->Window.Handle, title );
+#    endif
+
 #endif
     }
 }
@@ -892,7 +1234,7 @@
 
     if( ! fgStructure.CurrentWindow->Parent )
     {
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
 
         XTextProperty text;
 
@@ -909,18 +1251,17 @@
 
         XFlush( fgDisplay.Display ); /* XXX Shouldn't need this */
 
-#elif TARGET_HOST_WIN32
-
-        SetWindowText( fgStructure.CurrentWindow->Window.Handle, title );
-
-#elif TARGET_HOST_WINCE
+#elif TARGET_HOST_MS_WINDOWS
+#    ifdef _WIN32_WCE
         {
             wchar_t* wstr = fghWstrFromStr(title);
-
             SetWindowText( fgStructure.CurrentWindow->Window.Handle, wstr );
-
             free(wstr);
         }
+#    else
+        SetWindowText( fgStructure.CurrentWindow->Window.Handle, title );
+#    endif
+
 #endif
     }
 }
@@ -933,6 +1274,12 @@
     FREEGLUT_EXIT_IF_NOT_INITIALISED ( "glutReshapeWindow" );
     FREEGLUT_EXIT_IF_NO_WINDOW ( "glutReshapeWindow" );
 
+    if (glutGet(GLUT_FULL_SCREEN))
+    {
+      /*  Leave full screen state before resizing. */
+      glutFullScreenToggle();
+    }
+
     fgStructure.CurrentWindow->State.NeedToResize = GL_TRUE;
     fgStructure.CurrentWindow->State.Width  = width ;
     fgStructure.CurrentWindow->State.Height = height;
@@ -946,13 +1293,19 @@
     FREEGLUT_EXIT_IF_NOT_INITIALISED ( "glutPositionWindow" );
     FREEGLUT_EXIT_IF_NO_WINDOW ( "glutPositionWindow" );
 
-#if TARGET_HOST_UNIX_X11
+    if (glutGet(GLUT_FULL_SCREEN))
+    {
+      /*  Leave full screen state before moving. */
+      glutFullScreenToggle();
+    }
+
+#if TARGET_HOST_POSIX_X11
 
     XMoveWindow( fgDisplay.Display, fgStructure.CurrentWindow->Window.Handle,
                  x, y );
     XFlush( fgDisplay.Display ); /* XXX Shouldn't need this */
 
-#elif TARGET_HOST_WIN32 || TARGET_HOST_WINCE
+#elif TARGET_HOST_MS_WINDOWS
 
     {
         RECT winRect;
@@ -980,11 +1333,11 @@
     FREEGLUT_EXIT_IF_NOT_INITIALISED ( "glutPushWindow" );
     FREEGLUT_EXIT_IF_NO_WINDOW ( "glutPushWindow" );
 
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
 
     XLowerWindow( fgDisplay.Display, fgStructure.CurrentWindow->Window.Handle );
 
-#elif TARGET_HOST_WIN32 || TARGET_HOST_WINCE
+#elif TARGET_HOST_MS_WINDOWS
 
     SetWindowPos(
         fgStructure.CurrentWindow->Window.Handle,
@@ -1004,11 +1357,11 @@
     FREEGLUT_EXIT_IF_NOT_INITIALISED ( "glutPopWindow" );
     FREEGLUT_EXIT_IF_NO_WINDOW ( "glutPopWindow" );
 
-#if TARGET_HOST_UNIX_X11
+#if TARGET_HOST_POSIX_X11
 
     XRaiseWindow( fgDisplay.Display, fgStructure.CurrentWindow->Window.Handle );
 
-#elif TARGET_HOST_WIN32 || TARGET_HOST_WINCE
+#elif TARGET_HOST_MS_WINDOWS
 
     SetWindowPos(
         fgStructure.CurrentWindow->Window.Handle,
@@ -1028,38 +1381,33 @@
     FREEGLUT_EXIT_IF_NOT_INITIALISED ( "glutFullScreen" );
     FREEGLUT_EXIT_IF_NO_WINDOW ( "glutFullScreen" );
 
+    if (glutGet(GLUT_FULL_SCREEN))
     {
-#if TARGET_HOST_UNIX_X11
-        int x, y;
-        Window w;
+      /*  Leave full screen state before resizing. */
+      glutFullScreenToggle();
+    }
 
-        XMoveResizeWindow(
-            fgDisplay.Display,
-            fgStructure.CurrentWindow->Window.Handle,
-            0, 0,
-            fgDisplay.ScreenWidth,
-            fgDisplay.ScreenHeight
-        );
+    {
+#if TARGET_HOST_POSIX_X11
 
-        XFlush( fgDisplay.Display ); /* This is needed */
+        Status status;  /* Returned by XGetWindowAttributes(), not checked. */
+        XWindowAttributes attributes;
 
-        XTranslateCoordinates(
-            fgDisplay.Display,
-            fgStructure.CurrentWindow->Window.Handle,
-            fgDisplay.RootWindow,
-            0, 0, &x, &y, &w
-        );
+        status = XGetWindowAttributes(fgDisplay.Display,
+                                      fgStructure.CurrentWindow->Window.Handle,
+                                      &attributes);
+        /*
+         * The "x" and "y" members of "attributes" are the window's coordinates
+         * relative to its parent, i.e. to the decoration window.
+         */
+        XMoveResizeWindow(fgDisplay.Display,
+                          fgStructure.CurrentWindow->Window.Handle,
+                          -attributes.x,
+                          -attributes.y,
+                          fgDisplay.ScreenWidth,
+                          fgDisplay.ScreenHeight);
 
-        if (x || y)
-        {
-            XMoveWindow(
-                fgDisplay.Display,
-                fgStructure.CurrentWindow->Window.Handle,
-                -x, -y
-            );
-            XFlush( fgDisplay.Display ); /* XXX Shouldn't need this */
-        }
-#elif TARGET_HOST_WIN32
+#elif TARGET_HOST_MS_WINDOWS && !defined(_WIN32_WCE) /* FIXME: what about WinCE */
         RECT rect;
 
         /* For fullscreen mode, force the top-left corner to 0,0
@@ -1096,6 +1444,61 @@
 }
 
 /*
+ * Toggle the window's full screen state.
+ */
+void FGAPIENTRY glutFullScreenToggle( void )
+{
+    FREEGLUT_EXIT_IF_NOT_INITIALISED ( "glutFullScreenToggle" );
+    FREEGLUT_EXIT_IF_NO_WINDOW ( "glutFullScreenToggle" );
+
+    {
+#if TARGET_HOST_POSIX_X11
+
+      if (fgDisplay.StateFullScreen != None)
+      {
+        XEvent xevent;
+        long event_mask;
+        int status;
+
+        xevent.type = ClientMessage;
+        xevent.xclient.type = ClientMessage;
+        xevent.xclient.serial = 0;
+        xevent.xclient.send_event = True;
+        xevent.xclient.display = fgDisplay.Display;
+        xevent.xclient.window = fgStructure.CurrentWindow->Window.Handle;
+        xevent.xclient.message_type = fgDisplay.State;
+        xevent.xclient.format = 32;
+        xevent.xclient.data.l[0] = 2;  /* _NET_WM_STATE_TOGGLE */
+        xevent.xclient.data.l[1] = fgDisplay.StateFullScreen;
+        xevent.xclient.data.l[2] = 0;
+        xevent.xclient.data.l[3] = 0;
+        xevent.xclient.data.l[4] = 0;
+
+        /*** Don't really understand how event masks work... ***/
+        event_mask = SubstructureRedirectMask | SubstructureNotifyMask;
+
+        status = XSendEvent(fgDisplay.Display,
+          fgDisplay.RootWindow,
+          False,
+          event_mask,
+          &xevent);
+        FREEGLUT_INTERNAL_ERROR_EXIT(status != 0,
+          "XSendEvent failed",
+          "glutFullScreenToggle");
+      }
+      else
+#endif
+      {
+        /*
+         * If the window manager is not Net WM compliant, fall back to legacy
+         * behaviour.
+         */
+        glutFullScreen();
+      }
+    }
+}
+
+/*
  * A.Donev: Set and retrieve the window's user data
  */
 void* FGAPIENTRY glutGetWindowData( void )
diff -ruN freeglut-2.4.0/src/freeglutdll.def freeglut-2.4.0-svn759/src/freeglutdll.def
--- freeglut-2.4.0/src/freeglutdll.def	2005-05-04 06:59:45.000000000 -0600
+++ freeglut-2.4.0-svn759/src/freeglutdll.def	2008-11-09 23:05:14.000000000 -0700
@@ -15,6 +15,8 @@
 	glutDestroyWindow
 	glutSetWindow
 	glutGetWindow
+	glutSetWindowData
+	glutGetWindowData
 	glutSetWindowTitle
 	glutSetIconTitle
 	glutReshapeWindow
@@ -41,6 +43,8 @@
 	glutDestroyMenu
 	glutGetMenu
 	glutSetMenu
+	glutGetMenuData
+	glutSetMenuData
 	glutAddMenuEntry
 	glutAddSubMenu
 	glutChangeToMenuEntry
@@ -56,6 +60,7 @@
 	glutVisibilityFunc
 	glutDisplayFunc
 	glutMouseFunc
+	glutMouseWheelFunc
 	glutMotionFunc
 	glutPassiveMotionFunc
 	glutEntryFunc
@@ -66,6 +71,7 @@
 	glutJoystickFunc
 	glutMenuStateFunc
 	glutMenuStatusFunc
+	glutMenuDestroyFunc
 	glutOverlayDisplayFunc
 	glutWindowStatusFunc
 	glutSpaceballMotionFunc
@@ -112,6 +118,8 @@
 	glutSolidSierpinskiSponge
 	glutWireTeapot
 	glutSolidTeapot
+	glutWireCylinder
+	glutSolidCylinder
 	glutGameModeString
 	glutEnterGameMode
 	glutLeaveGameMode
@@ -129,4 +137,17 @@
 	glutForceJoystickFunc
 	glutExtensionSupported
 	glutReportErrors
-
+	glutGetProcAddress
+	glutJoystickGetNumAxes
+	glutJoystickGetNumButtons
+	glutJoystickNotWorking
+	glutJoystickGetDeadBand
+	glutJoystickSetDeadBand
+	glutJoystickGetSaturation
+	glutJoystickSetSaturation
+	glutJoystickSetMinRange
+	glutJoystickSetMaxRange
+	glutJoystickSetCenter
+	glutJoystickGetMinRange
+	glutJoystickGetMaxRange
+	glutJoystickGetCenter
